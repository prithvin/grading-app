(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Turbolinks = window.Turbolinks = require('turbolinks').Turbolinks
require('./lib/tnurboforms')
require('compose-shell')

// Setup routes
require('compose-router').setErrorHandler(function(error){
  Megatron.notify.error(error.message)
})

require('./mongodb')

var NProgress = require('nprogress')

NProgress.configure({showSpinner: false})

Megatron.Event.on(document, 'page:fetch', function() { NProgress.start() })
Megatron.Event.on(document, 'page:change', function() { NProgress.done() })
Megatron.Event.on(document, 'page:restore', function() { NProgress.remove() })

Megatron.Event.on(document, 'click', '.turbo-nav', function(event){
  var selectedText = getSelectionText()
  if (selectedText)
    return
  var href = event.currentTarget.querySelector('a').getAttribute('href')
  if (event.metaKey || event.ctrlKey) {
    window.open(href, '_blank')
  } else {
    Turbolinks.visit(href)
  }
})
function getSelectionText() {
  var text = ""
  if (window.getSelection) {
    text = window.getSelection().toString()
  } else if (document.selection && document.selection.type != "Control") {
    text = document.selection.createRange().text
  }
  return text
}
;

},{"./lib/turboforms":4,"./mongodb":7,"compose-router":14,"compose-shell":19,"nprogress":35,"turbolinks":45}],2:[function(require,module,exports){
var _, dateFormat;

_ = Megatron._;

dateFormat = require("./date.format");

module.exports = {
  getIndentation: function(level, indentation) {
    var pad;
    if (indentation) {
      pad = "\n";
      _.times(level * indentation, (function(_this) {
        return function() {
          return pad += " ";
        };
      })(this));
      return pad;
    } else {
      return " ";
    }
  },
  toBsonString: function(json, options) {
    var d, emptyObject, indentation, level, p, result, v;
    if (options == null) {
      options = {};
    }
    level = options.level || 0;
    if (options.indentation != null) {
      indentation = options.indentation;
    } else {
      indentation = 2;
    }
    result = "";
    emptyObject = true;
    if (result !== "") {
      result += "" + (this.getIndentation(level, indentation));
    }
    if (options.valueOnly) {
      return this.parseValue(json, result, level, indentation, options);
    } else if (json instanceof Array) {
      result += "[";
    } else if (json instanceof Object) {
      result += "{";
    }
    for (p in json) {
      v = json[p];
      emptyObject = false;
      result += this.getIndentation(level + 1, indentation);
      if (!(json instanceof Array)) {
        if (options.html) {
          if (p.match(/[^A-z0-9_]/)) {
            d = document.createElement('div');
            d.textContent = p;
            result += "<span class='key'>\"" + d.innerHTML + "\"</span>: ";
          } else {
            result += "<span class='key'>" + p + "</span>: ";
          }
        } else {
          if (p.match(/^\d|[^A-z0-9_]/)) {
            result += "\"" + (p.replace(/"/g, '\\"')) + "\": ";
          } else {
            result += p + ": ";
          }
        }
      }
      result = this.parseValue(v, result, level, indentation, options);
    }
    if (result.slice(-1) === ",") {
      result = result.slice(0, -1);
    }
    if (!emptyObject) {
      result += this.getIndentation(level, indentation);
    }
    if (json instanceof Array) {
      return result += "]";
    } else if (json instanceof Object) {
      return result += "}";
    }
  },
  parseValue: function(v, result, level, indentation, options) {
    var className, dt, dtf, val;
    if (_.isNull(v)) {
      if (options.html) {
        result += "<span class='value'>null</span>,";
      } else {
        result += "null,";
      }
    } else if (typeof v === "object") {
      switch (v.constructor.name) {
        case "ObjectID":
          if (options.html) {
            result += "<span class='function'>ObjectId</span>(<span class='string'>\"<span class='_id'>" + (v.toString()) + "</span>\"</span>),";
          } else {
            result += "ObjectId(\"" + (v.toString()) + "\"),";
          }
          break;
        case "Date":
          dt = new Date(v.toString());
          dtf = dateFormat(dt, 'isoUtcDateTime');
          if (dt.getMilliseconds() > 0) {
            dtf = dtf.replace(/Z$/, "." + (dateFormat(dt, 'l')) + "Z");
          }
          if (options.html) {
            result += "<span class='function'>ISODate</span>(<span class='string'>\"" + dtf + "\"</span>),";
          } else {
            result += "ISODate(\"" + dtf + "\"),";
          }
          break;
        case "RegExp":
          if (options.html) {
            result += "<span class='regex'>/" + (v.toString()) + "</span>,";
          } else {
            result += "/" + (v.toString()) + ",";
          }
          break;
        default:
          if (v["$oid"]) {
            if (options.html) {
              result += "<span class='function'>ObjectId</span>(<span class='string'>\"<span class='_id'>" + v["$oid"] + "</span>\"</span>),";
            } else {
              result += "ObjectId(\"" + v["$oid"] + "\"),";
            }
          } else if (v["$date"] != null) {
            dt = new Date(v['$date']);
            dtf = dateFormat(dt, 'isoUtcDateTime');
            if (dt.getMilliseconds() > 0) {
              dtf = dtf.replace(/Z$/, "." + (dateFormat(dt, 'l')) + "Z");
            }
            if (options.html) {
              result += "<span class='function'>ISODate</span>(<span class='string'>\"" + dtf + "\"</span>),";
            } else {
              result += "ISODate(\"" + dtf + "\"),";
            }
          } else if (v["$long"]) {
            if (options.html) {
              result += "<span class='function'>NumberLong</span>(\"" + v['$long'] + "\"),";
            } else {
              result += "NumberLong(\"" + v['$long'] + "\"),";
            }
          } else if (v["$regex"]) {
            if (options.html) {
              result += "<span class='regex'>/" + v["$regex"] + "/" + v["$options"] + "</span>,";
            } else {
              result += "/" + v["$regex"] + "/" + v["$options"] + ",";
            }
          } else if (v["t"] >= 0 && v["i"] >= 0) {
            if (options.html) {
              result += "<span class='function'>Timestamp</span>(" + v["t"] + ", " + v["i"] + "),";
            } else {
              result += "Timestamp(" + v["t"] + ", " + v["i"] + "),";
            }
          } else if (v["$ref"]) {
            if (options.html) {
              result += "<span class='function'>DBRef</span>(\"<span class='string'>" + v["$ref"] + "</span>\", " + (this.toBsonString(v["$id"], {
                level: level + 1,
                valueOnly: true,
                html: true
              }));
              if (v["$db"]) {
                result += ", \"<span class='string'>" + v["$db"] + "</span>\"";
              }
              result += "),";
            } else {
              result += "DBRef(\"" + v["$ref"] + "\", " + (this.toBsonString(v["$id"], {
                level: level + 1,
                valueOnly: true,
                html: false
              })) + "),";
            }
          } else if (v['$binary']) {
            if (options.html) {
              result += "<span class='function'>BinData</span>(<span class='number'>" + v['$type'] + "</span>,<span class='string'>\"" + v['$binary'] + "\"</span>),";
            } else {
              result += "BinData(" + v['$type'] + ", \"" + v['$binary'] + "\"),";
            }
          } else {
            result += (this.toBsonString(v, {
              level: level + 1,
              indentation: indentation,
              html: options.html
            })) + ",";
          }
      }
    } else {
      val = JSON.stringify(v);
      if (options.html) {
        val = val.replace(/</g, '&lt;');
        className = 'string';
        if (val === 'false' || val === 'true') {
          className = 'value';
        }
        if (typeof v === 'number') {
          className = 'number';
        }
        result += "<span class='" + className + "'>" + val + "</span>,";
      } else {
        result += val + ",";
      }
    }
    if (options.valueOnly) {
      if (result.slice(-1) === ",") {
        result = result.slice(0, -1);
      }
    }
    return result;
  },
  sanitizeRegex: function(json) {
    var p, regexp_parts, v;
    for (p in json) {
      v = json[p];
      if (v instanceof RegExp) {
        regexp_parts = v.toString().match(/^\/(.*)\/([gim]*)$/);
        json[p] = {
          $regex: regexp_parts[1],
          $options: regexp_parts[2]
        };
      } else if (p === "$oid" && typeof v === "undefined") {
        alert("json[p] = window.dblayer.page_data.document_oids.shift()");
      } else if (p === "$date" && typeof v === "undefined") {
        json[p] = (new Date()).getTime();
      } else if (typeof v === "object") {
        json[p] = this.sanitizeRegex(v);
      }
    }
    return json;
  },
  bsonEval: function(src) {
    var error, json, mask, p, v;
    try {
      mask = {};
      for (p in this) {
        v = this[p];
        mask[v] = void 0;
      }
      mask.ObjectId = function(id) {
        return {
          $oid: id
        };
      };
      mask.Date = function(date) {
        return {
          $date: date
        };
      };
      mask.ISODate = function(date) {
        return {
          $date: (new Date(date)).getTime()
        };
      };
      mask.Timestamp = function(t, i) {
        return {
          "t": t,
          "i": i
        };
      };
      mask.DBRef = function(name, id, db) {
        return {
          $ref: name,
          $id: id,
          $db: db
        };
      };
      mask.NumberLong = function(num) {
        return {
          $long: num.toString()
        };
      };
      mask.BinData = function(type, data) {
        return {
          $type: type,
          $binary: data
        };
      };
      json = (new Function("with(this){ return " + src + " }")).call(mask);
      return this.sanitizeRegex(json);
    } catch (_error) {
      error = _error;
      throw error;
    }
  }
};



},{"./date.format":3}],3:[function(require,module,exports){
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * http://blog.stevenlevithan.com/archives/date-time-format
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

var dateFormat = function() {
  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
    timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
    timezoneClip = /[^-+\dA-Z]/g,
    pad = function (val, len) {
      val = String(val);
      len = len || 2;
      while (val.length < len) val = "0" + val;
      return val;
    };

  // Regexes and supporting functions are cached through closure
  return function (date, mask, utc) {
    var dF = dateFormat;

    // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
    if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
      mask = date;
      date = undefined;
    }

    // Passing date through Date applies Date.parse, if necessary
    date = date ? new Date(date) : new Date;
    if (isNaN(date)) throw SyntaxError("invalid date");

    mask = String(dF.masks[mask] || mask || dF.masks["default"]);

    // Allow setting the utc argument via the mask
    if (mask.slice(0, 4) == "UTC:") {
      mask = mask.slice(4);
      utc = true;
    }

    var _ = utc ? "getUTC" : "get",
      d = date[_ + "Date"](),
      D = date[_ + "Day"](),
      m = date[_ + "Month"](),
      y = date[_ + "FullYear"](),
      H = date[_ + "Hours"](),
      M = date[_ + "Minutes"](),
      s = date[_ + "Seconds"](),
      L = date[_ + "Milliseconds"](),
      o = utc ? 0 : date.getTimezoneOffset(),
      flags = {
        d:    d,
        dd:   pad(d),
        ddd:  dF.i18n.dayNames[D],
        dddd: dF.i18n.dayNames[D + 7],
        m:    m + 1,
        mm:   pad(m + 1),
        mmm:  dF.i18n.monthNames[m],
        mmmm: dF.i18n.monthNames[m + 12],
        yy:   String(y).slice(2),
        yyyy: y,
        h:    H % 12 || 12,
        hh:   pad(H % 12 || 12),
        H:    H,
        HH:   pad(H),
        M:    M,
        MM:   pad(M),
        s:    s,
        ss:   pad(s),
        l:    pad(L, 3),
        L:    pad(L > 99 ? Math.round(L / 10) : L),
        t:    H < 12 ? "a"  : "p",
        tt:   H < 12 ? "am" : "pm",
        T:    H < 12 ? "A"  : "P",
        TT:   H < 12 ? "AM" : "PM",
        Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
        o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
        S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
      };

    return mask.replace(token, function ($0) {
      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
    });
  };
}();

// Some common format strings
dateFormat.masks = {
  "default":      "ddd mmm dd yyyy HH:MM:ss",
  shortDate:      "m/d/yy",
  mediumDate:     "mmm d, yyyy",
  longDate:       "mmmm d, yyyy",
  fullDate:       "dddd, mmmm d, yyyy",
  shortTime:      "h:MM TT",
  mediumTime:     "h:MM:ss TT",
  longTime:       "h:MM:ss TT Z",
  isoDate:        "yyyy-mm-dd",
  isoTime:        "HH:MM:ss",
  isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
  isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
dateFormat.i18n = {
  dayNames: [
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
  ],
  monthNames: [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
  ]
};

// For convenience...
Date.prototype.format = function (mask, utc) {
  return dateFormat(this, mask, utc);
};

module.exports = dateFormat;
},{}],4:[function(require,module,exports){
var serialize = require('serialize')
var Turbolinks = require('turbolinks').Turbolinks

Megatron.Event.on(document, 'submit', 'form[data-turboform]', function(event){
  console.log('Megatron.event form[data-turboform] submit')
  event.preventDefault()
  Turbolinks.visit(location.pathname + '?' + serialize(event.currentTarget))
})
},{"serialize":44,"turbolinks":45}],5:[function(require,module,exports){
var route = require('compose-router')
var BSON = require('../lib/bson')

// Collection settings page.
route(
  '/:account/deployments/:deployment/mongodb/databases/:database/collections/:collection/edit',
  collectionSettingsPage
)

// Sandboxes
route(
  '/:account/mongodb/databases/:database/collections/:collection/edit',
  collectionSettingsPage
)


function collectionSettingsPage(ctx, next){
  var statsEl = document.querySelector('.collection-info')
  statsEl.className += " language-json"
  statsEl.innerHTML = BSON.toBsonString(JSON.parse(statsEl.innerHTML))
  Megatron.utils.highlightCode()
}
},{"../lib/bson":2,"compose-router":14}],6:[function(require,module,exports){
var route = require('compose-router')
var BSON = require('../lib/bson')
var Turbolinks = require('turbolinks').Turbolinks

// Cluster show page.
route(
  '/:account/deployments/:deployment/mongodb/cluster',
  documentsIndexPage
)
// Documents index page.
route(
  '/:account/deployments/:deployment/mongodb/databases/:database/collections/:collection/documents',
  documentsIndexPage
)
route(
  '/:account/mongodb/databases/:database/collections/:collection/documents',
  documentsIndexPage
)

// Document SHOW page.
route(
  '/:account/deployments/:deployment/mongodb/databases/:database/collections/:collection/documents/:doc_id',
  documentsShowPage
)
route(
  '/:account/mongodb/databases/:database/collections/:collection/documents/:doc_id',
  documentsShowPage
)

window.initialValue = null

function prettyBson(){
  var bsonEls = document.querySelectorAll('.bson-plain')
  Megatron._.each(bsonEls, function(bsonEl){
    var bsonString = BSON.toBsonString(JSON.parse(bsonEl.innerHTML), {
      valueOnly: true
    })
    bsonEl.innerHTML = bsonString
    bsonEl.classList.remove('bson-plain')
  })
}

function documentsIndexPage(ctx, next){
  // BSON parsing.

  var docEls = document.querySelectorAll('.bson-code > div')
  Megatron._.each(docEls, function(docEl){
    try {
      var bson = BSON.toBsonString(JSON.parse(docEl.innerHTML), {
        indentation: ctx.query['explain'] ? 2 : 0,
        html: true
      })
    } catch (err) {
      // Bugsnag prob...
    }
    if (typeof bson !== 'undefined') {
      if (ctx.query['explain'])
        docEl.parentNode.innerHTML = '<pre>'+bson+'</pre>'
      else
        docEl.innerHTML = bson
    }
  })

  Megatron.Event.on(document.querySelector('.site'), 'click', '.document-summary', function(event){
    var selectedText = getSelectionText()
    if (!selectedText) {
      var href = event.currentTarget.querySelector('a').getAttribute('href')
      if (event.metaKey || event.ctrlKey) {
        window.open(href, '_blank')
      } else {
        Turbolinks.visit(href)
      }
    }
  })

  prettyBson()
  next() 
}

function documentsShowPage(ctx, next){
  var docTxt = document.querySelector('.code-editor-content textarea')
  if (!docTxt)
    return
  try {
    initialValue = docTxt.value = BSON.toBsonString(JSON.parse(docTxt.value), {
      indentation: 2,
      html: false
    })
  } catch (error) {
    // Probably already parsed, the user might have pressed the back button.
    // Megatron.notify.error("Parsing failed: "+error.message)
    initialValue = docTxt.value
  }
  
  Megatron.utils.CodeMirror.fromTextArea(docTxt, {
    mode: {
      name: "javascript",
      json: true
    },
    indentUnit: 2,
    matchBrackets: true,
    lineWrapping: true
  })

  prettyBson()
  next()
}

function formatBSONError(error) {
  console.log('BSON error', error)
  var msg = error instanceof Error ? error.message : error
  if (msg !== 'Cannot save documents with Binary values')
    return 'This document contains invalid BSON'
  return msg
}

function getSelectionText() {
  var text = ""
  if (window.getSelection) {
    text = window.getSelection().toString()
  } else if (document.selection && document.selection.type != "Control") {
    text = document.selection.createRange().text
  }
  return text
}

// Event delegation

// Validation
Megatron.Event.on(document, 'click', '.validate-document', function(event){
  event.preventDefault()
  var editor = getDocumentEditor()
  try {
    editor.setValue(BSON.toBsonString(BSON.bsonEval(editor.getValue())))
    Megatron.notify.success('This document is valid.')
  } catch (error) {
    Megatron.notify.error(formatBSONError(error))
  }
})

// Save
Megatron.Event.on(document, 'click', '.save-document', function(event){
  event.preventDefault()
  var editor = getDocumentEditor()
  // Update a hidden field with the new document data
  document.querySelector('#document_doc').value = JSON.stringify(BSON.bsonEval(editor.getValue()))
  document.querySelector('#doc-form').submit()
})

// Revert to original value
Megatron.Event.on(document, 'click', '.revert-document', function(event){
  event.preventDefault()
  var editor = getDocumentEditor()
  editor.setValue(initialValue)
  Megatron.notify.success('Document editor reverted to value when the page was initially loaded.')
})

function getDocumentEditor(){
  return document.querySelector('.code-editor-content .CodeMirror').CodeMirror
}

},{"../lib/bson":2,"compose-router":14,"turbolinks":45}],7:[function(require,module,exports){
require('./documents')
require('./indexes')
require('./collections')
require('./users')

require('./monitoring')
},{"./collections":5,"./documents":6,"./indexes":8,"./monitoring":9,"./users":13}],8:[function(require,module,exports){
var route = require('compose-router')
var BSON = require('../lib/bson')
 
// Indexes index page.
route(
  '/:account/deployments/:deployment/mongodb/databases/:database/collections/:collection/indexes',
  indexesIndexPage
)
route(
  '/:account/mongodb/databases/:database/collections/:collection/indexes',
  indexesIndexPage
)

function indexesIndexPage(ctx, next){
  var docEls = document.querySelectorAll('.bson-code .table-cell')
  Megatron._.each(docEls, function(docEl){
    try {
      var bson = BSON.toBsonString(JSON.parse(docEl.innerHTML), {
        indentation: 0,
        html: true
      })
    } catch (err) {
      // Bugsnag prob...
    }
    if (typeof bson !== 'undefined')
      docEl.innerHTML = bson
  })

  next()
}
},{"../lib/bson":2,"compose-router":14}],9:[function(require,module,exports){
require('./operations')
require('./logs')
require('./server_status')
},{"./logs":10,"./operations":11,"./server_status":12}],10:[function(require,module,exports){
var route = require('compose-router')
var request = require('superagent')

window.logStreamInterval = null

Megatron.Event.on(document, 'page:before-change', function(event){
  if (logStreamInterval)
    clearInterval(logStreamInterval)
})

// Indexes index page.
route(
  '/:account/deployments/:deployment/mongodb/monitoring/:hostname/logs',
  function(ctx, next){
    // return next()
    var logsContainer = document.querySelector('.mongolog ul')
    var logs = document.querySelectorAll('.mongolog li')
    if (logs.length > 0) {
      var lastLogTimestamp = logs[logs.length - 1].getAttribute('data-timestamp')
      logStreamInterval = setInterval(function(){
        request
          .get(window.location.pathname)
          .query({from: lastLogTimestamp})
          .accept('json')
          .end(function(error, resp){
            if (error || !resp.ok || resp.body.length === 0)
              return
            var logsFragment = document.createDocumentFragment()
            for (var i = 0; resp.body.length > i; i++) {
              var newLogEl = document.createElement('li')
              newLogEl.textContent = resp.body[i].raw
              logsFragment.appendChild(newLogEl)

            }
            lastLogTimestamp = resp.body[resp.body.length - 1].timestamp
            logsContainer.appendChild(logsFragment)
          })
      }, 1000 * 5)
    }
    next()
  }
)
},{"compose-router":14,"superagent":41}],11:[function(require,module,exports){
var route = require('compose-router')
var BSON = require('../../lib/bson')
 
// Indexes index page.
route(
  '/:account/deployments/:deployment/mongodb/monitoring/:hostname/operations',
  function(ctx, next){
    var docEls = document.querySelectorAll('.table-cell.bson-code')
    Megatron._.each(docEls, function(docEl){
      try {
        var bson = BSON.toBsonString(JSON.parse(docEl.innerHTML), {
          indentation: 0,
          html: true
        })
      } catch (err) {
        console.log("error parsing", err)
        // Bugsnag prob...
      }
      if (typeof bson !== 'undefined')
        docEl.innerHTML = bson
    })

    next()
  }
)
},{"../../lib/bson":2,"compose-router":14}],12:[function(require,module,exports){
var route = require('compose-router')
var request = require('superagent')

window.serverStatusStreamInterval = null

Megatron.Event.on(document, 'page:before-change', function(event){
  if (serverStatusStreamInterval)
    clearInterval(serverStatusStreamInterval)
})

// Indexes index page.
route(
  '/:account/deployments/:deployment/mongodb/monitoring/:hostname/server_status',
  function(ctx, next){
    console.log('hello')

    return next()
    // var logsContainer = document.querySelector('.mongolog ul')
    // var logs = document.querySelectorAll('.mongolog li')
    // if (logs.length > 0) {
    //   var lastLogTimestamp = logs[logs.length - 1].getAttribute('data-timestamp')
    //   logStreamInterval = setInterval(function(){
    //     request
    //       .get(window.location.pathname)
    //       .query({from: lastLogTimestamp})
    //       .accept('json')
    //       .end(function(error, resp){
    //         if (error || !resp.ok || resp.body.length === 0)
    //           return
    //         var logsFragment = document.createDocumentFragment()
    //         for (var i = 0; resp.body.length > i; i++) {
    //           var newLogEl = document.createElement('li')
    //           newLogEl.textContent = resp.body[i].raw
    //           logsFragment.appendChild(newLogEl)

    //         }
    //         lastLogTimestamp = resp.body[resp.body.length - 1].timestamp
    //         logsContainer.appendChild(logsFragment)
    //       })
    //   }, 1000)
    // }
    // next()
  }
)
},{"compose-router":14,"superagent":41}],13:[function(require,module,exports){
var route = require('compose-router')
var BSON = require('../lib/bson')
 
// Users index page.
route(
  '/:account/deployments/:deployment/mongodb/databases/:database/users',
  usersIndexPage
)
route(
  '/:account/mongodb/databases/:database/users',
  usersIndexPage
)

function usersIndexPage(ctx, next){
  var docEls = document.querySelectorAll('.bson-code .table-cell')
  Megatron._.each(docEls, function(docEl){
    try {
      var bson = BSON.toBsonString(JSON.parse(docEl.innerHTML), {
        indentation: 0,
        html: true
      })
    } catch (err) {
      // Bugsnag prob...
    }
    if (typeof bson !== 'undefined')
      docEl.innerHTML = bson
  })

  next()
}

},{"../lib/bson":2,"compose-router":14}],14:[function(require,module,exports){
var Router = require('routes')
var router = Router()
var qs = require('qs')

// noop error handler, modify by using `route.setErrorHandler(func)`
var errorHandler = function(){}

module.exports = route

// Turbolinks fires a page:change event on the document
document.addEventListener('page:change', function(){
  // Delay is for redirections...
  setTimeout(function(){
    callHandlerFromMatch(router.match(window.location.pathname))
  }, 25)
})

function route(){
  router.addRoute.apply(router, arguments)
}

route.setErrorHandler = function setErrorHandler(fn){
  errorHandler = fn
}

function buildNextFromMatch(match){
  var next = match.next()
  if (!next) return handleNextError

  return function(error){
    if (error) return handleNextError(error)
    callHandlerFromMatch(next)
  }
}

function handleNextError(error){
  if (!error) return
  if (!(error instanceof Error))
    throw "Passed error needs to be an instance of Error"

  errorHandler(error)
}

function buildContextFromMatch(match) {
  return {
    params: match['params'],
    splats: match['splats'],
    query: location.search ? qs.parse(location.search.slice(1)) : {}
  }
}

function callHandlerFromMatch(match) {
  if (!match) return
  match.fn.call(null, buildContextFromMatch(match), buildNextFromMatch(match))
}

},{"qs":36,"routes":15}],15:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.routes=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

var localRoutes = [];


/**
 * Convert path to route object
 *
 * A string or RegExp should be passed,
 * will return { re, src, keys} obj
 *
 * @param  {String / RegExp} path
 * @return {Object}
 */

var Route = function(path){
  //using 'new' is optional

  var src, re, keys = [];

  if(path instanceof RegExp){
    re = path;
    src = path.toString();
  }else{
    re = pathToRegExp(path, keys);
    src = path;
  }

  return {
  	 re: re,
  	 src: path.toString(),
  	 keys: keys
  }
};

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String} path
 * @param  {Array} keys
 * @return {RegExp}
 */
var pathToRegExp = function (path, keys) {
	path = path
		.concat('/?')
		.replace(/\/\(/g, '(?:/')
		.replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?|\*/g, function(_, slash, format, key, capture, optional){
			if (_ === "*"){
				keys.push(undefined);
				return _;
			}

			keys.push(key);
			slash = slash || '';
			return ''
				+ (optional ? '' : slash)
				+ '(?:'
				+ (optional ? slash : '')
				+ (format || '') + (capture || '([^/]+?)') + ')'
				+ (optional || '');
		})
		.replace(/([\/.])/g, '\\$1')
		.replace(/\*/g, '(.*)');
	return new RegExp('^' + path + '$', 'i');
};

/**
 * Attempt to match the given request to
 * one of the routes. When successful
 * a  {fn, params, splats} obj is returned
 *
 * @param  {Array} routes
 * @param  {String} uri
 * @return {Object}
 */
var match = function (routes, uri, startAt) {
	var captures, i = startAt || 0;

	for (var len = routes.length; i < len; ++i) {
		var route = routes[i],
		    re = route.re,
		    keys = route.keys,
		    splats = [],
		    params = {};

		if (captures = uri.match(re)) {
			for (var j = 1, len = captures.length; j < len; ++j) {
				var key = keys[j-1],
					val = typeof captures[j] === 'string'
						? unescape(captures[j])
						: captures[j];
				if (key) {
					params[key] = val;
				} else {
					splats.push(val);
				}
			}
			return {
				params: params,
				splats: splats,
				route: route.src,
				next: i + 1
			};
		}
	}
};

/**
 * Default "normal" router constructor.
 * accepts path, fn tuples via addRoute
 * returns {fn, params, splats, route}
 *  via match
 *
 * @return {Object}
 */

var Router = function(){
  //using 'new' is optional
  return {
    routes: [],
    routeMap : {},
    addRoute: function(path, fn){
      if (!path) throw new Error(' route requires a path');
      if (!fn) throw new Error(' route ' + path.toString() + ' requires a callback');

      var route = Route(path);
      route.fn = fn;

      this.routes.push(route);
      this.routeMap[path] = fn;
    },

    match: function(pathname, startAt){
      var route = match(this.routes, pathname, startAt);
      if(route){
        route.fn = this.routeMap[route.route];
        route.next = this.match.bind(this, pathname, route.next)
      }
      return route;
    }
  }
};

Router.Route = Route
Router.pathToRegExp = pathToRegExp
Router.match = match
// back compat
Router.Router = Router

module.exports = Router

},{}]},{},[1])
(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb3NlLXJvdXRlci9ub2RlX21vZHVsZXMvcm91dGVzL2Rpc3Qvcm91dGVzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYucm91dGVzPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG52YXIgbG9jYWxSb3V0ZXMgPSBbXTtcblxuXG4vKipcbiAqIENvbnZlcnQgcGF0aCB0byByb3V0ZSBvYmplY3RcbiAqXG4gKiBBIHN0cmluZyBvciBSZWdFeHAgc2hvdWxkIGJlIHBhc3NlZCxcbiAqIHdpbGwgcmV0dXJuIHsgcmUsIHNyYywga2V5c30gb2JqXG4gKlxuICogQHBhcmFtICB7U3RyaW5nIC8gUmVnRXhwfSBwYXRoXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxudmFyIFJvdXRlID0gZnVuY3Rpb24ocGF0aCl7XG4gIC8vdXNpbmcgJ25ldycgaXMgb3B0aW9uYWxcblxuICB2YXIgc3JjLCByZSwga2V5cyA9IFtdO1xuXG4gIGlmKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApe1xuICAgIHJlID0gcGF0aDtcbiAgICBzcmMgPSBwYXRoLnRvU3RyaW5nKCk7XG4gIH1lbHNle1xuICAgIHJlID0gcGF0aFRvUmVnRXhwKHBhdGgsIGtleXMpO1xuICAgIHNyYyA9IHBhdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICBcdCByZTogcmUsXG4gIFx0IHNyYzogcGF0aC50b1N0cmluZygpLFxuICBcdCBrZXlzOiBrZXlzXG4gIH1cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZyxcbiAqIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBzaG91bGQgYmUgcGFzc2VkLFxuICogd2hpY2ggd2lsbCBjb250YWluIHRoZSBwbGFjZWhvbGRlclxuICoga2V5IG5hbWVzLiBGb3IgZXhhbXBsZSBcIi91c2VyLzppZFwiIHdpbGxcbiAqIHRoZW4gY29udGFpbiBbXCJpZFwiXS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbnZhciBwYXRoVG9SZWdFeHAgPSBmdW5jdGlvbiAocGF0aCwga2V5cykge1xuXHRwYXRoID0gcGF0aFxuXHRcdC5jb25jYXQoJy8/Jylcblx0XHQucmVwbGFjZSgvXFwvXFwoL2csICcoPzovJylcblx0XHQucmVwbGFjZSgvKFxcLyk/KFxcLik/OihcXHcrKSg/OihcXCguKj9cXCkpKT8oXFw/KT98XFwqL2csIGZ1bmN0aW9uKF8sIHNsYXNoLCBmb3JtYXQsIGtleSwgY2FwdHVyZSwgb3B0aW9uYWwpe1xuXHRcdFx0aWYgKF8gPT09IFwiKlwiKXtcblx0XHRcdFx0a2V5cy5wdXNoKHVuZGVmaW5lZCk7XG5cdFx0XHRcdHJldHVybiBfO1xuXHRcdFx0fVxuXG5cdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdHNsYXNoID0gc2xhc2ggfHwgJyc7XG5cdFx0XHRyZXR1cm4gJydcblx0XHRcdFx0KyAob3B0aW9uYWwgPyAnJyA6IHNsYXNoKVxuXHRcdFx0XHQrICcoPzonXG5cdFx0XHRcdCsgKG9wdGlvbmFsID8gc2xhc2ggOiAnJylcblx0XHRcdFx0KyAoZm9ybWF0IHx8ICcnKSArIChjYXB0dXJlIHx8ICcoW14vXSs/KScpICsgJyknXG5cdFx0XHRcdCsgKG9wdGlvbmFsIHx8ICcnKTtcblx0XHR9KVxuXHRcdC5yZXBsYWNlKC8oW1xcLy5dKS9nLCAnXFxcXCQxJylcblx0XHQucmVwbGFjZSgvXFwqL2csICcoLiopJyk7XG5cdHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHBhdGggKyAnJCcsICdpJyk7XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gbWF0Y2ggdGhlIGdpdmVuIHJlcXVlc3QgdG9cbiAqIG9uZSBvZiB0aGUgcm91dGVzLiBXaGVuIHN1Y2Nlc3NmdWxcbiAqIGEgIHtmbiwgcGFyYW1zLCBzcGxhdHN9IG9iaiBpcyByZXR1cm5lZFxuICpcbiAqIEBwYXJhbSAge0FycmF5fSByb3V0ZXNcbiAqIEBwYXJhbSAge1N0cmluZ30gdXJpXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBtYXRjaCA9IGZ1bmN0aW9uIChyb3V0ZXMsIHVyaSwgc3RhcnRBdCkge1xuXHR2YXIgY2FwdHVyZXMsIGkgPSBzdGFydEF0IHx8IDA7XG5cblx0Zm9yICh2YXIgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0dmFyIHJvdXRlID0gcm91dGVzW2ldLFxuXHRcdCAgICByZSA9IHJvdXRlLnJlLFxuXHRcdCAgICBrZXlzID0gcm91dGUua2V5cyxcblx0XHQgICAgc3BsYXRzID0gW10sXG5cdFx0ICAgIHBhcmFtcyA9IHt9O1xuXG5cdFx0aWYgKGNhcHR1cmVzID0gdXJpLm1hdGNoKHJlKSkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDEsIGxlbiA9IGNhcHR1cmVzLmxlbmd0aDsgaiA8IGxlbjsgKytqKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBrZXlzW2otMV0sXG5cdFx0XHRcdFx0dmFsID0gdHlwZW9mIGNhcHR1cmVzW2pdID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyB1bmVzY2FwZShjYXB0dXJlc1tqXSlcblx0XHRcdFx0XHRcdDogY2FwdHVyZXNbal07XG5cdFx0XHRcdGlmIChrZXkpIHtcblx0XHRcdFx0XHRwYXJhbXNba2V5XSA9IHZhbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzcGxhdHMucHVzaCh2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRwYXJhbXM6IHBhcmFtcyxcblx0XHRcdFx0c3BsYXRzOiBzcGxhdHMsXG5cdFx0XHRcdHJvdXRlOiByb3V0ZS5zcmMsXG5cdFx0XHRcdG5leHQ6IGkgKyAxXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBEZWZhdWx0IFwibm9ybWFsXCIgcm91dGVyIGNvbnN0cnVjdG9yLlxuICogYWNjZXB0cyBwYXRoLCBmbiB0dXBsZXMgdmlhIGFkZFJvdXRlXG4gKiByZXR1cm5zIHtmbiwgcGFyYW1zLCBzcGxhdHMsIHJvdXRlfVxuICogIHZpYSBtYXRjaFxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG52YXIgUm91dGVyID0gZnVuY3Rpb24oKXtcbiAgLy91c2luZyAnbmV3JyBpcyBvcHRpb25hbFxuICByZXR1cm4ge1xuICAgIHJvdXRlczogW10sXG4gICAgcm91dGVNYXAgOiB7fSxcbiAgICBhZGRSb3V0ZTogZnVuY3Rpb24ocGF0aCwgZm4pe1xuICAgICAgaWYgKCFwYXRoKSB0aHJvdyBuZXcgRXJyb3IoJyByb3V0ZSByZXF1aXJlcyBhIHBhdGgnKTtcbiAgICAgIGlmICghZm4pIHRocm93IG5ldyBFcnJvcignIHJvdXRlICcgKyBwYXRoLnRvU3RyaW5nKCkgKyAnIHJlcXVpcmVzIGEgY2FsbGJhY2snKTtcblxuICAgICAgdmFyIHJvdXRlID0gUm91dGUocGF0aCk7XG4gICAgICByb3V0ZS5mbiA9IGZuO1xuXG4gICAgICB0aGlzLnJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIHRoaXMucm91dGVNYXBbcGF0aF0gPSBmbjtcbiAgICB9LFxuXG4gICAgbWF0Y2g6IGZ1bmN0aW9uKHBhdGhuYW1lLCBzdGFydEF0KXtcbiAgICAgIHZhciByb3V0ZSA9IG1hdGNoKHRoaXMucm91dGVzLCBwYXRobmFtZSwgc3RhcnRBdCk7XG4gICAgICBpZihyb3V0ZSl7XG4gICAgICAgIHJvdXRlLmZuID0gdGhpcy5yb3V0ZU1hcFtyb3V0ZS5yb3V0ZV07XG4gICAgICAgIHJvdXRlLm5leHQgPSB0aGlzLm1hdGNoLmJpbmQodGhpcywgcGF0aG5hbWUsIHJvdXRlLm5leHQpXG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGU7XG4gICAgfVxuICB9XG59O1xuXG5Sb3V0ZXIuUm91dGUgPSBSb3V0ZVxuUm91dGVyLnBhdGhUb1JlZ0V4cCA9IHBhdGhUb1JlZ0V4cFxuUm91dGVyLm1hdGNoID0gbWF0Y2hcbi8vIGJhY2sgY29tcGF0XG5Sb3V0ZXIuUm91dGVyID0gUm91dGVyXG5cbm1vZHVsZS5leHBvcnRzID0gUm91dGVyXG5cbn0se31dfSx7fSxbMV0pXG4oMSlcbn0pOyJdfQ==
},{}],16:[function(require,module,exports){
var template = require('./templates/button.hbs')

xtag.register('compose-shell-button', {
  lifecycle: {
    created: function(){
      this.type = this.getAttribute('type')
      this.innerHTML = template({
        enabled: this.enabled,
        type: this.type,
        content: this.textContent
      })
    },
    inserted: function(){
      if (this.type !== 'submit')
        this.shell.registerButton(this)
    }
  },

  events: {
    'click:delegate(button)': function(event) {
      var button = event.currentTarget
      button.children[0].blur()
      if (button.type === 'submit')
        return
      event.preventDefault()
      event.currentTarget.enabled = !event.currentTarget.enabled
      xtag.fireEvent(button, 'toggle')
    }
  },

  accessors: {
    enabled: {
      get: function(){ return !!this.getAttribute('enabled') },
      set: function(enabled){
        if (enabled === true)
          this.setAttribute('enabled', true)
        else if (enabled === false)
          this.removeAttribute('enabled')
      }
    },
    toggle: {
      get: function(){ return this.getAttribute('toggle') }
    }
  }
})

},{"./templates/button.hbs":31}],17:[function(require,module,exports){
var template = require('./templates/param.hbs')
var BSON = require('./lib/bson')
var cssAnimEventTypes = require('./lib/anim-events')

xtag.register('compose-shell-param', {
  lifecycle: {
    created: function(){
      this.params = xtag.queryChildren(this, 'compose-shell-param')
      this.group = !!this.params.length

      this.innerHTML = template({
        before: this.getAttribute('before'),
        group: this.group,
        editable: this.editable,
        value: this.parseValue(this.getAttribute('value')),
        type: this.type,
        content: this.textContent,
        after: this.getAttribute('after'),
        placeholder: this.placeholder
      })
    },
    inserted: function(){
      this.hide()

      if (this.params.length > 0) {
        var groupEl = this.querySelector('.params-group')
        for (var param in this.params) {
          // this.onShellSet.push(function(){
          //   this.params[param].shell = this.shell
          // })
          this.params[param].shell = this.shell
          this.params[param].addEventListener('show', this.updateVisibility.bind(this))
          this.params[param].addEventListener('hide', this.updateVisibility.bind(this))
          groupEl.appendChild(this.params[param])
        }
      }

      if (this.type)
        this.shell.registerParam(this)// this.onShellSet = [function(){this.shell.registerParam(this)}].concat(this.onShellSet)

      if (this.type === 'text' || (this.getAttribute('value') || this.required))
        this.visible = true
      if (this.getAttribute('focus'))
        this.focusInput()
    }
  },

  events: {
    'focus:delegate(span[contenteditable])': function(event) {
      var param = event.currentTarget
      if (param.group) return
      if (param.placeholder) {
        if (this.textContent === param.placeholder && /placeholder/.test(this.className))
          this.textContent = ''
      }
      param.setCursorAtEnd()
    },
    'blur:delegate(span[contenteditable])': function(event) {
      var param = event.currentTarget
      if (param.group) return
      if (param.placeholder)
        if (this.textContent === '') {
          this.textContent = param.placeholder
          if (!/placeholder/.test(this.className))
            this.className += ' placeholder'
        } else {
          this.className = this.className.replace('placeholder', '')
        }
    },
    'paste:delegate(span[contenteditable])': function(event){
      var param = event.currentTarget
      if (param.group) return
      event.preventDefault()
      if (event.clipboardData) {
        var content = (event.originalEvent || event).clipboardData.getData('text/plain').replace(/^\s+|\s+$/g, '')
        document.execCommand('insertText', false, content)
      }
      else if (window.clipboardData) {
        var content = window.clipboardData.getData('Text').replace(/^\s+|\s+$/g, '')
        document.selection.createRange().pasteHTML(content)
      }

    },
    show: function(event){
      if (this.hint)
        this.showHint()
    }
  },

  accessors: {
    // params: { get: function(){ return xtag.queryChildren(this, 'compose-shell-param') } },
    name: { get: function(){ return this.getAttribute('name') } },
    type: { get: function(){ return this.getAttribute('type') } },
    placeholder: { get: function(){ return this.getAttribute('placeholder') } },
    hint: { get: function(){ return this.getAttribute('hint') } },
    required: { get: function(){ return this.getAttribute('required') } },
    focus:    { get: function(){ return this.getAttribute('focus') } },
    // group: { get: function() { return this.params.length > 0 } },
    editable: { get: function() { return !this.group && this.type && this.type !== 'boolean' } },
    optional: { get: function(){ return !!this.getAttribute('optional') } },
    dependency: { get: function(){ return this.getAttribute('dependency') } },
    customInput: { get: function() { return this.querySelector('span[contenteditable]') } },
    parser: { get: function() { return this.getAttribute('parser') } },
    visible: {
      get: function(){ return !this.getAttribute('hidden') },
      set: function(visible){
        if (visible === true) {
          this.removeAttribute('hidden')
          xtag.fireEvent(this, 'show')
        } else if (visible === false) {
          this.setAttribute('hidden', true)
          xtag.fireEvent(this, 'hide')
        }
      }
    },

    value: {
      get: function(){
        var val;
        if (!this.visible)
          return null // no value
        if (this.type === 'boolean') {
          val = 1
        } else if (this.customInput) {
          // ensure stuff by blurring.
          this.customInput.blur()

          val = this.customInput.textContent.replace(/[\u200B-\u200D\uFEFF]/g, '')
          if (this.placeholder) {
            if (/placeholder/.test(this.customInput.className) && val === this.placeholder)
              val = ""
          }
          if (val && this.type === 'hash')
            val = '{' + val + '}'
        }
        return this.serializeValue(val)
      }
    }
  },

  methods: {
    toggle: function(){ this.visible = !this.visible },
    show: function(){ this.visible = true },
    hide: function(){ this.visible = false },

    focusInput: function(){
      if (this.customInput)
        this.customInput.focus()
    },
    
    updateVisibility: function(){
      this.visible = [].some.call(this.params, function(child){ return child.visible })
    },

    showHint: function(){
      var hintEl = this.querySelector('.hint')
      if (hintEl)
        this.removeChild(hintEl)
      
      hintEl = document.createElement('span')
      hintEl.className = 'hint'
      hintEl.textContent = this.hint

      clearTimeout(this.hintTimeout)
      this.appendChild(hintEl)
      this.hintTimeout = setTimeout(function(){
        hintEl.className += ' out'
        hintEl.addEventListener(cssAnimEventTypes.end, function animEnd(event){
          this.removeChild(hintEl)
          hintEl.removeEventListener(cssAnimEventTypes.end, animEnd)
        }.bind(this), false)
      }.bind(this), 2000)
    },

    setCursorAtEnd: function(){
      var text = this.customInput.firstChild
      if(text)
        this.setSelection(text.length, 0)
    },

    setSelection: function(start, length) {
      var el = this.customInput
      var range = document.createRange()
      range.setStart(el.firstChild, start)
      range.setEnd(el.firstChild, start + length)
      var sel = window.getSelection()
      sel.removeAllRanges()
      sel.addRange(range)
    },

    serializeValue: function(value){
      if (!this.parser)
        return value

      if (this.parser === 'bson') {
        try {
          return JSON.stringify(BSON.bsonEval(value))
        } catch (error) {
          console.log(error)
          xtag.fireEvent(this, 'error', {detail: {error: new Error('Unserializable value for ' + this.name)}})
          return value
        }
      }
    },
    
    parseValue: function(value){
      if (!this.parser)
        return value
      if (this.parser === 'bson' && value) {
        try {
          return stripWrapper(BSON.toBsonString(JSON.parse(value), {indentation: 0}))
        } catch (error) {
          console.log(error)
          xtag.fireEvent(this, 'error', {detail: {error: new Error('Unparsable value for ' + this.name)}})
          return value
        }
      }
    }
  }
})

function stripWrapper(queryString) {
  var matches = queryString.match(/\{(.+)\}/)
  if (matches)
    return matches[1]
}

},{"./lib/anim-events":20,"./lib/bson":21,"./templates/param.hbs":32}],18:[function(require,module,exports){
var template = require('./templates/shell.hbs')

xtag.register('compose-shell', {
  lifecycle: {
    created: function(){
      var params = xtag.queryChildren(this, 'compose-shell-param')
      var buttons = xtag.queryChildren(this, 'compose-shell-button')
      var oldInputs = this.querySelectorAll('input,select,textarea')

      // Render the initial template
      this.innerHTML = template()

      for (var i in this.attributes) {
        var name = this.attributes[i].nodeName
        if (name)
          this.form.setAttribute(name, this.attributes[i].value)
      }

      [].forEach.call(oldInputs, function(input){
        this.form.appendChild(input)
      }.bind(this))
      
      var paramsEl = this.querySelector('.params')
      for (var i in params) {
        params[i].shell = this
        paramsEl.appendChild(params[i])
      }
      
      var buttonsEl = this.querySelector('.buttons')
      for (var i in buttons) {
        buttons[i].shell = this
        buttonsEl.appendChild(buttons[i])
      }

    }
  },

  events: {
    'submit:delegate(form)': function(event) {
      console.log('form submit')
      event.currentTarget.generateInputs()
    },
    'toggle:delegate(compose-shell-button)': function(event) {
      var toggle = event.target.getAttribute('toggle')

      var shell = event.currentTarget
      var param = shell.params[toggle]
      if (param) {
        param.toggle()
        param.focusInput()
      }
    },
    'show:delegate(compose-shell-param)': function(event){
      var shell = event.currentTarget
      if (this.dependency && !shell.params[this.dependency].visible) {
        xtag.fireEvent(shell, 'notify', {detail: {message: this.name + ' requires ' + this.dependency}})
        shell.params[this.dependency].show()
      }
      if (shell.buttons && shell.buttons[this.name])
        shell.buttons[this.name].enabled = true
    },
    'hide:delegate(compose-shell-param)': function(event){
      var shell = event.currentTarget
      if (this.requiredBy && !this.visible && shell.params[this.requiredBy].visible) {
        shell.params[this.requiredBy].hide()
      }
      if (shell.buttons && shell.buttons[this.name])
        shell.buttons[this.name].enabled = false
    },
    'keypress:keypass(13):delegate(compose-shell-param)': function(event){
      event.preventDefault()
      var submitEvent = new Event('submit', {bubbles: true, cancelable: true})
      var form = event.currentTarget.form
      form.dispatchEvent(submitEvent)
      setTimeout(function(){
        if (!submitEvent.defaultPrevented) {
          form.submit()
        }
      }, 50)
    },
    notify: function(event){
      if (this.onNotify)
        this.onNotify(event.detail.message)
    }
  },

  accessors: {
    form: { get: function(){ return this.querySelector('form') } },
    onNotify: {
      get: function(){
        var notify = this.getAttribute('on-notify')
        return notify && eval(notify) || false
      }
    }
  },

  methods: {
    registerParam: function(param){
      this.params = this.params || {}
      this.params[param.name] = param
      if (param.dependency && this.params[param.dependency])
        this.params[param.dependency].requiredBy = param.name
    },
    registerButton: function(button){
      this.buttons = this.buttons || {}
      this.buttons[button.toggle] = button
      if (this.params[button.toggle].visible)
        button.enabled = true
    },
    generateInputs: function() {
      for (var name in this.params) {
        if (this.params[name].value) {
          var input = document.createElement('input')
          input.type = 'hidden'
          input.value = this.params[name].value
          input.name = name
          this.form.appendChild(input)
        }
      }
    }
  }
})

},{"./templates/shell.hbs":33}],19:[function(require,module,exports){
require('./vendor/x-tag-core')

var Handlebars = require('hbsfy/runtime')
Handlebars.registerHelper('ifEqual', function(v1, v2, options) {
  if (v1 === v2) {
    return options.fn(this)
  }
  return options.inverse(this)
})

require('./compose-shell')
require('./compose-shell-param')
require('./compose-shell-button')

document.addEventListener('page:load', function(){
  var shells = document.body.querySelectorAll('compose-shell')
  for (var i in shells) {
    var shell = shells[i]
    if (shell.parentNode)
      shell.parentNode.replaceChild(document.importNode(shell, true), shell)
  }
})
},{"./compose-shell":18,"./compose-shell-button":16,"./compose-shell-param":17,"./vendor/x-tag-core":34,"hbsfy/runtime":30}],20:[function(require,module,exports){
module.exports = getAnimationEventTypes()

function camelCaseEventTypes(prefix) {
  prefix = prefix || '';

  return {
    start: prefix + 'AnimationStart',
    end: prefix + 'AnimationEnd',
    iteration: prefix + 'AnimationIteration'
  };
}

function lowerCaseEventTypes(prefix) {
  prefix = prefix || '';

  return {
    start: prefix + 'animationstart',
    end: prefix + 'animationend',
    iteration: prefix + 'animationiteration'
  };
}

function getAnimationEventTypes() {
  var prefixes = ['webkit', 'Moz', 'O', ''];
  var style = document.documentElement.style;

  // browser compliant
  if (undefined !== style.animationName) {
    return lowerCaseEventTypes();
  }

  for (var i = 0, len = prefixes.length, prefix; i < len; i++) {
    prefix = prefixes[i];

    if (undefined !== style[prefix + 'AnimationName']) {
      // Webkit
      if (0 === i) {
        return camelCaseEventTypes(prefix.toLowerCase());
      }
      // Mozilla
      else if (1 === i) {
        return lowerCaseEventTypes();
      }
      // Opera
      else if (2 === i) {
        return lowerCaseEventTypes(prefix.toLowerCase());
      }
    }
  }

  return {};
}
},{}],21:[function(require,module,exports){
var dateFormat = require("./date.format");

module.exports = {
  getIndentation: function(level, indentation) {
    var pad;
    if (indentation) {
      pad = "\n";
      var times = level * indentation
      for (var i = times; i == 0; i--) {
        pad += " "
      }
      // _.times(level * indentation, (function(_this) {
      //   return function() {
      //     return pad += " ";
      //   };
      // })(this));
      return pad;
    } else {
      return "";
    }
  },
  toBsonString: function(json, options) {
    var emptyObject, indentation, level, p, result, v;
    if (options == null) {
      options = {};
    }
    level = options.level || 0;
    if (options.indentation != null) {
      indentation = options.indentation;
    } else {
      indentation = 2;
    }
    result = "";
    emptyObject = true;
    if (result !== "") {
      result += "" + (this.getIndentation(level, indentation));
    }
    if (options.valueOnly) {
      return this.parseValue(json, result, level, indentation, options);
    } else if (json instanceof Array) {
      result += "[";
    } else if (json instanceof Object) {
      result += "{";
    }
    for (p in json) {
      v = json[p];
      emptyObject = false;
      result += this.getIndentation(level + 1, indentation);
      if (!(json instanceof Array)) {
        if (options.html) {
          if (p.match(/[^A-z0-9_]/)) {
            result += "<span class='key'>\"" + ($("<div>").text(p).html()) + "\"</span>: ";
          } else {
            result += "<span class='key'>" + p + "</span>: ";
          }
        } else {
          if (p.match(/^\d|[^A-z0-9_]/)) {
            result += "\"" + (p.replace(/"/g, '\\"')) + "\": ";
          } else {
            result += "" + p + ": ";
          }
        }
      }
      result = this.parseValue(v, result, level, indentation, options);
    }
    if (result.slice(-1) === ",") {
      result = result.slice(0, -1);
    }
    if (!emptyObject) {
      result += this.getIndentation(level, indentation);
    }
    if (json instanceof Array) {
      return result += "]";
    } else if (json instanceof Object) {
      return result += "}";
    }
  },
  parseValue: function(v, result, level, indentation, options) {
    var className, dt, dtf, val;
    if (v === null) {
      if (options.html) {
        result += "<span class='value'>null</span>,";
      } else {
        result += "null,";
      }
    } else if (typeof v === "object") {
      switch (v.constructor.name) {
        case "ObjectID":
          if (options.html) {
            result += "<span class='function'>ObjectId</span>(<span class='string'>\"<span class='_id'>" + (v.toString()) + "</span>\"</span>),";
          } else {
            result += "ObjectId(\"" + (v.toString()) + "\"),";
          }
          break;
        case "Date":
          dt = new Date(v.toString());
          dtf = dateFormat(dt, 'isoUtcDateTime');
          if (dt.getMilliseconds() > 0) {
            dtf = dtf.replace(/Z$/, "." + (dateFormat(dt, 'l')) + "Z");
          }
          if (options.html) {
            result += "<span class='function'>ISODate</span>(<span class='string'>\"" + dtf + "\"</span>),";
          } else {
            result += "ISODate(\"" + dtf + "\"),";
          }
          break;
        case "RegExp":
          if (options.html) {
            result += "<span class='regex'>/" + (v.toString()) + "</span>,";
          } else {
            result += "/" + (v.toString()) + ",";
          }
          break;
        default:
          if (v["$oid"]) {
            if (options.html) {
              result += "<span class='function'>ObjectId</span>(<span class='string'>\"<span class='_id'>" + v["$oid"] + "</span>\"</span>),";
            } else {
              result += "ObjectId(\"" + v["$oid"] + "\"),";
            }
          } else if (v["$date"] != null) {
            dt = new Date(v['$date']);
            dtf = dateFormat(dt, 'isoUtcDateTime');
            if (dt.getMilliseconds() > 0) {
              dtf = dtf.replace(/Z$/, "." + (dateFormat(dt, 'l')) + "Z");
            }
            if (options.html) {
              result += "<span class='function'>ISODate</span>(<span class='string'>\"" + dtf + "\"</span>),";
            } else {
              result += "ISODate(\"" + dtf + "\"),";
            }
          } else if (v["$regex"]) {
            if (options.html) {
              result += "<span class='regex'>/" + v["$regex"] + "/" + (v["$options"] || "") + "</span>,";
            } else {
              result += "/" + v["$regex"] + "/" + (v["$options"] || "") + ",";
            }
          } else if (v["$timestamp"]) {
            if (options.html) {
              result += "<span class='function'>Timestamp</span>(" + v["$timestamp"]["t"] + ", " + v["$timestamp"]["i"] + "),";
            } else {
              result += "Timestamp(" + v["$timestamp"]["t"] + ", " + v["$timestamp"]["i"] + "),";
            }
          } else if (v["$ref"]) {
            if (options.html) {
              result += "<span class='function'>Dbref</span>(\"<span class='string'>" + v["namespace"] + "</span>\", " + (this.toBsonString(v["oid"], {
                level: level + 1,
                valueOnly: true,
                html: true
              }));
              if (v["db"]) {
                result += ", \"<span class='string'>" + v["db"] + "</span>\"";
              }
              result += "),";
            } else {
              result += "Dbref(\"" + v["$ref"] + "\", " + (this.toBsonString(v["$id"], {
                level: level + 1,
                valueOnly: true,
                html: false
              })) + "),";
            }
          } else {
            result += "" + (this.toBsonString(v, {
              level: level + 1,
              indentation: indentation,
              html: options.html
            })) + ",";
          }
      }
    } else if (v === "<BSON::Binary>") {
      if (options.html) {
        result += "<span class='function'>Binary</span>(<span class='string'>\"[BSON::Binary]\"</span>),";
      } else {
        result += "Binary(\"[BSON::Binary]\"),";
      }
    } else {
      val = JSON.stringify(v);
      if (options.html) {
        val = val.replace(/</g, '&lt;');
        className = 'string';
        if (val === 'false' || val === 'true') {
          className = 'value';
        }
        if (typeof v === 'number') {
          className = 'number';
        }
        result += "<span class='" + className + "'>" + val + "</span>,";
      } else {
        result += "" + val + ",";
      }
    }
    if (options.valueOnly) {
      if (result.slice(-1) === ",") {
        result = result.slice(0, -1);
      }
    }
    return result;
  },
  sanitizeRegex: function(json) {
    var p, regexp_parts, v;
    for (p in json) {
      v = json[p];
      if (v instanceof RegExp) {
        regexp_parts = v.toString().match(/^\/(.*)\/([gim]*)$/);
        json[p] = {
          $regex: regexp_parts[1],
          $options: regexp_parts[2]
        };
      } else if (p === "$oid" && typeof v === "undefined") {
        alert("json[p] = window.dblayer.page_data.document_oids.shift()");
      } else if (p === "$date" && typeof v === "undefined") {
        json[p] = (new Date()).getTime();
      } else if (typeof v === "object") {
        json[p] = this.sanitizeRegex(v);
      }
    }
    return json;
  },
  bsonEval: function(src) {
    var error, json, mask, p, v;
    try {
      mask = {};
      for (p in this) {
        v = this[p];
        mask[v] = void 0;
      }
      mask.ObjectId = function(id) {
        return {
          $oid: id
        };
      };
      mask.Date = function(date) {
        return {
          $date: date
        };
      };
      mask.ISODate = function(date) {
        return {
          $date: (new Date(date)).getTime()
        };
      };
      mask.Timestamp = function(t, i) {
        return {
          $timestamp: {
            "t": t,
            "i": i
          }
        };
      };
      mask.Dbref = function(name, id, db) {
        return {
          namespace: name,
          oid: id,
          db: db
        };
      };
      mask.Binary = function(v) {
        throw "Cannot save documents with Binary values";
      };
      json = (new Function("with(this){ return " + src + " }")).call(mask);
      return this.sanitizeRegex(json);
    } catch (_error) {
      error = _error;
      throw error;
    }
  }
};

},{"./date.format":22}],22:[function(require,module,exports){
module.exports=require(3)
},{"/app/app/assets/javascripts/lib/date.format.js":3}],23:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

Handlebars['default'] = Handlebars;

exports["default"] = Handlebars;
},{"./handlebars/base":24,"./handlebars/exception":25,"./handlebars/runtime":26,"./handlebars/safe-string":27,"./handlebars/utils":28}],24:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "2.0.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 6;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn) {
    if (toString.call(name) === objectType) {
      if (fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function(name) {
    delete this.helpers[name];
  },

  registerPartial: function(name, partial) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function(name) {
    delete this.partials[name];
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(/* [args, ]options */) {
    if(arguments.length === 1) {
      // A missing field in a {{foo}} constuct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new Exception("Missing helper: '" + arguments[arguments.length-1].name + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = createFrame(options.data);
        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
        options = {data: data};
      }

      return fn(context, options);
    }
  });

  instance.registerHelper('each', function(context, options) {
    if (!options) {
      throw new Exception('Must pass iterator to #each');
    }

    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    var contextPath;
    if (options.data && options.ids) {
      contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));

            if (contextPath) {
              data.contextPath = contextPath + i;
            }
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) {
              data.key = key;
              data.index = i;
              data.first = (i === 0);

              if (contextPath) {
                data.contextPath = contextPath + key;
              }
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    var fn = options.fn;

    if (!Utils.isEmpty(context)) {
      if (options.data && options.ids) {
        var data = createFrame(options.data);
        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
        options = {data:data};
      }

      return fn(context, options);
    } else {
      return options.inverse(this);
    }
  });

  instance.registerHelper('log', function(message, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, message);
  });

  instance.registerHelper('lookup', function(obj, field) {
    return obj && obj[field];
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, message) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, message);
      }
    }
  }
};
exports.logger = logger;
var log = logger.log;
exports.log = log;
var createFrame = function(object) {
  var frame = Utils.extend({}, object);
  frame._parent = object;
  return frame;
};
exports.createFrame = createFrame;
},{"./exception":25,"./utils":28}],25:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],26:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;
var createFrame = require("./base").createFrame;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new Exception("No environment passed to template");
  }
  if (!templateSpec || !templateSpec.main) {
    throw new Exception('Unknown template object: ' + typeof templateSpec);
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  var invokePartialWrapper = function(partial, indent, name, context, hash, helpers, partials, data, depths) {
    if (hash) {
      context = Utils.extend({}, context, hash);
    }

    var result = env.VM.invokePartial.call(this, partial, name, context, helpers, partials, data, depths);

    if (result == null && env.compile) {
      var options = { helpers: helpers, partials: partials, data: data, depths: depths };
      partials[name] = env.compile(partial, { data: data !== undefined, compat: templateSpec.compat }, env);
      result = partials[name](context, options);
    }
    if (result != null) {
      if (indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    lookup: function(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function(i) {
      return templateSpec[i];
    },

    programs: [],
    program: function(i, data, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths) {
        programWrapper = program(this, i, fn, data, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(this, i, fn);
      }
      return programWrapper;
    },

    data: function(data, depth) {
      while (data && depth--) {
        data = data._parent;
      }
      return data;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = Utils.extend({}, common, param);
      }

      return ret;
    },

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  var ret = function(context, options) {
    options = options || {};
    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths;
    if (templateSpec.useDepths) {
      depths = options.depths ? [context].concat(options.depths) : [context];
    }

    return templateSpec.main.call(container, context, container.helpers, container.partials, data, depths);
  };
  ret.isTop = true;

  ret._setup = function(options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
    }
  };

  ret._child = function(i, data, depths) {
    if (templateSpec.useDepths && !depths) {
      throw new Exception('must pass parent depths');
    }

    return program(container, i, templateSpec[i], data, depths);
  };
  return ret;
}

exports.template = template;function program(container, i, fn, data, depths) {
  var prog = function(context, options) {
    options = options || {};

    return fn.call(container, context, container.helpers, container.partials, options.data || data, depths && [context].concat(depths));
  };
  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data, depths) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data, depths: depths };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? createFrame(data) : {};
    data.root = context;
  }
  return data;
}
},{"./base":24,"./exception":25,"./utils":28}],27:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],28:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
/* istanbul ignore next */
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (string == null) {
    return "";
  } else if (!string) {
    return string + '';
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}

exports.appendContextPath = appendContextPath;
},{"./safe-string":27}],29:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":23}],30:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":29}],31:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(depth0,helpers,partials,data) {
  return "enabled";
  },"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<button\n  class=\"";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.enabled : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "\"\n  type=\""
    + escapeExpression(((helper = (helper = helpers.type || (depth0 != null ? depth0.type : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"type","hash":{},"data":data}) : helper)))
    + "\">"
    + escapeExpression(((helper = (helper = helpers.content || (depth0 != null ? depth0.content : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"content","hash":{},"data":data}) : helper)))
    + "</button>";
},"useData":true});

},{"hbsfy/runtime":30}],32:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(depth0,helpers,partials,data) {
  return "<span class=\"params-group\"></span>";
  },"3":function(depth0,helpers,partials,data) {
  var stack1, helperMissing=helpers.helperMissing, buffer = "";
  stack1 = ((helpers.ifEqual || (depth0 && depth0.ifEqual) || helperMissing).call(depth0, (depth0 != null ? depth0.type : depth0), "text", {"name":"ifEqual","hash":{},"fn":this.program(4, data),"inverse":this.program(6, data),"data":data}));
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"4":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<span>"
    + escapeExpression(((helper = (helper = helpers.content || (depth0 != null ? depth0.content : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"content","hash":{},"data":data}) : helper)))
    + "</span>";
},"6":function(depth0,helpers,partials,data) {
  var stack1, helperMissing=helpers.helperMissing, buffer = "";
  stack1 = ((helpers.ifEqual || (depth0 && depth0.ifEqual) || helperMissing).call(depth0, (depth0 != null ? depth0.type : depth0), "boolean", {"name":"ifEqual","hash":{},"fn":this.program(7, data),"inverse":this.program(9, data),"data":data}));
  if (stack1 != null) { buffer += stack1; }
  return buffer;
},"7":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return "<span class=\"boolean\">"
    + escapeExpression(((helper = (helper = helpers.content || (depth0 != null ? depth0.content : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"content","hash":{},"data":data}) : helper)))
    + "</span>";
},"9":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<span\n        spellcheck=\"false\"\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.editable : depth0), {"name":"if","hash":{},"fn":this.program(10, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\n        class=\""
    + escapeExpression(((helper = (helper = helpers.type || (depth0 != null ? depth0.type : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"type","hash":{},"data":data}) : helper)));
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.placeholder : depth0), {"name":"if","hash":{},"fn":this.program(12, data),"inverse":this.noop,"data":data});
  if (stack1 != null) { buffer += stack1; }
  buffer += "\">";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.value : depth0), {"name":"if","hash":{},"fn":this.program(14, data),"inverse":this.program(16, data),"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "</span>";
},"10":function(depth0,helpers,partials,data) {
  return "contenteditable=\"true\"";
  },"12":function(depth0,helpers,partials,data) {
  return " placeholder";
  },"14":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return escapeExpression(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"value","hash":{},"data":data}) : helper)));
  },"16":function(depth0,helpers,partials,data) {
  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;
  return escapeExpression(((helper = (helper = helpers.placeholder || (depth0 != null ? depth0.placeholder : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"placeholder","hash":{},"data":data}) : helper)));
  },"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<span class=\"before\">"
    + escapeExpression(((helper = (helper = helpers.before || (depth0 != null ? depth0.before : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"before","hash":{},"data":data}) : helper)))
    + "</span>";
  stack1 = helpers['if'].call(depth0, (depth0 != null ? depth0.group : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.program(3, data),"data":data});
  if (stack1 != null) { buffer += stack1; }
  return buffer + "<span class=\"after\">"
    + escapeExpression(((helper = (helper = helpers.after || (depth0 != null ? depth0.after : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"after","hash":{},"data":data}) : helper)))
    + "</span>";
},"useData":true});

},{"hbsfy/runtime":30}],33:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
  return "<form>\n  <div class=\"editor\">\n    <div class=\"params\">\n    </div>\n    <div class=\"buttons\">\n    </div>\n  </div>\n</form>";
  },"useData":true});

},{"hbsfy/runtime":30}],34:[function(require,module,exports){
// We don't use the platform bootstrapper, so fake this stuff.

window.Platform = {};
var logFlags = {};


// DOMTokenList polyfill for IE9
(function () {

if (typeof window.Element === "undefined" || "classList" in document.documentElement) return;

var prototype = Array.prototype,
    indexOf = prototype.indexOf,
    slice = prototype.slice,
    push = prototype.push,
    splice = prototype.splice,
    join = prototype.join;

function DOMTokenList(el) {
  this._element = el;
  if (el.className != this._classCache) {
    this._classCache = el.className;

    if (!this._classCache) return;

      // The className needs to be trimmed and split on whitespace
      // to retrieve a list of classes.
      var classes = this._classCache.replace(/^\s+|\s+$/g,'').split(/\s+/),
        i;
    for (i = 0; i < classes.length; i++) {
      push.call(this, classes[i]);
    }
  }
};

function setToClassName(el, classes) {
  el.className = classes.join(' ');
}

DOMTokenList.prototype = {
  add: function(token) {
    if(this.contains(token)) return;
    push.call(this, token);
    setToClassName(this._element, slice.call(this, 0));
  },
  contains: function(token) {
    return indexOf.call(this, token) !== -1;
  },
  item: function(index) {
    return this[index] || null;
  },
  remove: function(token) {
    var i = indexOf.call(this, token);
     if (i === -1) {
       return;
     }
    splice.call(this, i, 1);
    setToClassName(this._element, slice.call(this, 0));
  },
  toString: function() {
    return join.call(this, ' ');
  },
  toggle: function(token) {
    if (indexOf.call(this, token) === -1) {
      this.add(token);
    } else {
      this.remove(token);
    }
  }
};

window.DOMTokenList = DOMTokenList;

function defineElementGetter (obj, prop, getter) {
  if (Object.defineProperty) {
    Object.defineProperty(obj, prop,{
      get : getter
    })
  } else {
    obj.__defineGetter__(prop, getter);
  }
}

defineElementGetter(Element.prototype, 'classList', function () {
  return new DOMTokenList(this);
});

})();


/*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

if (typeof WeakMap === 'undefined') {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;

    var WeakMap = function() {
      this.name = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');
    };

    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key)
          entry[1] = value;
        else
          defineProperty(key, this.name, {value: [key, value], writable: true});
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ?
            entry[1] : undefined;
      },
      delete: function(key) {
        this.set(key, undefined);
      }
    };

    window.WeakMap = WeakMap;
  })();
}

/*
 * Copyright 2012 The Polymer Authors. All rights reserved.
 * Use of this source code is goverened by a BSD-style
 * license that can be found in the LICENSE file.
 */

(function(global) {

  var registrationsTable = new WeakMap();

  // We use setImmediate or postMessage for our future callback.
  var setImmediate = window.msSetImmediate;

  // Use post message to emulate setImmediate.
  if (!setImmediate) {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener('message', function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, '*');
    };
  }

  // This is used to ensure that we never schedule 2 callas to setImmediate
  var isScheduled = false;

  // Keep track of observers that needs to be notified next time.
  var scheduledObservers = [];

  /**
   * Schedules |dispatchCallback| to be called in the future.
   * @param {MutationObserver} observer
   */
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }

  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill &&
        window.ShadowDOMPolyfill.wrapIfNeeded(node) ||
        node;
  }

  function dispatchCallbacks() {
    // http://dom.spec.whatwg.org/#mutation-observers

    isScheduled = false; // Used to allow a new setImmediate call above.

    var observers = scheduledObservers;
    scheduledObservers = [];
    // Sort observers based on their creation UID (incremental).
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });

    var anyNonEmpty = false;
    observers.forEach(function(observer) {

      // 2.1, 2.2
      var queue = observer.takeRecords();
      // 2.3. Remove all transient registered observers whose observer is mo.
      removeTransientObserversFor(observer);

      // 2.4
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });

    // 3.
    if (anyNonEmpty)
      dispatchCallbacks();
  }

  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations)
        return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer)
          registration.removeTransientObservers();
      });
    });
  }

  /**
   * This function is used for the "For each registered observer observer (with
   * observer's options as options) in target's list of registered observers,
   * run these substeps:" and the "For each ancestor ancestor of target, and for
   * each registered observer observer (with options options) in ancestor's list
   * of registered observers, run these substeps:" part of the algorithms. The
   * |options.subtree| is checked to ensure that the callback is called
   * correctly.
   *
   * @param {Node} target
   * @param {function(MutationObserverInit):MutationRecord} callback
   */
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);

      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;

          // Only target ignores subtree.
          if (node !== target && !options.subtree)
            continue;

          var record = callback(options);
          if (record)
            registration.enqueue(record);
        }
      }
    }
  }

  var uidCounter = 0;

  /**
   * The class that maps to the DOM MutationObserver interface.
   * @param {Function} callback.
   * @constructor
   */
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }

  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);

      // 1.1
      if (!options.childList && !options.attributes && !options.characterData ||

          // 1.2
          options.attributeOldValue && !options.attributes ||

          // 1.3
          options.attributeFilter && options.attributeFilter.length &&
              !options.attributes ||

          // 1.4
          options.characterDataOldValue && !options.characterData) {

        throw new SyntaxError();
      }

      var registrations = registrationsTable.get(target);
      if (!registrations)
        registrationsTable.set(target, registrations = []);

      // 2
      // If target's list of registered observers already includes a registered
      // observer associated with the context object, replace that registered
      // observer's options with options.
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }

      // 3.
      // Otherwise, add a new registered observer to target's list of registered
      // observers with the context object as the observer and options as the
      // options, and add target to context object's list of nodes on which it
      // is registered.
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }

      registration.addListeners();
    },

    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            // Each node can only have one registered observer associated with
            // this observer.
            break;
          }
        }
      }, this);
      this.records_ = [];
    },

    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };

  /**
   * @param {string} type
   * @param {Node} target
   * @constructor
   */
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }

  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  };

  // We keep track of the two (possibly one) records used in a single mutation.
  var currentRecord, recordWithOldValue;

  /**
   * Creates a record without |oldValue| and caches it as |currentRecord| for
   * later use.
   * @param {string} oldValue
   * @return {MutationRecord}
   */
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }

  /**
   * Gets or creates a record with |oldValue| based in the |currentRecord|
   * @param {string} oldValue
   * @return {MutationRecord}
   */
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue)
      return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }

  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }

  /**
   * @param {MutationRecord} record
   * @return {boolean} Whether the record represents a record from the current
   * mutation event.
   */
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }

  /**
   * Selects which record, if any, to replace the last record in the queue.
   * This returns |null| if no record should be replaced.
   *
   * @param {MutationRecord} lastRecord
   * @param {MutationRecord} newRecord
   * @param {MutationRecord}
   */
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord)
      return lastRecord;

    // Check if the the record we are adding represents the same record. If
    // so, we keep the one with the oldValue in it.
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
      return recordWithOldValue;

    return null;
  }

  /**
   * Class used to represent a registered observer.
   * @param {MutationObserver} observer
   * @param {Node} target
   * @param {MutationObserverInit} options
   * @constructor
   */
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }

  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;

      // There are cases where we replace the last record with the new record.
      // For example if the record represents the same mutation we need to use
      // the one with the oldValue. If we get same record (this can happen as we
      // walk up the tree) we ignore the new record.
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }

      records[length] = record;
    },

    addListeners: function() {
      this.addListeners_(this.target);
    },

    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.addEventListener('DOMAttrModified', this, true);

      if (options.characterData)
        node.addEventListener('DOMCharacterDataModified', this, true);

      if (options.childList)
        node.addEventListener('DOMNodeInserted', this, true);

      if (options.childList || options.subtree)
        node.addEventListener('DOMNodeRemoved', this, true);
    },

    removeListeners: function() {
      this.removeListeners_(this.target);
    },

    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes)
        node.removeEventListener('DOMAttrModified', this, true);

      if (options.characterData)
        node.removeEventListener('DOMCharacterDataModified', this, true);

      if (options.childList)
        node.removeEventListener('DOMNodeInserted', this, true);

      if (options.childList || options.subtree)
        node.removeEventListener('DOMNodeRemoved', this, true);
    },

    /**
     * Adds a transient observer on node. The transient observer gets removed
     * next time we deliver the change records.
     * @param {Node} node
     */
    addTransientObserver: function(node) {
      // Don't add transient observers on the target itself. We already have all
      // the required listeners set up on the target.
      if (node === this.target)
        return;

      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations)
        registrationsTable.set(node, registrations = []);

      // We know that registrations does not contain this because we already
      // checked if node === this.target.
      registrations.push(this);
    },

    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];

      transientObservedNodes.forEach(function(node) {
        // Transient observers are never added to the target.
        this.removeListeners_(node);

        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            // Each node can only have one registered observer associated with
            // this observer.
            break;
          }
        }
      }, this);
    },

    handleEvent: function(e) {
      // Stop propagation since we are managing the propagation manually.
      // This means that other mutation events on the page will not work
      // correctly but that is by design.
      e.stopImmediatePropagation();

      switch (e.type) {
        case 'DOMAttrModified':
          // http://dom.spec.whatwg.org/#concept-mo-queue-attributes

          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          var target = e.target;

          // 1.
          var record = new getRecord('attributes', target);
          record.attributeName = name;
          record.attributeNamespace = namespace;

          // 2.
          var oldValue =
              e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;

          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 3.1, 4.2
            if (!options.attributes)
              return;

            // 3.2, 4.3
            if (options.attributeFilter && options.attributeFilter.length &&
                options.attributeFilter.indexOf(name) === -1 &&
                options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            // 3.3, 4.4
            if (options.attributeOldValue)
              return getRecordWithOldValue(oldValue);

            // 3.4, 4.5
            return record;
          });

          break;

        case 'DOMCharacterDataModified':
          // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata
          var target = e.target;

          // 1.
          var record = getRecord('characterData', target);

          // 2.
          var oldValue = e.prevValue;


          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 3.1, 4.2
            if (!options.characterData)
              return;

            // 3.2, 4.3
            if (options.characterDataOldValue)
              return getRecordWithOldValue(oldValue);

            // 3.3, 4.4
            return record;
          });

          break;

        case 'DOMNodeRemoved':
          this.addTransientObserver(e.target);
          // Fall through.
        case 'DOMNodeInserted':
          // http://dom.spec.whatwg.org/#concept-mo-queue-childlist
          var target = e.relatedNode;
          var changedNode = e.target;
          var addedNodes, removedNodes;
          if (e.type === 'DOMNodeInserted') {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {

            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;

          // 1.
          var record = getRecord('childList', target);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;

          forEachAncestorAndObserverEnqueueRecord(target, function(options) {
            // 2.1, 3.2
            if (!options.childList)
              return;

            // 2.2, 3.3
            return record;
          });

      }

      clearRecords();
    }
  };

  global.JsMutationObserver = JsMutationObserver;

  if (!global.MutationObserver)
    global.MutationObserver = JsMutationObserver;


})(this);

/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * Implements `document.registerElement`
 * @module CustomElements
*/

/**
 * Polyfilled extensions to the `document` object.
 * @class Document
*/

(function(scope) {

// imports

if (!scope) {
  scope = window.CustomElements = {flags:{}};
}
var flags = scope.flags;

// native document.registerElement?

var hasNative = Boolean(document.registerElement);
// For consistent timing, use native custom elements only when not polyfilling
// other key related web components features.
var useNative = !flags.register && hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || HTMLImports.useNative);

if (useNative) {

  // stub
  var nop = function() {};

  // exports
  scope.registry = {};
  scope.upgradeElement = nop;

  scope.watchShadow = nop;
  scope.upgrade = nop;
  scope.upgradeAll = nop;
  scope.upgradeSubtree = nop;
  scope.observeDocument = nop;
  scope.upgradeDocument = nop;
  scope.upgradeDocumentTree = nop;
  scope.takeRecords = nop;
  scope.reservedTagList = [];

} else {

  /**
   * Registers a custom tag name with the document.
   *
   * When a registered element is created, a `readyCallback` method is called
   * in the scope of the element. The `readyCallback` method can be specified on
   * either `options.prototype` or `options.lifecycle` with the latter taking
   * precedence.
   *
   * @method register
   * @param {String} name The tag name to register. Must include a dash ('-'),
   *    for example 'x-component'.
   * @param {Object} options
   *    @param {String} [options.extends]
   *      (_off spec_) Tag name of an element to extend (or blank for a new
   *      element). This parameter is not part of the specification, but instead
   *      is a hint for the polyfill because the extendee is difficult to infer.
   *      Remember that the input prototype must chain to the extended element's
   *      prototype (or HTMLElement.prototype) regardless of the value of
   *      `extends`.
   *    @param {Object} options.prototype The prototype to use for the new
   *      element. The prototype must inherit from HTMLElement.
   *    @param {Object} [options.lifecycle]
   *      Callbacks that fire at important phases in the life of the custom
   *      element.
   *
   * @example
   *      FancyButton = document.registerElement("fancy-button", {
   *        extends: 'button',
   *        prototype: Object.create(HTMLButtonElement.prototype, {
   *          readyCallback: {
   *            value: function() {
   *              console.log("a fancy-button was created",
   *            }
   *          }
   *        })
   *      });
   * @return {Function} Constructor for the newly registered type.
   */
  function register(name, options) {
    //console.warn('document.registerElement("' + name + '", ', options, ')');
    // construct a defintion out of options
    // TODO(sjmiles): probably should clone options instead of mutating it
    var definition = options || {};
    if (!name) {
      // TODO(sjmiles): replace with more appropriate error (EricB can probably
      // offer guidance)
      throw new Error('document.registerElement: first argument `name` must not be empty');
    }
    if (name.indexOf('-') < 0) {
      // TODO(sjmiles): replace with more appropriate error (EricB can probably
      // offer guidance)
      throw new Error('document.registerElement: first argument (\'name\') must contain a dash (\'-\'). Argument provided was \'' + String(name) + '\'.');
    }
    // prevent registering reserved names
    if (isReservedTag(name)) {
      throw new Error('Failed to execute \'registerElement\' on \'Document\': Registration failed for type \'' + String(name) + '\'. The type name is invalid.');
    }
    // elements may only be registered once
    if (getRegisteredDefinition(name)) {
      throw new Error('DuplicateDefinitionError: a type with name \'' + String(name) + '\' is already registered');
    }
    // must have a prototype, default to an extension of HTMLElement
    // TODO(sjmiles): probably should throw if no prototype, check spec
    if (!definition.prototype) {
      // TODO(sjmiles): replace with more appropriate error (EricB can probably
      // offer guidance)
      throw new Error('Options missing required prototype property');
    }
    // record name
    definition.__name = name.toLowerCase();
    // ensure a lifecycle object so we don't have to null test it
    definition.lifecycle = definition.lifecycle || {};
    // build a list of ancestral custom elements (for native base detection)
    // TODO(sjmiles): we used to need to store this, but current code only
    // uses it in 'resolveTagName': it should probably be inlined
    definition.ancestry = ancestry(definition.extends);
    // extensions of native specializations of HTMLElement require localName
    // to remain native, and use secondary 'is' specifier for extension type
    resolveTagName(definition);
    // some platforms require modifications to the user-supplied prototype
    // chain
    resolvePrototypeChain(definition);
    // overrides to implement attributeChanged callback
    overrideAttributeApi(definition.prototype);
    // 7.1.5: Register the DEFINITION with DOCUMENT
    registerDefinition(definition.__name, definition);
    // 7.1.7. Run custom element constructor generation algorithm with PROTOTYPE
    // 7.1.8. Return the output of the previous step.
    definition.ctor = generateConstructor(definition);
    definition.ctor.prototype = definition.prototype;
    // force our .constructor to be our actual constructor
    definition.prototype.constructor = definition.ctor;
    // if initial parsing is complete
    if (scope.ready) {
      // upgrade any pre-existing nodes of this type
      scope.upgradeDocumentTree(document);
    }
    return definition.ctor;
  }

  function isReservedTag(name) {
    for (var i = 0; i < reservedTagList.length; i++) {
      if (name === reservedTagList[i]) {
        return true;
      }
    }
  }

  var reservedTagList = [
    'annotation-xml', 'color-profile', 'font-face', 'font-face-src',
    'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph'
  ];

  function ancestry(extnds) {
    var extendee = getRegisteredDefinition(extnds);
    if (extendee) {
      return ancestry(extendee.extends).concat([extendee]);
    }
    return [];
  }

  function resolveTagName(definition) {
    // if we are explicitly extending something, that thing is our
    // baseTag, unless it represents a custom component
    var baseTag = definition.extends;
    // if our ancestry includes custom components, we only have a
    // baseTag if one of them does
    for (var i=0, a; (a=definition.ancestry[i]); i++) {
      baseTag = a.is && a.tag;
    }
    // our tag is our baseTag, if it exists, and otherwise just our name
    definition.tag = baseTag || definition.__name;
    if (baseTag) {
      // if there is a base tag, use secondary 'is' specifier
      definition.is = definition.__name;
    }
  }

  function resolvePrototypeChain(definition) {
    // if we don't support __proto__ we need to locate the native level
    // prototype for precise mixing in
    if (!Object.__proto__) {
      // default prototype
      var nativePrototype = HTMLElement.prototype;
      // work out prototype when using type-extension
      if (definition.is) {
        var inst = document.createElement(definition.tag);
        var expectedPrototype = Object.getPrototypeOf(inst);
        // only set nativePrototype if it will actually appear in the definition's chain
        if (expectedPrototype === definition.prototype) {
          nativePrototype = expectedPrototype;
        }
      }
      // ensure __proto__ reference is installed at each point on the prototype
      // chain.
      // NOTE: On platforms without __proto__, a mixin strategy is used instead
      // of prototype swizzling. In this case, this generated __proto__ provides
      // limited support for prototype traversal.
      var proto = definition.prototype, ancestor;
      while (proto && (proto !== nativePrototype)) {
        ancestor = Object.getPrototypeOf(proto);
        proto.__proto__ = ancestor;
        proto = ancestor;
      }
      // cache this in case of mixin
      definition.native = nativePrototype;
    }
  }

  // SECTION 4

  function instantiate(definition) {
    // 4.a.1. Create a new object that implements PROTOTYPE
    // 4.a.2. Let ELEMENT by this new object
    //
    // the custom element instantiation algorithm must also ensure that the
    // output is a valid DOM element with the proper wrapper in place.
    //
    return upgrade(domCreateElement(definition.tag), definition);
  }

  function upgrade(element, definition) {
    // some definitions specify an 'is' attribute
    if (definition.is) {
      element.setAttribute('is', definition.is);
    }
    // make 'element' implement definition.prototype
    implement(element, definition);
    // flag as upgraded
    element.__upgraded__ = true;
    // lifecycle management
    created(element);
    // attachedCallback fires in tree order, call before recursing
    scope.insertedNode(element);
    // there should never be a shadow root on element at this point
    scope.upgradeSubtree(element);
    // OUTPUT
    return element;
  }

  function implement(element, definition) {
    // prototype swizzling is best
    if (Object.__proto__) {
      element.__proto__ = definition.prototype;
    } else {
      // where above we can re-acquire inPrototype via
      // getPrototypeOf(Element), we cannot do so when
      // we use mixin, so we install a magic reference
      customMixin(element, definition.prototype, definition.native);
      element.__proto__ = definition.prototype;
    }
  }

  function customMixin(inTarget, inSrc, inNative) {
    // TODO(sjmiles): 'used' allows us to only copy the 'youngest' version of
    // any property. This set should be precalculated. We also need to
    // consider this for supporting 'super'.
    var used = {};
    // start with inSrc
    var p = inSrc;
    // The default is HTMLElement.prototype, so we add a test to avoid mixing in
    // native prototypes
    while (p !== inNative && p !== HTMLElement.prototype) {
      var keys = Object.getOwnPropertyNames(p);
      for (var i=0, k; k=keys[i]; i++) {
        if (!used[k]) {
          Object.defineProperty(inTarget, k,
              Object.getOwnPropertyDescriptor(p, k));
          used[k] = 1;
        }
      }
      p = Object.getPrototypeOf(p);
    }
  }

  function created(element) {
    // invoke createdCallback
    if (element.createdCallback) {
      element.createdCallback();
    }
  }

  // attribute watching

  function overrideAttributeApi(prototype) {
    // overrides to implement callbacks
    // TODO(sjmiles): should support access via .attributes NamedNodeMap
    // TODO(sjmiles): preserves user defined overrides, if any
    if (prototype.setAttribute._polyfilled) {
      return;
    }
    var setAttribute = prototype.setAttribute;
    prototype.setAttribute = function(name, value) {
      changeAttribute.call(this, name, value, setAttribute);
    }
    var removeAttribute = prototype.removeAttribute;
    prototype.removeAttribute = function(name) {
      changeAttribute.call(this, name, null, removeAttribute);
    }
    prototype.setAttribute._polyfilled = true;
  }

  // https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/custom/
  // index.html#dfn-attribute-changed-callback
  function changeAttribute(name, value, operation) {
    name = name.toLowerCase();
    var oldValue = this.getAttribute(name);
    operation.apply(this, arguments);
    var newValue = this.getAttribute(name);
    if (this.attributeChangedCallback
        && (newValue !== oldValue)) {
      this.attributeChangedCallback(name, oldValue, newValue);
    }
  }

  // element registry (maps tag names to definitions)

  var registry = {};

  function getRegisteredDefinition(name) {
    if (name) {
      return registry[name.toLowerCase()];
    }
  }

  function registerDefinition(name, definition) {
    registry[name] = definition;
  }

  function generateConstructor(definition) {
    return function() {
      return instantiate(definition);
    };
  }

  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  function createElementNS(namespace, tag, typeExtension) {
    // NOTE: we do not support non-HTML elements,
    // just call createElementNS for non HTML Elements
    if (namespace === HTML_NAMESPACE) {
      return createElement(tag, typeExtension);
    } else {
      return domCreateElementNS(namespace, tag);
    }
  }

  function createElement(tag, typeExtension) {
    // TODO(sjmiles): ignore 'tag' when using 'typeExtension', we could
    // error check it, or perhaps there should only ever be one argument
    var definition = getRegisteredDefinition(typeExtension || tag);
    if (definition) {
      if (tag == definition.tag && typeExtension == definition.is) {
        return new definition.ctor();
      }
      // Handle empty string for type extension.
      if (!typeExtension && !definition.is) {
        return new definition.ctor();
      }
    }

    if (typeExtension) {
      var element = createElement(tag);
      element.setAttribute('is', typeExtension);
      return element;
    }
    var element = domCreateElement(tag);
    // Custom tags should be HTMLElements even if not upgraded.
    if (tag.indexOf('-') >= 0) {
      implement(element, HTMLElement);
    }
    return element;
  }

  function upgradeElement(element) {
    if (!element.__upgraded__ && (element.nodeType === Node.ELEMENT_NODE)) {
      var is = element.getAttribute('is');
      var definition = getRegisteredDefinition(is || element.localName);
      if (definition) {
        if (is && definition.tag == element.localName) {
          return upgrade(element, definition);
        } else if (!is && !definition.extends) {
          return upgrade(element, definition);
        }
      }
    }
  }

  function cloneNode(deep) {
    // call original clone
    var n = domCloneNode.call(this, deep);
    // upgrade the element and subtree
    scope.upgradeAll(n);
    // return the clone
    return n;
  }
  // capture native createElement before we override it

  var domCreateElement = document.createElement.bind(document);
  var domCreateElementNS = document.createElementNS.bind(document);

  // capture native cloneNode before we override it

  var domCloneNode = Node.prototype.cloneNode;

  // exports

  document.registerElement = register;
  document.createElement = createElement; // override
  document.createElementNS = createElementNS; // override
  Node.prototype.cloneNode = cloneNode; // override

  scope.registry = registry;

  /**
   * Upgrade an element to a custom element. Upgrading an element
   * causes the custom prototype to be applied, an `is` attribute
   * to be attached (as needed), and invocation of the `readyCallback`.
   * `upgrade` does nothing if the element is already upgraded, or
   * if it matches no registered custom tag name.
   *
   * @method ugprade
   * @param {Element} element The element to upgrade.
   * @return {Element} The upgraded element.
   */
  scope.upgrade = upgradeElement;
}

// Create a custom 'instanceof'. This is necessary when CustomElements
// are implemented via a mixin strategy, as for example on IE10.
var isInstance;
if (!Object.__proto__ && !useNative) {
  isInstance = function(obj, ctor) {
    var p = obj;
    while (p) {
      // NOTE: this is not technically correct since we're not checking if
      // an object is an instance of a constructor; however, this should
      // be good enough for the mixin strategy.
      if (p === ctor.prototype) {
        return true;
      }
      p = p.__proto__;
    }
    return false;
  }
} else {
  isInstance = function(obj, base) {
    return obj instanceof base;
  }
}

// exports
scope.instanceof = isInstance;
scope.reservedTagList = reservedTagList;

// bc
document.register = document.registerElement;

scope.hasNative = hasNative;
scope.useNative = useNative;

})(window.CustomElements);

/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(scope){

var logFlags = window.logFlags || {};
var IMPORT_LINK_TYPE = window.HTMLImports ? HTMLImports.IMPORT_LINK_TYPE : 'none';

// walk the subtree rooted at node, applying 'find(element, data)' function
// to each element
// if 'find' returns true for 'element', do not search element's subtree
function findAll(node, find, data) {
  var e = node.firstElementChild;
  if (!e) {
    e = node.firstChild;
    while (e && e.nodeType !== Node.ELEMENT_NODE) {
      e = e.nextSibling;
    }
  }
  while (e) {
    if (find(e, data) !== true) {
      findAll(e, find, data);
    }
    e = e.nextElementSibling;
  }
  return null;
}

// walk all shadowRoots on a given node.
function forRoots(node, cb) {
  var root = node.shadowRoot;
  while(root) {
    forSubtree(root, cb);
    root = root.olderShadowRoot;
  }
}

// walk the subtree rooted at node, including descent into shadow-roots,
// applying 'cb' to each element
function forSubtree(node, cb) {
  //logFlags.dom && node.childNodes && node.childNodes.length && console.group('subTree: ', node);
  findAll(node, function(e) {
    if (cb(e)) {
      return true;
    }
    forRoots(e, cb);
  });
  forRoots(node, cb);
  //logFlags.dom && node.childNodes && node.childNodes.length && console.groupEnd();
}

// manage lifecycle on added node
function added(node) {
  if (upgrade(node)) {
    insertedNode(node);
    return true;
  }
  inserted(node);
}

// manage lifecycle on added node's subtree only
function addedSubtree(node) {
  forSubtree(node, function(e) {
    if (added(e)) {
      return true;
    }
  });
}

// manage lifecycle on added node and it's subtree
function addedNode(node) {
  return added(node) || addedSubtree(node);
}

// upgrade custom elements at node, if applicable
function upgrade(node) {
  if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {
    var type = node.getAttribute('is') || node.localName;
    var definition = scope.registry[type];
    if (definition) {
      logFlags.dom && console.group('upgrade:', node.localName);
      scope.upgrade(node);
      logFlags.dom && console.groupEnd();
      return true;
    }
  }
}

function insertedNode(node) {
  inserted(node);
  if (inDocument(node)) {
    forSubtree(node, function(e) {
      inserted(e);
    });
  }
}

// TODO(sorvell): on platforms without MutationObserver, mutations may not be
// reliable and therefore attached/detached are not reliable.
// To make these callbacks less likely to fail, we defer all inserts and removes
// to give a chance for elements to be inserted into dom.
// This ensures attachedCallback fires for elements that are created and
// immediately added to dom.
var hasPolyfillMutations = (!window.MutationObserver ||
    (window.MutationObserver === window.JsMutationObserver));
scope.hasPolyfillMutations = hasPolyfillMutations;

var isPendingMutations = false;
var pendingMutations = [];
function deferMutation(fn) {
  pendingMutations.push(fn);
  if (!isPendingMutations) {
    isPendingMutations = true;
    var async = (window.Platform && window.Platform.endOfMicrotask) ||
        setTimeout;
    async(takeMutations);
  }
}

function takeMutations() {
  isPendingMutations = false;
  var $p = pendingMutations;
  for (var i=0, l=$p.length, p; (i<l) && (p=$p[i]); i++) {
    p();
  }
  pendingMutations = [];
}

function inserted(element) {
  if (hasPolyfillMutations) {
    deferMutation(function() {
      _inserted(element);
    });
  } else {
    _inserted(element);
  }
}

// TODO(sjmiles): if there are descents into trees that can never have inDocument(*) true, fix this
function _inserted(element) {
  // TODO(sjmiles): it's possible we were inserted and removed in the space
  // of one microtask, in which case we won't be 'inDocument' here
  // But there are other cases where we are testing for inserted without
  // specific knowledge of mutations, and must test 'inDocument' to determine
  // whether to call inserted
  // If we can factor these cases into separate code paths we can have
  // better diagnostics.
  // TODO(sjmiles): when logging, do work on all custom elements so we can
  // track behavior even when callbacks not defined
  //console.log('inserted: ', element.localName);
  if (element.attachedCallback || element.detachedCallback || (element.__upgraded__ && logFlags.dom)) {
    logFlags.dom && console.group('inserted:', element.localName);
    if (inDocument(element)) {
      element.__inserted = (element.__inserted || 0) + 1;
      // if we are in a 'removed' state, bluntly adjust to an 'inserted' state
      if (element.__inserted < 1) {
        element.__inserted = 1;
      }
      // if we are 'over inserted', squelch the callback
      if (element.__inserted > 1) {
        logFlags.dom && console.warn('inserted:', element.localName,
          'insert/remove count:', element.__inserted)
      } else if (element.attachedCallback) {
        logFlags.dom && console.log('inserted:', element.localName);
        element.attachedCallback();
      }
    }
    logFlags.dom && console.groupEnd();
  }
}

function removedNode(node) {
  removed(node);
  forSubtree(node, function(e) {
    removed(e);
  });
}

function removed(element) {
  if (hasPolyfillMutations) {
    deferMutation(function() {
      _removed(element);
    });
  } else {
    _removed(element);
  }
}

function _removed(element) {
  // TODO(sjmiles): temporary: do work on all custom elements so we can track
  // behavior even when callbacks not defined
  if (element.attachedCallback || element.detachedCallback || (element.__upgraded__ && logFlags.dom)) {
    logFlags.dom && console.group('removed:', element.localName);
    if (!inDocument(element)) {
      element.__inserted = (element.__inserted || 0) - 1;
      // if we are in a 'inserted' state, bluntly adjust to an 'removed' state
      if (element.__inserted > 0) {
        element.__inserted = 0;
      }
      // if we are 'over removed', squelch the callback
      if (element.__inserted < 0) {
        logFlags.dom && console.warn('removed:', element.localName,
            'insert/remove count:', element.__inserted)
      } else if (element.detachedCallback) {
        element.detachedCallback();
      }
    }
    logFlags.dom && console.groupEnd();
  }
}

// SD polyfill intrustion due mainly to the fact that 'document'
// is not entirely wrapped
function wrapIfNeeded(node) {
  return window.ShadowDOMPolyfill ? ShadowDOMPolyfill.wrapIfNeeded(node)
      : node;
}

function inDocument(element) {
  var p = element;
  var doc = wrapIfNeeded(document);
  while (p) {
    if (p == doc) {
      return true;
    }
    p = p.parentNode || p.host;
  }
}

function watchShadow(node) {
  if (node.shadowRoot && !node.shadowRoot.__watched) {
    logFlags.dom && console.log('watching shadow-root for: ', node.localName);
    // watch all unwatched roots...
    var root = node.shadowRoot;
    while (root) {
      watchRoot(root);
      root = root.olderShadowRoot;
    }
  }
}

function watchRoot(root) {
  if (!root.__watched) {
    observe(root);
    root.__watched = true;
  }
}

function handler(mutations) {
  //
  if (logFlags.dom) {
    var mx = mutations[0];
    if (mx && mx.type === 'childList' && mx.addedNodes) {
        if (mx.addedNodes) {
          var d = mx.addedNodes[0];
          while (d && d !== document && !d.host) {
            d = d.parentNode;
          }
          var u = d && (d.URL || d._URL || (d.host && d.host.localName)) || '';
          u = u.split('/?').shift().split('/').pop();
        }
    }
    console.group('mutations (%d) [%s]', mutations.length, u || '');
  }
  //
  mutations.forEach(function(mx) {
    //logFlags.dom && console.group('mutation');
    if (mx.type === 'childList') {
      forEach(mx.addedNodes, function(n) {
        //logFlags.dom && console.log(n.localName);
        if (!n.localName) {
          return;
        }
        // nodes added may need lifecycle management
        addedNode(n);
      });
      // removed nodes may need lifecycle management
      forEach(mx.removedNodes, function(n) {
        //logFlags.dom && console.log(n.localName);
        if (!n.localName) {
          return;
        }
        removedNode(n);
      });
    }
    //logFlags.dom && console.groupEnd();
  });
  logFlags.dom && console.groupEnd();
};

var observer = new MutationObserver(handler);

function takeRecords() {
  // TODO(sjmiles): ask Raf why we have to call handler ourselves
  handler(observer.takeRecords());
  takeMutations();
}

var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

function observe(inRoot) {
  observer.observe(inRoot, {childList: true, subtree: true});
}

function observeDocument(doc) {
  observe(doc);
}

function upgradeDocument(doc) {
  logFlags.dom && console.group('upgradeDocument: ', (doc.baseURI).split('/').pop());
  addedNode(doc);
  logFlags.dom && console.groupEnd();
}

function upgradeDocumentTree(doc) {
  doc = wrapIfNeeded(doc);
  //console.log('upgradeDocumentTree: ', (doc.baseURI).split('/').pop());
  // upgrade contained imported documents
  var imports = doc.querySelectorAll('link[rel=' + IMPORT_LINK_TYPE + ']');
  for (var i=0, l=imports.length, n; (i<l) && (n=imports[i]); i++) {
    if (n.import && n.import.__parsed) {
      upgradeDocumentTree(n.import);
    }
  }
  upgradeDocument(doc);
}

// exports
scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
scope.watchShadow = watchShadow;
scope.upgradeDocumentTree = upgradeDocumentTree;
scope.upgradeAll = addedNode;
scope.upgradeSubtree = addedSubtree;
scope.insertedNode = insertedNode;

scope.observeDocument = observeDocument;
scope.upgradeDocument = upgradeDocument;

scope.takeRecords = takeRecords;

})(window.CustomElements);

/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(scope) {

// import

var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;

// highlander object for parsing a document tree

var parser = {
  selectors: [
    'link[rel=' + IMPORT_LINK_TYPE + ']'
  ],
  map: {
    link: 'parseLink'
  },
  parse: function(inDocument) {
    if (!inDocument.__parsed) {
      // only parse once
      inDocument.__parsed = true;
      // all parsable elements in inDocument (depth-first pre-order traversal)
      var elts = inDocument.querySelectorAll(parser.selectors);
      // for each parsable node type, call the mapped parsing method
      forEach(elts, function(e) {
        parser[parser.map[e.localName]](e);
      });
      // upgrade all upgradeable static elements, anything dynamically
      // created should be caught by observer
      CustomElements.upgradeDocument(inDocument);
      // observe document for dom changes
      CustomElements.observeDocument(inDocument);
    }
  },
  parseLink: function(linkElt) {
    // imports
    if (isDocumentLink(linkElt)) {
      this.parseImport(linkElt);
    }
  },
  parseImport: function(linkElt) {
    if (linkElt.import) {
      parser.parse(linkElt.import);
    }
  }
};

function isDocumentLink(inElt) {
  return (inElt.localName === 'link'
      && inElt.getAttribute('rel') === IMPORT_LINK_TYPE);
}

var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);

// exports

scope.parser = parser;
scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;

})(window.CustomElements);
/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
(function(scope){

// bootstrap parsing
function bootstrap() {
  // parse document
  CustomElements.parser.parse(document);
  // one more pass before register is 'live'
  CustomElements.upgradeDocument(document);
  // install upgrade hook if HTMLImports are available
  if (window.HTMLImports) {
    HTMLImports.__importsParsingHook = function(elt) {
      CustomElements.parser.parse(elt.import);
    }
  }
  // set internal 'ready' flag, now document.registerElement will trigger 
  // synchronous upgrades
  CustomElements.ready = true;
  // async to ensure *native* custom elements upgrade prior to this
  // DOMContentLoaded can fire before elements upgrade (e.g. when there's
  // an external script)
  setTimeout(function() {
    // capture blunt profiling data
    CustomElements.readyTime = Date.now();
    if (window.HTMLImports) {
      CustomElements.elapsed = CustomElements.readyTime - HTMLImports.readyTime;
    }
    // notify the system that we are bootstrapped
    document.dispatchEvent(
      new CustomEvent('WebComponentsReady', {bubbles: true})
    );
  });
}

// CustomEvent shim for IE
if (typeof window.CustomEvent !== 'function') {
  window.CustomEvent = function(inType, params) {
    params = params || {};
    var e = document.createEvent('CustomEvent');
    e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
    return e;
  };
  window.CustomEvent.prototype = window.Event.prototype;
}

// When loading at readyState complete time (or via flag), boot custom elements
// immediately.
// If relevant, HTMLImports must already be loaded.
if (document.readyState === 'complete' || scope.flags.eager) {
  bootstrap();
// When loading at readyState interactive time, bootstrap only if HTMLImports
// are not pending. Also avoid IE as the semantics of this state are unreliable.
} else if (document.readyState === 'interactive' && !window.attachEvent &&
    (!window.HTMLImports || window.HTMLImports.ready)) {
  bootstrap();
// When loading at other readyStates, wait for the appropriate DOM event to 
// bootstrap.
} else {
  var loadEvent = window.HTMLImports && !HTMLImports.ready ?
      'HTMLImportsLoaded' : 'DOMContentLoaded';
  window.addEventListener(loadEvent, bootstrap);
}

})(window.CustomElements);

(function () {

/*** Variables ***/

  var win = window,
    doc = document,
    attrProto = {
      setAttribute: Element.prototype.setAttribute,
      removeAttribute: Element.prototype.removeAttribute
    },
    hasShadow = Element.prototype.createShadowRoot,
    container = doc.createElement('div'),
    noop = function(){},
    trueop = function(){ return true; },
    regexCamelToDash = /([a-z])([A-Z])/g,
    regexPseudoParens = /\(|\)/g,
    regexPseudoCapture = /:(\w+)\u276A(.+?(?=\u276B))|:(\w+)/g,
    regexDigits = /(\d+)/g,
    keypseudo = {
      action: function (pseudo, event) {
        return pseudo.value.match(regexDigits).indexOf(String(event.keyCode)) > -1 == (pseudo.name == 'keypass') || null;
      }
    },
    /*
      - The prefix object generated here is added to the xtag object as xtag.prefix later in the code
      - Prefix provides a variety of prefix variations for the browser in which your code is running
      - The 4 variations of prefix are as follows:
        * prefix.dom: the correct prefix case and form when used on DOM elements/style properties
        * prefix.lowercase: a lowercase version of the prefix for use in various user-code situations
        * prefix.css: the lowercase, dashed version of the prefix
        * prefix.js: addresses prefixed APIs present in global and non-Element contexts
    */
    prefix = (function () {
      var styles = win.getComputedStyle(doc.documentElement, ''),
          pre = (Array.prototype.slice
            .call(styles)
            .join('')
            .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o'])
          )[1];
      return {
        dom: pre == 'ms' ? 'MS' : pre,
        lowercase: pre,
        css: '-' + pre + '-',
        js: pre == 'ms' ? pre : pre[0].toUpperCase() + pre.substr(1)
      };
    })(),
    matchSelector = Element.prototype.matchesSelector || Element.prototype[prefix.lowercase + 'MatchesSelector'],
    mutation = win.MutationObserver || win[prefix.js + 'MutationObserver'];

/*** Functions ***/

// Utilities

  /*
    This is an enhanced typeof check for all types of objects. Where typeof would normaly return
    'object' for many common DOM objects (like NodeLists and HTMLCollections).
    - For example: typeOf(document.children) will correctly return 'htmlcollection'
  */
  var typeCache = {},
      typeString = typeCache.toString,
      typeRegexp = /\s([a-zA-Z]+)/;
  function typeOf(obj) {
    var type = typeString.call(obj);
    return typeCache[type] || (typeCache[type] = type.match(typeRegexp)[1].toLowerCase());
  }

  function clone(item, type){
    var fn = clone[type || typeOf(item)];
    return fn ? fn(item) : item;
  }
    clone.object = function(src){
      var obj = {};
      for (var key in src) obj[key] = clone(src[key]);
      return obj;
    };
    clone.array = function(src){
      var i = src.length, array = new Array(i);
      while (i--) array[i] = clone(src[i]);
      return array;
    };

  /*
    The toArray() method allows for conversion of any object to a true array. For types that
    cannot be converted to an array, the method returns a 1 item array containing the passed-in object.
  */
  var unsliceable = ['undefined', 'null', 'number', 'boolean', 'string', 'function'];
  function toArray(obj){
    return unsliceable.indexOf(typeOf(obj)) == -1 ?
    Array.prototype.slice.call(obj, 0) :
    [obj];
  }

// DOM

  var str = '';
  function query(element, selector){
    return (selector || str).length ? toArray(element.querySelectorAll(selector)) : [];
  }

  function parseMutations(element, mutations) {
    var diff = { added: [], removed: [] };
    mutations.forEach(function(record){
      record._mutation = true;
      for (var z in diff) {
        var type = element._records[(z == 'added') ? 'inserted' : 'removed'],
          nodes = record[z + 'Nodes'], length = nodes.length;
        for (var i = 0; i < length && diff[z].indexOf(nodes[i]) == -1; i++){
          diff[z].push(nodes[i]);
          type.forEach(function(fn){
            fn(nodes[i], record);
          });
        }
      }
    });
  }

// Pseudos

  function parsePseudo(fn){fn();}

// Mixins

  function mergeOne(source, key, current){
    var type = typeOf(current);
    if (type == 'object' && typeOf(source[key]) == 'object') xtag.merge(source[key], current);
    else source[key] = clone(current, type);
    return source;
  }

  function wrapMixin(tag, key, pseudo, value, original){
    var fn = original[key];
    if (!(key in original)) {
      original[key + (pseudo.match(':mixins') ? '' : ':mixins')] = value;
    }
    else if (typeof original[key] == 'function') {
      if (!fn.__mixins__) fn.__mixins__ = [];
      fn.__mixins__.push(xtag.applyPseudos(pseudo, value, tag.pseudos));
    }
  }

  var uniqueMixinCount = 0;
  function mergeMixin(tag, mixin, original, mix) {
    if (mix) {
      var uniques = {};
      for (var z in original) uniques[z.split(':')[0]] = z;
      for (z in mixin) {
        wrapMixin(tag, uniques[z.split(':')[0]] || z, z, mixin[z], original);
      }
    }
    else {
      for (var zz in mixin){
        original[zz + ':__mixin__(' + (uniqueMixinCount++) + ')'] = xtag.applyPseudos(zz, mixin[zz], tag.pseudos);
      }
    }
  }

  function applyMixins(tag) {
    tag.mixins.forEach(function (name) {
      var mixin = xtag.mixins[name];
      for (var type in mixin) {
        var item = mixin[type],
            original = tag[type];
        if (!original) tag[type] = item;
        else {
          switch (type){
            case 'accessors': case 'prototype':
              for (var z in item) {
                if (!original[z]) original[z] = item[z];
                else mergeMixin(tag, item[z], original[z], true);
              }
              break;
            default: mergeMixin(tag, item, original, type != 'events');
          }
        }
      }
    });
    return tag;
  }

// Events

  function delegateAction(pseudo, event) {
    var match, target = event.target;
    if (!target.tagName) return null;
    if (xtag.matchSelector(target, pseudo.value)) match = target;
    else if (xtag.matchSelector(target, pseudo.value + ' *')) {
      var parent = target.parentNode;
      while (!match) {
        if (xtag.matchSelector(parent, pseudo.value)) match = parent;
        parent = parent.parentNode;
      }
    }
    return match ? pseudo.listener = pseudo.listener.bind(match) : null;
  }

  function touchFilter(event) {
    if (event.type.match('touch')){
      event.target.__touched__ = true;
    }
    else if (event.target.__touched__ && event.type.match('mouse')){
      delete event.target.__touched__;
      return;
    }
    return true;
  }

  function writeProperty(key, event, base, desc){
    if (desc) event[key] = base[key];
    else Object.defineProperty(event, key, {
      writable: true,
      enumerable: true,
      value: base[key]
    });
  }

  var skipProps = {};
  for (var z in doc.createEvent('CustomEvent')) skipProps[z] = 1;
  function inheritEvent(event, base){
    var desc = Object.getOwnPropertyDescriptor(event, 'target');
    for (var z in base) {
      if (!skipProps[z]) writeProperty(z, event, base, desc);
    }
    event.baseEvent = base;
  }

// Accessors

  function modAttr(element, attr, name, value, method){
    attrProto[method].call(element, name, attr && attr.boolean ? '' : value);
  }

  function syncAttr(element, attr, name, value, method){
    if (attr && (attr.property || attr.selector)) {
      var nodes = attr.property ? [element.xtag[attr.property]] : attr.selector ? xtag.query(element, attr.selector) : [],
          index = nodes.length;
      while (index--) nodes[index][method](name, value);
    }
  }

  function updateView(element, name, value){
    if (element.__view__){
      element.__view__.updateBindingValue(element, name, value);
    }
  }

  function attachProperties(tag, prop, z, accessor, attr, name){
    var key = z.split(':'), type = key[0];
    if (type == 'get') {
      key[0] = prop;
      tag.prototype[prop].get = xtag.applyPseudos(key.join(':'), accessor[z], tag.pseudos, accessor[z]);
    }
    else if (type == 'set') {
      key[0] = prop;
      var setter = tag.prototype[prop].set = xtag.applyPseudos(key.join(':'), attr ? function(value){
          value = attr.boolean ? !!value : attr.validate ? attr.validate.call(this, value) : value;
          var method = attr.boolean ? (value ? 'setAttribute' : 'removeAttribute') : 'setAttribute';
        modAttr(this, attr, name, value, method);
        accessor[z].call(this, value);
        syncAttr(this, attr, name, value, method);
        updateView(this, prop, value);
      } : accessor[z] ? function(value){
        accessor[z].call(this, value);
        updateView(this, prop, value);
      } : null, tag.pseudos, accessor[z]);

      if (attr) attr.setter = accessor[z];
    }
    else tag.prototype[prop][z] = accessor[z];
  }

  function parseAccessor(tag, prop){
    tag.prototype[prop] = {};
    var accessor = tag.accessors[prop],
        attr = accessor.attribute,
        name;

    if (attr) {
      name = attr.name = (attr ? (attr.name || prop.replace(regexCamelToDash, '$1-$2')) : prop).toLowerCase();
      attr.key = prop;
      tag.attributes[name] = attr;
    }

    for (var z in accessor) attachProperties(tag, prop, z, accessor, attr, name);

    if (attr) {
      if (!tag.prototype[prop].get) {
        var method = (attr.boolean ? 'has' : 'get') + 'Attribute';
        tag.prototype[prop].get = function(){
          return this[method](name);
        };
      }
      if (!tag.prototype[prop].set) tag.prototype[prop].set = function(value){
        value = attr.boolean ? !!value : attr.validate ? attr.validate.call(this, value) : value;
        var method = attr.boolean ? (value ? 'setAttribute' : 'removeAttribute') : 'setAttribute';
        modAttr(this, attr, name, value, method);
        syncAttr(this, attr, name, value, method);
        updateView(this, name, value);
      };
    }
  }

  var unwrapComment = /\/\*!?(?:\@preserve)?[ \t]*(?:\r\n|\n)([\s\S]*?)(?:\r\n|\n)\s*\*\//;
  function parseMultiline(fn){
    return unwrapComment.exec(fn.toString())[1];
  }

/*** X-Tag Object Definition ***/

  var xtag = {
    tags: {},
    defaultOptions: {
      pseudos: [],
      mixins: [],
      events: {},
      methods: {},
      accessors: {},
      lifecycle: {},
      attributes: {},
      'prototype': {
        xtag: {
          get: function(){
            return this.__xtag__ ? this.__xtag__ : (this.__xtag__ = { data: {} });
          }
        }
      }
    },
    register: function (name, options) {
      var _name;
      if (typeof name == 'string') {
        _name = name.toLowerCase();
      } else {
        return;
      }
      xtag.tags[_name] = options || {};
      // save prototype for actual object creation below
      var basePrototype = options.prototype;
      delete options.prototype;
      var tag = xtag.tags[_name].compiled = applyMixins(xtag.merge({}, xtag.defaultOptions, options));

      for (var z in tag.events) tag.events[z] = xtag.parseEvent(z, tag.events[z]);
      for (z in tag.lifecycle) tag.lifecycle[z.split(':')[0]] = xtag.applyPseudos(z, tag.lifecycle[z], tag.pseudos, tag.lifecycle[z]);
      for (z in tag.methods) tag.prototype[z.split(':')[0]] = { value: xtag.applyPseudos(z, tag.methods[z], tag.pseudos, tag.methods[z]), enumerable: true };
      for (z in tag.accessors) parseAccessor(tag, z);

      tag.shadow = tag.shadow ? xtag.createFragment(tag.shadow) : null;
      tag.content = tag.content ? xtag.createFragment(tag.content) : null;
      var ready = tag.lifecycle.created || tag.lifecycle.ready;
      tag.prototype.createdCallback = {
        enumerable: true,
        value: function(){
          var element = this;
          if (tag.shadow && hasShadow) this.createShadowRoot().appendChild(tag.shadow.cloneNode(true));
          if (tag.content) this.appendChild(tag.content.cloneNode(true));
          xtag.addEvents(this, tag.events);
          var output = ready ? ready.apply(this, arguments) : null;
          for (var name in tag.attributes) {
            var attr = tag.attributes[name],
                hasAttr = this.hasAttribute(name);
            if (hasAttr || attr.boolean) {
              this[attr.key] = attr.boolean ? hasAttr : this.getAttribute(name);
            }
          }
          tag.pseudos.forEach(function(obj){
            obj.onAdd.call(element, obj);
          });
          return output;
        }
      };

      var inserted = tag.lifecycle.inserted,
          removed = tag.lifecycle.removed;
      if (inserted || removed) {
        tag.prototype.attachedCallback = { value: function(){
          if (removed) this.xtag.__parentNode__ = this.parentNode;
          if (inserted) return inserted.apply(this, arguments);
        }, enumerable: true };
      }
      if (removed) {
        tag.prototype.detachedCallback = { value: function(){
          var args = toArray(arguments);
          args.unshift(this.xtag.__parentNode__);
          var output = removed.apply(this, args);
          delete this.xtag.__parentNode__;
          return output;
        }, enumerable: true };
      }
      if (tag.lifecycle.attributeChanged) tag.prototype.attributeChangedCallback = { value: tag.lifecycle.attributeChanged, enumerable: true };

      tag.prototype.setAttribute = {
        writable: true,
        enumberable: true,
        value: function (name, value){
          var _name = name.toLowerCase();
          var attr = tag.attributes[_name];
          if (attr) {
            value = attr.boolean ? '' : attr.validate ? attr.validate.call(this, value) : value;
          }
          modAttr(this, attr, _name, value, 'setAttribute');
          if (attr) {
            if (attr.setter) attr.setter.call(this, attr.boolean ? true : value);
            syncAttr(this, attr, _name, value, 'setAttribute');
          }
        }
      };

      tag.prototype.removeAttribute = {
        writable: true,
        enumberable: true,
        value: function (name){
          var _name = name.toLowerCase();
          var attr = tag.attributes[_name];
          modAttr(this, attr, _name, '', 'removeAttribute');
          if (attr) {
            if (attr.setter) attr.setter.call(this, attr.boolean ? false : undefined);
            syncAttr(this, attr, _name, '', 'removeAttribute');
          }
        }
      };

      var elementProto = basePrototype ?
            basePrototype :
            options['extends'] ?
            Object.create(doc.createElement(options['extends']).constructor).prototype :
            win.HTMLElement.prototype;

      var definition = {
        'prototype': Object.create(elementProto, tag.prototype)
      };
      if (options['extends']) {
        definition['extends'] = options['extends'];
      }
      var reg = doc.registerElement(_name, definition);
      return reg;
    },

    /* Exposed Variables */

    mixins: {},
    prefix: prefix,
    captureEvents: ['focus', 'blur', 'scroll', 'underflow', 'overflow', 'overflowchanged', 'DOMMouseScroll'],
    customEvents: {
      animationstart: {
        attach: [prefix.dom + 'AnimationStart']
      },
      animationend: {
        attach: [prefix.dom + 'AnimationEnd']
      },
      transitionend: {
        attach: [prefix.dom + 'TransitionEnd']
      },
      move: {
        attach: ['mousemove', 'touchmove'],
        condition: touchFilter
      },
      enter: {
        attach: ['mouseover', 'touchenter'],
        condition: touchFilter
      },
      leave: {
        attach: ['mouseout', 'touchleave'],
        condition: touchFilter
      },
      scrollwheel: {
        attach: ['DOMMouseScroll', 'mousewheel'],
        condition: function(event){
          event.delta = event.wheelDelta ? event.wheelDelta / 40 : Math.round(event.detail / 3.5 * -1);
          return true;
        }
      },
      tapstart: {
        observe: {
          mousedown: doc,
          touchstart: doc
        },
        condition: touchFilter
      },
      tapend: {
        observe: {
          mouseup: doc,
          touchend: doc
        },
        condition: touchFilter
      },
      tapmove: {
        attach: ['tapstart', 'dragend', 'touchcancel'],
        condition: function(event, custom){
          switch (event.type) {
            case 'move':  return true;
            case 'dragover':
              var last = custom.lastDrag || {};
              custom.lastDrag = event;
              return (last.pageX != event.pageX && last.pageY != event.pageY) || null;
            case 'tapstart':
              if (!custom.move) {
                custom.current = this;
                custom.move = xtag.addEvents(this, {
                  move: custom.listener,
                  dragover: custom.listener
                });
                custom.tapend = xtag.addEvent(doc, 'tapend', custom.listener);
              }
              break;
            case 'tapend': case 'dragend': case 'touchcancel':
              if (!event.touches.length) {
                if (custom.move) xtag.removeEvents(custom.current , custom.move || {});
                if (custom.tapend) xtag.removeEvent(doc, custom.tapend || {});
                delete custom.lastDrag;
                delete custom.current;
                delete custom.tapend;
                delete custom.move;
              }
          }
        }
      }
    },
    pseudos: {
      __mixin__: {},
      /*


      */
      mixins: {
        onCompiled: function(fn, pseudo){
          var mixins = pseudo.source.__mixins__;
          if (mixins) switch (pseudo.value) {
            case 'before': return function(){
              var self = this,
                  args = arguments;
              mixins.forEach(function(m){
                m.apply(self, args);
              });
              return fn.apply(self, args);
            };
            case null: case '': case 'after': return function(){
              var self = this,
                  args = arguments;
                  returns = fn.apply(self, args);
              mixins.forEach(function(m){
                m.apply(self, args);
              });
              return returns;
            };
          }
        }
      },
      keypass: keypseudo,
      keyfail: keypseudo,
      delegate: { action: delegateAction },
      within: {
        action: delegateAction,
        onAdd: function(pseudo){
          var condition = pseudo.source.condition;
          if (condition) pseudo.source.condition = function(event, custom){
            return xtag.query(this, pseudo.value).filter(function(node){
              return node == event.target || node.contains ? node.contains(event.target) : null;
            })[0] ? condition.call(this, event, custom) : null;
          };
        }
      },
      preventable: {
        action: function (pseudo, event) {
          return !event.defaultPrevented;
        }
      }
    },

    /* UTILITIES */

    clone: clone,
    typeOf: typeOf,
    toArray: toArray,

    wrap: function (original, fn) {
      return function(){
        var args = arguments,
            output = original.apply(this, args);
        fn.apply(this, args);
        return output;
      };
    },
    /*
      Recursively merges one object with another. The first argument is the destination object,
      all other objects passed in as arguments are merged from right to left, conflicts are overwritten
    */
    merge: function(source, k, v){
      if (typeOf(k) == 'string') return mergeOne(source, k, v);
      for (var i = 1, l = arguments.length; i < l; i++){
        var object = arguments[i];
        for (var key in object) mergeOne(source, key, object[key]);
      }
      return source;
    },

    /*
      ----- This should be simplified! -----
      Generates a random ID string
    */
    uid: function(){
      return Math.random().toString(36).substr(2,10);
    },

    /* DOM */

    query: query,

    skipTransition: function(element, fn, bind){
      var prop = prefix.js + 'TransitionProperty';
      element.style[prop] = element.style.transitionProperty = 'none';
      var callback = fn ? fn.call(bind || element) : null;
      return xtag.skipFrame(function(){
        element.style[prop] = element.style.transitionProperty = '';
        if (callback) callback.call(bind || element);
      });
    },

    requestFrame: (function(){
      var raf = win.requestAnimationFrame ||
                win[prefix.lowercase + 'RequestAnimationFrame'] ||
                function(fn){ return win.setTimeout(fn, 20); };
      return function(fn){ return raf(fn); };
    })(),

    cancelFrame: (function(){
      var cancel = win.cancelAnimationFrame ||
                   win[prefix.lowercase + 'CancelAnimationFrame'] ||
                   win.clearTimeout;
      return function(id){ return cancel(id); };
    })(),

    skipFrame: function(fn){
      var id = xtag.requestFrame(function(){ id = xtag.requestFrame(fn); });
      return id;
    },

    matchSelector: function (element, selector) {
      return matchSelector.call(element, selector);
    },

    set: function (element, method, value) {
      element[method] = value;
      if (window.CustomElements) CustomElements.upgradeAll(element);
    },

    innerHTML: function(el, html){
      xtag.set(el, 'innerHTML', html);
    },

    hasClass: function (element, klass) {
      return element.className.split(' ').indexOf(klass.trim())>-1;
    },

    addClass: function (element, klass) {
      var list = element.className.trim().split(' ');
      klass.trim().split(' ').forEach(function (name) {
        if (!~list.indexOf(name)) list.push(name);
      });
      element.className = list.join(' ').trim();
      return element;
    },

    removeClass: function (element, klass) {
      var classes = klass.trim().split(' ');
      element.className = element.className.trim().split(' ').filter(function (name) {
        return name && !~classes.indexOf(name);
      }).join(' ');
      return element;
    },

    toggleClass: function (element, klass) {
      return xtag[xtag.hasClass(element, klass) ? 'removeClass' : 'addClass'].call(null, element, klass);
    },

    /*
      Runs a query on only the children of an element
    */
    queryChildren: function (element, selector) {
      var id = element.id,
        guid = element.id = id || 'x_' + xtag.uid(),
        attr = '#' + guid + ' > ',
        noParent = false;
      if (!element.parentNode){
        noParent = true;
        container.appendChild(element);
      }
      selector = attr + (selector + '').replace(',', ',' + attr, 'g');
      var result = element.parentNode.querySelectorAll(selector);
      if (!id) element.removeAttribute('id');
      if (noParent){
        container.removeChild(element);
      }
      return toArray(result);
    },
    /*
      Creates a document fragment with the content passed in - content can be
      a string of HTML, an element, or an array/collection of elements
    */
    createFragment: function(content) {
      var frag = doc.createDocumentFragment();
      if (content) {
        var div = frag.appendChild(doc.createElement('div')),
          nodes = toArray(content.nodeName ? arguments : !(div.innerHTML = typeof content == 'function' ? parseMultiline(content) : content) || div.children),
          length = nodes.length,
          index = 0;
        while (index < length) frag.insertBefore(nodes[index++], div);
        frag.removeChild(div);
      }
      return frag;
    },

    /*
      Removes an element from the DOM for more performant node manipulation. The element
      is placed back into the DOM at the place it was taken from.
    */
    manipulate: function(element, fn){
      var next = element.nextSibling,
        parent = element.parentNode,
        frag = doc.createDocumentFragment(),
        returned = fn.call(frag.appendChild(element), frag) || element;
      if (next) parent.insertBefore(returned, next);
      else parent.appendChild(returned);
    },

    /* PSEUDOS */

    applyPseudos: function(key, fn, target, source) {
      var listener = fn,
          pseudos = {};
      if (key.match(':')) {
        var matches = [],
            valueFlag = 0;
        key.replace(regexPseudoParens, function(match){
          if (match == '(') return ++valueFlag == 1 ? '\u276A' : '(';
          return !--valueFlag ? '\u276B' : ')';
        }).replace(regexPseudoCapture, function(z, name, value, solo){
          matches.push([name || solo, value]);
        });
        var i = matches.length;
        while (i--) parsePseudo(function(){
          var name = matches[i][0],
              value = matches[i][1];
          if (!xtag.pseudos[name]) throw "pseudo not found: " + name + " " + value;
          value = (value === '' || typeof value == 'undefined') ? null : value;
          var pseudo = pseudos[i] = Object.create(xtag.pseudos[name]);
          pseudo.key = key;
          pseudo.name = name;
          pseudo.value = value;
          pseudo['arguments'] = (value || '').split(',');
          pseudo.action = pseudo.action || trueop;
          pseudo.source = source;
          var original = pseudo.listener = listener;
          listener = function(){
            var output = pseudo.action.apply(this, [pseudo].concat(toArray(arguments)));
            if (output === null || output === false) return output;
            output = pseudo.listener.apply(this, arguments);
            pseudo.listener = original;
            return output;
          };
          if (target && pseudo.onAdd) {
            if (target.nodeName) pseudo.onAdd.call(target, pseudo);
            else target.push(pseudo);
          }
        });
      }
      for (var z in pseudos) {
        if (pseudos[z].onCompiled) listener = pseudos[z].onCompiled(listener, pseudos[z]) || listener;
      }
      return listener;
    },

    removePseudos: function(target, pseudos){
      pseudos.forEach(function(obj){
        if (obj.onRemove) obj.onRemove.call(target, obj);
      });
    },

  /*** Events ***/

    parseEvent: function(type, fn) {
      var pseudos = type.split(':'),
          key = pseudos.shift(),
          custom = xtag.customEvents[key],
          event = xtag.merge({
            type: key,
            stack: noop,
            condition: trueop,
            attach: [],
            _attach: [],
            pseudos: '',
            _pseudos: [],
            onAdd: noop,
            onRemove: noop
          }, custom || {});
      event.attach = toArray(event.base || event.attach);
      event.chain = key + (event.pseudos.length ? ':' + event.pseudos : '') + (pseudos.length ? ':' + pseudos.join(':') : '');
      var condition = event.condition;
      event.condition = function(e){
        var t = e.touches, tt = e.targetTouches;
        return condition.apply(this, arguments);
      };
      var stack = xtag.applyPseudos(event.chain, fn, event._pseudos, event);
      event.stack = function(e){
        e.currentTarget = e.currentTarget || this;
        var t = e.touches, tt = e.targetTouches;
        var detail = e.detail || {};
        if (!detail.__stack__) return stack.apply(this, arguments);
        else if (detail.__stack__ == stack) {
          e.stopPropagation();
          e.cancelBubble = true;
          return stack.apply(this, arguments);
        }
      };
      event.listener = function(e){
        var args = toArray(arguments),
            output = event.condition.apply(this, args.concat([event]));
        if (!output) return output;
        // The second condition in this IF is to address the following Blink regression: https://code.google.com/p/chromium/issues/detail?id=367537
        // Remove this when affected browser builds with this regression fall below 5% marketshare
        if (e.type != key && (e.baseEvent && e.type != e.baseEvent.type)) {
          xtag.fireEvent(e.target, key, {
            baseEvent: e,
            detail: output !== true && (output.__stack__ = stack) ? output : { __stack__: stack }
          });
        }
        else return event.stack.apply(this, args);
      };
      event.attach.forEach(function(name) {
        event._attach.push(xtag.parseEvent(name, event.listener));
      });
      if (custom && custom.observe && !custom.__observing__) {
        custom.observer = function(e){
          var output = event.condition.apply(this, toArray(arguments).concat([custom]));
          if (!output) return output;
          xtag.fireEvent(e.target, key, {
            baseEvent: e,
            detail: output !== true ? output : {}
          });
        };
        for (var z in custom.observe) xtag.addEvent(custom.observe[z] || document, z, custom.observer, true);
        custom.__observing__ = true;
      }
      return event;
    },

    addEvent: function (element, type, fn, capture) {
      var event = typeof fn == 'function' ? xtag.parseEvent(type, fn) : fn;
      event._pseudos.forEach(function(obj){
        obj.onAdd.call(element, obj);
      });
      event._attach.forEach(function(obj) {
        xtag.addEvent(element, obj.type, obj);
      });
      event.onAdd.call(element, event, event.listener);
      element.addEventListener(event.type, event.stack, capture || xtag.captureEvents.indexOf(event.type) > -1);
      return event;
    },

    addEvents: function (element, obj) {
      var events = {};
      for (var z in obj) {
        events[z] = xtag.addEvent(element, z, obj[z]);
      }
      return events;
    },

    removeEvent: function (element, type, event) {
      event = event || type;
      event.onRemove.call(element, event, event.listener);
      xtag.removePseudos(element, event._pseudos);
      event._attach.forEach(function(obj) {
        xtag.removeEvent(element, obj);
      });
      element.removeEventListener(event.type, event.stack);
    },

    removeEvents: function(element, obj){
      for (var z in obj) xtag.removeEvent(element, obj[z]);
    },

    fireEvent: function(element, type, options){
      var event = doc.createEvent('CustomEvent');
      options = options || {};
      event.initCustomEvent(type,
        options.bubbles !== false,
        options.cancelable !== false,
        options.detail
      );
      if (options.baseEvent) inheritEvent(event, options.baseEvent);
      element.dispatchEvent(event);
    },

    /*
      Listens for insertion or removal of nodes from a given element using
      Mutation Observers, or Mutation Events as a fallback
    */
    addObserver: function(element, type, fn){
      if (!element._records) {
        element._records = { inserted: [], removed: [] };
        if (mutation){
          element._observer = new mutation(function(mutations) {
            parseMutations(element, mutations);
          });
          element._observer.observe(element, {
            subtree: true,
            childList: true,
            attributes: !true,
            characterData: false
          });
        }
        else ['Inserted', 'Removed'].forEach(function(type){
          element.addEventListener('DOMNode' + type, function(event){
            event._mutation = true;
            element._records[type.toLowerCase()].forEach(function(fn){
              fn(event.target, event);
            });
          }, false);
        });
      }
      if (element._records[type].indexOf(fn) == -1) element._records[type].push(fn);
    },

    removeObserver: function(element, type, fn){
      var obj = element._records;
      if (obj && fn){
        obj[type].splice(obj[type].indexOf(fn), 1);
      }
      else{
        obj[type] = [];
      }
    }

  };

/*** Universal Touch ***/

var touching = false,
    touchTarget = null;

doc.addEventListener('mousedown', function(e){
  touching = true;
  touchTarget = e.target;
}, true);

doc.addEventListener('mouseup', function(){
  touching = false;
  touchTarget = null;
}, true);

doc.addEventListener('dragend', function(){
  touching = false;
  touchTarget = null;
}, true);

var UIEventProto = {
  touches: {
    configurable: true,
    get: function(){
      return this.__touches__ ||
        (this.identifier = 0) ||
        (this.__touches__ = touching ? [this] : []);
    }
  },
  targetTouches: {
    configurable: true,
    get: function(){
      return this.__targetTouches__ || (this.__targetTouches__ =
        (touching && this.currentTarget &&
        (this.currentTarget == touchTarget ||
        (this.currentTarget.contains && this.currentTarget.contains(touchTarget)))) ? (this.identifier = 0) || [this] : []);
    }
  },
  changedTouches: {
    configurable: true,
    get: function(){
      return this.__changedTouches__ || (this.identifier = 0) || (this.__changedTouches__ = [this]);
    }
  }
};

for (z in UIEventProto){
  UIEvent.prototype[z] = UIEventProto[z];
  Object.defineProperty(UIEvent.prototype, z, UIEventProto[z]);
}


/*** Custom Event Definitions ***/

  function addTap(el, tap, e){
    if (!el.__tap__) {
      el.__tap__ = { click: e.type == 'mousedown' };
      if (el.__tap__.click) el.addEventListener('click', tap.observer);
      else {
        el.__tap__.scroll = tap.observer.bind(el);
        window.addEventListener('scroll', el.__tap__.scroll, true);
        el.addEventListener('touchmove', tap.observer);
        el.addEventListener('touchcancel', tap.observer);
        el.addEventListener('touchend', tap.observer);
      }
    }
    if (!el.__tap__.click) {
      el.__tap__.x = e.touches[0].pageX;
      el.__tap__.y = e.touches[0].pageY;
    }
  }

  function removeTap(el, tap){
    if (el.__tap__) {
      if (el.__tap__.click) el.removeEventListener('click', tap.observer);
      else {
        window.removeEventListener('scroll', el.__tap__.scroll, true);
        el.removeEventListener('touchmove', tap.observer);
        el.removeEventListener('touchcancel', tap.observer);
        el.removeEventListener('touchend', tap.observer);
      }
      delete el.__tap__;
    }
  }

  function checkTapPosition(el, tap, e){
    var touch = e.changedTouches[0],
        tol = tap.gesture.tolerance;
    if (
      touch.pageX < el.__tap__.x + tol &&
      touch.pageX > el.__tap__.x - tol &&
      touch.pageY < el.__tap__.y + tol &&
      touch.pageY > el.__tap__.y - tol
    ) return true;
  }

  xtag.customEvents.tap = {
    observe: {
      mousedown: document,
      touchstart: document
    },
    gesture: {
      tolerance: 8
    },
    condition: function(e, tap){
      var el = e.target;
      switch (e.type) {
        case 'touchstart':
          if (el.__tap__ && el.__tap__.click) removeTap(el, tap);
          addTap(el, tap, e);
          return;
        case 'mousedown':
          if (!el.__tap__) addTap(el, tap, e);
          return;
        case 'scroll':
        case 'touchcancel':
          removeTap(this, tap);
          return;
        case 'touchmove':
        case 'touchend':
          if (this.__tap__ && !checkTapPosition(this, tap, e)) {
            removeTap(this, tap);
            return;
          }
          return e.type == 'touchend' || null;
        case 'click':
          removeTap(this, tap);
          return true;
      }
    }
  };

  win.xtag = xtag;
  if (typeof define == 'function' && define.amd) define(xtag);

  doc.addEventListener('WebComponentsReady', function(){
    xtag.fireEvent(doc.body, 'DOMComponentsLoaded');
  });

})();
},{}],35:[function(require,module,exports){
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */

;(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.NProgress = factory();
  }

})(this, function() {
  var NProgress = {};

  NProgress.version = '0.1.6';

  var Settings = NProgress.settings = {
    minimum: 0.08,
    easing: 'ease',
    positionUsing: '',
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    showSpinner: true,
    barSelector: '[role="bar"]',
    spinnerSelector: '[role="spinner"]',
    parent: 'body',
    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
  };

  /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */
  NProgress.configure = function(options) {
    var key, value;
    for (key in options) {
      value = options[key];
      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
    }

    return this;
  };

  /**
   * Last number.
   */

  NProgress.status = null;

  /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */

  NProgress.set = function(n) {
    var started = NProgress.isStarted();

    n = clamp(n, Settings.minimum, 1);
    NProgress.status = (n === 1 ? null : n);

    var progress = NProgress.render(!started),
        bar      = progress.querySelector(Settings.barSelector),
        speed    = Settings.speed,
        ease     = Settings.easing;

    progress.offsetWidth; /* Repaint */

    queue(function(next) {
      // Set positionUsing if it hasn't already been set
      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

      // Add transition
      css(bar, barPositionCSS(n, speed, ease));

      if (n === 1) {
        // Fade out
        css(progress, { 
          transition: 'none', 
          opacity: 1 
        });
        progress.offsetWidth; /* Repaint */

        setTimeout(function() {
          css(progress, { 
            transition: 'all ' + speed + 'ms linear', 
            opacity: 0 
          });
          setTimeout(function() {
            NProgress.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(next, speed);
      }
    });

    return this;
  };

  NProgress.isStarted = function() {
    return typeof NProgress.status === 'number';
  };

  /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */
  NProgress.start = function() {
    if (!NProgress.status) NProgress.set(0);

    var work = function() {
      setTimeout(function() {
        if (!NProgress.status) return;
        NProgress.trickle();
        work();
      }, Settings.trickleSpeed);
    };

    if (Settings.trickle) work();

    return this;
  };

  /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */

  NProgress.done = function(force) {
    if (!force && !NProgress.status) return this;

    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
  };

  /**
   * Increments by a random amount.
   */

  NProgress.inc = function(amount) {
    var n = NProgress.status;

    if (!n) {
      return NProgress.start();
    } else {
      if (typeof amount !== 'number') {
        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
      }

      n = clamp(n + amount, 0, 0.994);
      return NProgress.set(n);
    }
  };

  NProgress.trickle = function() {
    return NProgress.inc(Math.random() * Settings.trickleRate);
  };

  /**
   * Waits for all supplied jQuery promises and
   * increases the progress as the promises resolve.
   * 
   * @param $promise jQUery Promise
   */
  (function() {
    var initial = 0, current = 0;
    
    NProgress.promise = function($promise) {
      if (!$promise || $promise.state() == "resolved") {
        return this;
      }
      
      if (current == 0) {
        NProgress.start();
      }
      
      initial++;
      current++;
      
      $promise.always(function() {
        current--;
        if (current == 0) {
            initial = 0;
            NProgress.done();
        } else {
            NProgress.set((initial - current) / initial);
        }
      });
      
      return this;
    };
    
  })();

  /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */

  NProgress.render = function(fromStart) {
    if (NProgress.isRendered()) return document.getElementById('nprogress');

    addClass(document.documentElement, 'nprogress-busy');
    
    var progress = document.createElement('div');
    progress.id = 'nprogress';
    progress.innerHTML = Settings.template;

    var bar      = progress.querySelector(Settings.barSelector),
        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
        parent   = document.querySelector(Settings.parent),
        spinner;
    
    css(bar, {
      transition: 'all 0 linear',
      transform: 'translate3d(' + perc + '%,0,0)'
    });

    if (!Settings.showSpinner) {
      spinner = progress.querySelector(Settings.spinnerSelector);
      spinner && removeElement(spinner);
    }

    if (parent != document.body) {
      addClass(parent, 'nprogress-custom-parent');
    }

    parent.appendChild(progress);
    return progress;
  };

  /**
   * Removes the element. Opposite of render().
   */

  NProgress.remove = function() {
    removeClass(document.documentElement, 'nprogress-busy');
    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent')
    var progress = document.getElementById('nprogress');
    progress && removeElement(progress);
  };

  /**
   * Checks if the progress bar is rendered.
   */

  NProgress.isRendered = function() {
    return !!document.getElementById('nprogress');
  };

  /**
   * Determine which positioning CSS rule to use.
   */

  NProgress.getPositioningCSS = function() {
    // Sniff on document.body.style
    var bodyStyle = document.body.style;

    // Sniff prefixes
    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
                       ('MozTransform' in bodyStyle) ? 'Moz' :
                       ('msTransform' in bodyStyle) ? 'ms' :
                       ('OTransform' in bodyStyle) ? 'O' : '';

    if (vendorPrefix + 'Perspective' in bodyStyle) {
      // Modern browsers with 3D support, e.g. Webkit, IE10
      return 'translate3d';
    } else if (vendorPrefix + 'Transform' in bodyStyle) {
      // Browsers without 3D support, e.g. IE9
      return 'translate';
    } else {
      // Browsers without translate() support, e.g. IE7-8
      return 'margin';
    }
  };

  /**
   * Helpers
   */

  function clamp(n, min, max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
  }

  /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */

  function toBarPerc(n) {
    return (-1 + n) * 100;
  }


  /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */

  function barPositionCSS(n, speed, ease) {
    var barCSS;

    if (Settings.positionUsing === 'translate3d') {
      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
    } else if (Settings.positionUsing === 'translate') {
      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
    } else {
      barCSS = { 'margin-left': toBarPerc(n)+'%' };
    }

    barCSS.transition = 'all '+speed+'ms '+ease;

    return barCSS;
  }

  /**
   * (Internal) Queues a function to be executed.
   */

  var queue = (function() {
    var pending = [];
    
    function next() {
      var fn = pending.shift();
      if (fn) {
        fn(next);
      }
    }

    return function(fn) {
      pending.push(fn);
      if (pending.length == 1) next();
    };
  })();

  /**
   * (Internal) Applies css properties to an element, similar to the jQuery 
   * css method.
   *
   * While this helper does assist with vendor prefixed property names, it 
   * does not perform any manipulation of values prior to setting styles.
   */

  var css = (function() {
    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
        cssProps    = {};

    function camelCase(string) {
      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
        return letter.toUpperCase();
      });
    }

    function getVendorProp(name) {
      var style = document.body.style;
      if (name in style) return name;

      var i = cssPrefixes.length,
          capName = name.charAt(0).toUpperCase() + name.slice(1),
          vendorName;
      while (i--) {
        vendorName = cssPrefixes[i] + capName;
        if (vendorName in style) return vendorName;
      }

      return name;
    }

    function getStyleProp(name) {
      name = camelCase(name);
      return cssProps[name] || (cssProps[name] = getVendorProp(name));
    }

    function applyCss(element, prop, value) {
      prop = getStyleProp(prop);
      element.style[prop] = value;
    }

    return function(element, properties) {
      var args = arguments,
          prop, 
          value;

      if (args.length == 2) {
        for (prop in properties) {
          value = properties[prop];
          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
        }
      } else {
        applyCss(element, args[1], args[2]);
      }
    }
  })();

  /**
   * (Internal) Determines if an element or space separated list of class names contains a class name.
   */

  function hasClass(element, name) {
    var list = typeof element == 'string' ? element : classList(element);
    return list.indexOf(' ' + name + ' ') >= 0;
  }

  /**
   * (Internal) Adds a class to an element.
   */

  function addClass(element, name) {
    var oldList = classList(element),
        newList = oldList + name;

    if (hasClass(oldList, name)) return; 

    // Trim the opening space.
    element.className = newList.substring(1);
  }

  /**
   * (Internal) Removes a class from an element.
   */

  function removeClass(element, name) {
    var oldList = classList(element),
        newList;

    if (!hasClass(element, name)) return;

    // Replace the class name.
    newList = oldList.replace(' ' + name + ' ', ' ');

    // Trim the opening and closing spaces.
    element.className = newList.substring(1, newList.length - 1);
  }

  /**
   * (Internal) Gets a space separated list of the class names on the element. 
   * The list is wrapped with a single space on each end to facilitate finding 
   * matches within the list.
   */

  function classList(element) {
    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
  }

  /**
   * (Internal) Removes an element from the DOM.
   */

  function removeElement(element) {
    element && element.parentNode && element.parentNode.removeChild(element);
  }

  return NProgress;
});


},{}],36:[function(require,module,exports){
module.exports = require('./lib/');

},{"./lib/":37}],37:[function(require,module,exports){
// Load modules

var Stringify = require('./stringify');
var Parse = require('./parse');


// Declare internals

var internals = {};


module.exports = {
    stringify: Stringify,
    parse: Parse
};

},{"./parse":38,"./stringify":39}],38:[function(require,module,exports){
// Load modules

var Utils = require('./utils');


// Declare internals

var internals = {
    delimiter: '&',
    depth: 5,
    arrayLimit: 20,
    parameterLimit: 1000
};


internals.parseValues = function (str, options) {

    var obj = {};
    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

    for (var i = 0, il = parts.length; i < il; ++i) {
        var part = parts[i];
        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

        if (pos === -1) {
            obj[Utils.decode(part)] = '';
        }
        else {
            var key = Utils.decode(part.slice(0, pos));
            var val = Utils.decode(part.slice(pos + 1));

            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
                obj[key] = val;
            }
            else {
                obj[key] = [].concat(obj[key]).concat(val);
            }
        }
    }

    return obj;
};


internals.parseObject = function (chain, val, options) {

    if (!chain.length) {
        return val;
    }

    var root = chain.shift();

    var obj = {};
    if (root === '[]') {
        obj = [];
        obj = obj.concat(internals.parseObject(chain, val, options));
    }
    else {
        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
        var index = parseInt(cleanRoot, 10);
        var indexString = '' + index;
        if (!isNaN(index) &&
            root !== cleanRoot &&
            indexString === cleanRoot &&
            index >= 0 &&
            index <= options.arrayLimit) {

            obj = [];
            obj[index] = internals.parseObject(chain, val, options);
        }
        else {
            obj[cleanRoot] = internals.parseObject(chain, val, options);
        }
    }

    return obj;
};


internals.parseKeys = function (key, val, options) {

    if (!key) {
        return;
    }

    // The regex chunks

    var parent = /^([^\[\]]*)/;
    var child = /(\[[^\[\]]*\])/g;

    // Get the parent

    var segment = parent.exec(key);

    // Don't allow them to overwrite object prototype properties

    if (Object.prototype.hasOwnProperty(segment[1])) {
        return;
    }

    // Stash the parent if it exists

    var keys = [];
    if (segment[1]) {
        keys.push(segment[1]);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {

        ++i;
        if (!Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
            keys.push(segment[1]);
        }
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return internals.parseObject(keys, val, options);
};


module.exports = function (str, options) {

    if (str === '' ||
        str === null ||
        typeof str === 'undefined') {

        return {};
    }

    options = options || {};
    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;

    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
    var obj = {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0, il = keys.length; i < il; ++i) {
        var key = keys[i];
        var newObj = internals.parseKeys(key, tempObj[key], options);
        obj = Utils.merge(obj, newObj);
    }

    return Utils.compact(obj);
};

},{"./utils":40}],39:[function(require,module,exports){
// Load modules

var Utils = require('./utils');


// Declare internals

var internals = {
    delimiter: '&',
    arrayPrefixGenerators: {
        brackets: function (prefix, key) {
            return prefix + '[]';
        },
        indices: function (prefix, key) {
            return prefix + '[' + key + ']';
        },
        repeat: function (prefix, key) {
            return prefix;
        }
    }
};


internals.stringify = function (obj, prefix, generateArrayPrefix) {

    if (Utils.isBuffer(obj)) {
        obj = obj.toString();
    }
    else if (obj instanceof Date) {
        obj = obj.toISOString();
    }
    else if (obj === null) {
        obj = '';
    }

    if (typeof obj === 'string' ||
        typeof obj === 'number' ||
        typeof obj === 'boolean') {

        return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys = Object.keys(obj);
    for (var i = 0, il = objKeys.length; i < il; ++i) {
        var key = objKeys[i];
        if (Array.isArray(obj)) {
            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix));
        }
        else {
            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix));
        }
    }

    return values;
};


module.exports = function (obj, options) {

    options = options || {};
    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;

    var keys = [];

    if (typeof obj !== 'object' ||
        obj === null) {

        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in internals.arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    }
    else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    }
    else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];

    var objKeys = Object.keys(obj);
    for (var i = 0, il = objKeys.length; i < il; ++i) {
        var key = objKeys[i];
        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix));
    }

    return keys.join(delimiter);
};

},{"./utils":40}],40:[function(require,module,exports){
// Load modules


// Declare internals

var internals = {};


exports.arrayToObject = function (source) {

    var obj = {};
    for (var i = 0, il = source.length; i < il; ++i) {
        if (typeof source[i] !== 'undefined') {

            obj[i] = source[i];
        }
    }

    return obj;
};


exports.merge = function (target, source) {

    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        }
        else {
            target[source] = true;
        }

        return target;
    }

    if (typeof target !== 'object') {
        target = [target].concat(source);
        return target;
    }

    if (Array.isArray(target) &&
        !Array.isArray(source)) {

        target = exports.arrayToObject(target);
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];

        if (!target[key]) {
            target[key] = value;
        }
        else {
            target[key] = exports.merge(target[key], value);
        }
    }

    return target;
};


exports.decode = function (str) {

    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};


exports.compact = function (obj, refs) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    refs = refs || [];
    var lookup = refs.indexOf(obj);
    if (lookup !== -1) {
        return refs[lookup];
    }

    refs.push(obj);

    if (Array.isArray(obj)) {
        var compacted = [];

        for (var i = 0, il = obj.length; i < il; ++i) {
            if (typeof obj[i] !== 'undefined') {
                compacted.push(obj[i]);
            }
        }

        return compacted;
    }

    var keys = Object.keys(obj);
    for (i = 0, il = keys.length; i < il; ++i) {
        var key = keys[i];
        obj[key] = exports.compact(obj[key], refs);
    }

    return obj;
};


exports.isRegExp = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};


exports.isBuffer = function (obj) {

    if (obj === null ||
        typeof obj === 'undefined') {

        return false;
    }

    return !!(obj.constructor &&
        obj.constructor.isBuffer &&
        obj.constructor.isBuffer(obj));
};

},{}],41:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root = 'undefined' == typeof window
  ? this
  : window;

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

function getXHR() {
  if (root.XMLHttpRequest
    && ('file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
}

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(obj[key]));
    }
  }
  return pairs.join('&');
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  this.text = this.req.method !='HEAD' 
     ? this.xhr.responseText 
     : null;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse && str && str.length
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  var type = status / 100 | 0;

  // status / class
  this.status = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status || 1223 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self); 
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
    }

    self.callback(err, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Allow for extension
 */

Request.prototype.use = function(fn) {
  fn(this);
  return this;
}

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.field = function(name, val){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(name, val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(field, file, filename);
  return this;
};

/**
 * Send `data`, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // querystring
 *       request.get('/search')
 *         .end(callback)
 *
 *       // multiple data "writes"
 *       request.get('/search')
 *         .send({ search: 'query' })
 *         .send({ range: '1..5' })
 *         .send({ order: 'desc' })
 *         .end(callback)
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"})
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  if (2 == fn.length) return fn(err, res);
  if (err) return this.emit('error', err);
  fn(res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
  err.crossDomain = true;
  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;
    if (0 == xhr.status) {
      if (self.aborted) return self.timeoutError();
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  if (xhr.upload) {
    xhr.upload.onprogress = function(e){
      e.percent = e.loaded / e.total * 100;
      self.emit('progress', e);
    };
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var serialize = request.serialize[this.getHeader('Content-Type')];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  this.emit('request', this);
  xhr.send(data);
  return this;
};

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.del = function(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

},{"emitter":42,"reduce":43}],42:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],43:[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}],44:[function(require,module,exports){
// Serialize 0.2
// Source: https://code.google.com/p/form-serialize/source/browse/trunk/serialize-0.2.js

module.exports = function serialize(form) {
﻿  if (!form || form.nodeName !== "FORM") {
﻿  ﻿  return;
﻿  }
﻿  var i, j, q = [];
﻿  for (i = form.elements.length - 1; i >= 0; i = i - 1) {
﻿  ﻿  if (form.elements[i].name === "") {
﻿  ﻿  ﻿  continue;
﻿  ﻿  }
﻿  ﻿  switch (form.elements[i].nodeName) {
﻿  ﻿  case 'INPUT':
﻿  ﻿  ﻿  switch (form.elements[i].type) {
﻿  ﻿  ﻿  case 'text':
﻿  ﻿  ﻿  case 'hidden':
﻿  ﻿  ﻿  case 'password':
﻿  ﻿  ﻿  case 'button':
﻿  ﻿  ﻿  case 'reset':
﻿  ﻿  ﻿  case 'submit':
﻿  ﻿  ﻿  ﻿  q.push(form.elements[i].name + "=" + encodeURIComponent(form.elements[i].value));
﻿  ﻿  ﻿  ﻿  break;
﻿  ﻿  ﻿  case 'checkbox':
﻿  ﻿  ﻿  case 'radio':
﻿  ﻿  ﻿  ﻿  if (form.elements[i].checked) {
﻿  ﻿  ﻿  ﻿  ﻿  q.push(form.elements[i].name + "=" + encodeURIComponent(form.elements[i].value));
﻿  ﻿  ﻿  ﻿  }﻿  ﻿  ﻿  ﻿  ﻿  ﻿  
﻿  ﻿  ﻿  ﻿  break;
﻿  ﻿  ﻿  case 'file':
﻿  ﻿  ﻿  ﻿  break;
﻿  ﻿  ﻿  }
﻿  ﻿  ﻿  break;﻿  ﻿  ﻿   
﻿  ﻿  case 'TEXTAREA':
﻿  ﻿  ﻿  q.push(form.elements[i].name + "=" + encodeURIComponent(form.elements[i].value));
﻿  ﻿  ﻿  break;
﻿  ﻿  case 'SELECT':
﻿  ﻿  ﻿  switch (form.elements[i].type) {
﻿  ﻿  ﻿  case 'select-one':
﻿  ﻿  ﻿  ﻿  q.push(form.elements[i].name + "=" + encodeURIComponent(form.elements[i].value));
﻿  ﻿  ﻿  ﻿  break;
﻿  ﻿  ﻿  case 'select-multiple':
﻿  ﻿  ﻿  ﻿  for (j = form.elements[i].options.length - 1; j >= 0; j = j - 1) {
﻿  ﻿  ﻿  ﻿  ﻿  if (form.elements[i].options[j].selected) {
﻿  ﻿  ﻿  ﻿  ﻿  ﻿  q.push(form.elements[i].name + "=" + encodeURIComponent(form.elements[i].options[j].value));
﻿  ﻿  ﻿  ﻿  ﻿  }
﻿  ﻿  ﻿  ﻿  }
﻿  ﻿  ﻿  ﻿  break;
﻿  ﻿  ﻿  }
﻿  ﻿  ﻿  break;
﻿  ﻿  case 'BUTTON':
﻿  ﻿  ﻿  switch (form.elements[i].type) {
﻿  ﻿  ﻿  case 'reset':
﻿  ﻿  ﻿  case 'submit':
﻿  ﻿  ﻿  case 'button':
﻿  ﻿  ﻿  ﻿  q.push(form.elements[i].name + "=" + encodeURIComponent(form.elements[i].value));
﻿  ﻿  ﻿  ﻿  break;
﻿  ﻿  ﻿  }
﻿  ﻿  ﻿  break;
﻿  ﻿  }
﻿  }
﻿  return q.join("&");
}
},{}],45:[function(require,module,exports){
var CSRFToken, Click, ComponentUrl, EVENTS, Link, ProgressBar, browserCompatibleDocumentParser, browserIsntBuggy, browserSupportsCustomEvents, browserSupportsPushState, browserSupportsTurbolinks, bypassOnLoadPopstate, cacheCurrentPage, cacheSize, changePage, clone, constrainPageCacheTo, createDocument, crossOriginRedirect, currentState, enableProgressBar, enableTransitionCache, executeScriptTags, extractTitleAndBody, fetch, fetchHistory, fetchReplacement, historyStateIsDefined, initializeTurbolinks, installDocumentReadyPageEventTriggers, installHistoryChangeHandler, installJqueryAjaxSuccessPageUpdateTrigger, loadedAssets, manuallyTriggerHashChangeForFirefox, pageCache, pageChangePrevented, pagesCached, popCookie, processResponse, progressBar, recallScrollPosition, ref, referer, reflectNewUrl, reflectRedirectedUrl, rememberCurrentState, rememberCurrentUrl, rememberReferer, removeNoscriptTags, requestMethodIsSafe, resetScrollPosition, setAutofocusElement, transitionCacheEnabled, transitionCacheFor, triggerEvent, visit, xhr,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

pageCache = {};

cacheSize = 10;

transitionCacheEnabled = false;

progressBar = null;

currentState = null;

loadedAssets = null;

referer = null;

createDocument = null;

xhr = null;

EVENTS = {
  BEFORE_CHANGE: 'page:before-change',
  FETCH: 'page:fetch',
  RECEIVE: 'page:receive',
  CHANGE: 'page:change',
  UPDATE: 'page:update',
  LOAD: 'page:load',
  RESTORE: 'page:restore',
  BEFORE_UNLOAD: 'page:before-unload',
  EXPIRE: 'page:expire'
};

fetch = function(url) {
  var cachedPage;
  url = new ComponentUrl(url);
  rememberReferer();
  cacheCurrentPage();
  if (progressBar != null) {
    progressBar.start();
  }
  if (transitionCacheEnabled && (cachedPage = transitionCacheFor(url.absolute))) {
    fetchHistory(cachedPage);
    return fetchReplacement(url, null, false);
  } else {
    return fetchReplacement(url, resetScrollPosition);
  }
};

transitionCacheFor = function(url) {
  var cachedPage;
  cachedPage = pageCache[url];
  if (cachedPage && !cachedPage.transitionCacheDisabled) {
    return cachedPage;
  }
};

enableTransitionCache = function(enable) {
  if (enable == null) {
    enable = true;
  }
  return transitionCacheEnabled = enable;
};

enableProgressBar = function(enable) {
  if (enable == null) {
    enable = true;
  }
  if (enable) {
    return progressBar != null ? progressBar : progressBar = new ProgressBar('html');
  } else {
    if (progressBar != null) {
      progressBar.uninstall();
    }
    return progressBar = null;
  }
};

fetchReplacement = function(url, onLoadFunction, showProgressBar) {
  if (showProgressBar == null) {
    showProgressBar = true;
  }
  triggerEvent(EVENTS.FETCH, {
    url: url.absolute
  });
  if (xhr != null) {
    xhr.abort();
  }
  xhr = new XMLHttpRequest;
  xhr.open('GET', url.withoutHashForIE10compatibility(), true);
  xhr.setRequestHeader('Accept', 'text/html, application/xhtml+xml, application/xml');
  xhr.setRequestHeader('X-XHR-Referer', referer);
  xhr.onload = function() {
    var doc;
    triggerEvent(EVENTS.RECEIVE, {
      url: url.absolute
    });
    if (doc = processResponse()) {
      reflectNewUrl(url);
      reflectRedirectedUrl();
      changePage.apply(null, extractTitleAndBody(doc));
      manuallyTriggerHashChangeForFirefox();
      if (typeof onLoadFunction === "function") {
        onLoadFunction();
      }
      return triggerEvent(EVENTS.LOAD);
    } else {
      return document.location.href = crossOriginRedirect() || url.absolute;
    }
  };
  if (progressBar && showProgressBar) {
    xhr.onprogress = (function(_this) {
      return function(event) {
        var percent;
        percent = event.lengthComputable ? event.loaded / event.total * 100 : progressBar.value + (100 - progressBar.value) / 10;
        return progressBar.advanceTo(percent);
      };
    })(this);
  }
  xhr.onloadend = function() {
    return xhr = null;
  };
  xhr.onerror = function() {
    return document.location.href = url.absolute;
  };
  return xhr.send();
};

fetchHistory = function(cachedPage) {
  if (xhr != null) {
    xhr.abort();
  }
  changePage(cachedPage.title, cachedPage.body);
  recallScrollPosition(cachedPage);
  return triggerEvent(EVENTS.RESTORE);
};

cacheCurrentPage = function() {
  var currentStateUrl;
  currentStateUrl = new ComponentUrl(currentState.url);
  pageCache[currentStateUrl.absolute] = {
    url: currentStateUrl.relative,
    body: document.body,
    title: document.title,
    positionY: window.pageYOffset,
    positionX: window.pageXOffset,
    cachedAt: new Date().getTime(),
    transitionCacheDisabled: document.querySelector('[data-no-transition-cache]') != null
  };
  return constrainPageCacheTo(cacheSize);
};

pagesCached = function(size) {
  if (size == null) {
    size = cacheSize;
  }
  if (/^[\d]+$/.test(size)) {
    return cacheSize = parseInt(size);
  }
};

constrainPageCacheTo = function(limit) {
  var cacheTimesRecentFirst, i, key, len, pageCacheKeys, results;
  pageCacheKeys = Object.keys(pageCache);
  cacheTimesRecentFirst = pageCacheKeys.map(function(url) {
    return pageCache[url].cachedAt;
  }).sort(function(a, b) {
    return b - a;
  });
  results = [];
  for (i = 0, len = pageCacheKeys.length; i < len; i++) {
    key = pageCacheKeys[i];
    if (!(pageCache[key].cachedAt <= cacheTimesRecentFirst[limit])) {
      continue;
    }
    triggerEvent(EVENTS.EXPIRE, pageCache[key]);
    results.push(delete pageCache[key]);
  }
  return results;
};

changePage = function(title, body, csrfToken, runScripts) {
  triggerEvent(EVENTS.BEFORE_UNLOAD);
  document.title = title;
  document.documentElement.replaceChild(body, document.body);
  if (csrfToken != null) {
    CSRFToken.update(csrfToken);
  }
  setAutofocusElement();
  if (runScripts) {
    executeScriptTags();
  }
  currentState = window.history.state;
  if (progressBar != null) {
    progressBar.done();
  }
  triggerEvent(EVENTS.CHANGE);
  return triggerEvent(EVENTS.UPDATE);
};

executeScriptTags = function() {
  var attr, copy, i, j, len, len1, nextSibling, parentNode, ref, ref1, script, scripts;
  scripts = Array.prototype.slice.call(document.body.querySelectorAll('script:not([data-turbolinks-eval="false"])'));
  for (i = 0, len = scripts.length; i < len; i++) {
    script = scripts[i];
    if (!((ref = script.type) === '' || ref === 'text/javascript')) {
      continue;
    }
    copy = document.createElement('script');
    ref1 = script.attributes;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      attr = ref1[j];
      copy.setAttribute(attr.name, attr.value);
    }
    if (!script.hasAttribute('async')) {
      copy.async = false;
    }
    copy.appendChild(document.createTextNode(script.innerHTML));
    parentNode = script.parentNode, nextSibling = script.nextSibling;
    parentNode.removeChild(script);
    parentNode.insertBefore(copy, nextSibling);
  }
};

removeNoscriptTags = function(node) {
  node.innerHTML = node.innerHTML.replace(/<noscript[\S\s]*?<\/noscript>/ig, '');
  return node;
};

setAutofocusElement = function() {
  var autofocusElement, list;
  autofocusElement = (list = document.querySelectorAll('input[autofocus], textarea[autofocus]'))[list.length - 1];
  if (autofocusElement && document.activeElement !== autofocusElement) {
    return autofocusElement.focus();
  }
};

reflectNewUrl = function(url) {
  if ((url = new ComponentUrl(url)).absolute !== referer) {
    return window.history.pushState({
      turbolinks: true,
      url: url.absolute
    }, '', url.absolute);
  }
};

reflectRedirectedUrl = function() {
  var location, preservedHash;
  if (location = xhr.getResponseHeader('X-XHR-Redirected-To')) {
    location = new ComponentUrl(location);
    preservedHash = location.hasNoHash() ? document.location.hash : '';
    return window.history.replaceState(currentState, '', location.href + preservedHash);
  }
};

crossOriginRedirect = function() {
  var redirect;
  if (((redirect = xhr.getResponseHeader('Location')) != null) && (new ComponentUrl(redirect)).crossOrigin()) {
    return redirect;
  }
};

rememberReferer = function() {
  return referer = document.location.href;
};

rememberCurrentUrl = function() {
  return window.history.replaceState({
    turbolinks: true,
    url: document.location.href
  }, '', document.location.href);
};

rememberCurrentState = function() {
  return currentState = window.history.state;
};

manuallyTriggerHashChangeForFirefox = function() {
  var url;
  if (navigator.userAgent.match(/Firefox/) && !(url = new ComponentUrl).hasNoHash()) {
    window.history.replaceState(currentState, '', url.withoutHash());
    return document.location.hash = url.hash;
  }
};

recallScrollPosition = function(page) {
  return window.scrollTo(page.positionX, page.positionY);
};

resetScrollPosition = function() {
  if (document.location.hash) {
    return document.location.href = document.location.href;
  } else {
    return window.scrollTo(0, 0);
  }
};

clone = function(original) {
  var copy, key, value;
  if ((original == null) || typeof original !== 'object') {
    return original;
  }
  copy = new original.constructor();
  for (key in original) {
    value = original[key];
    copy[key] = clone(value);
  }
  return copy;
};

popCookie = function(name) {
  var ref, value;
  value = ((ref = document.cookie.match(new RegExp(name + "=(\\w+)"))) != null ? ref[1].toUpperCase() : void 0) || '';
  document.cookie = name + '=; expires=Thu, 01-Jan-70 00:00:01 GMT; path=/';
  return value;
};

triggerEvent = function(name, data) {
  var event;
  if (typeof Prototype !== 'undefined') {
    Event.fire(document, name, data, true);
  }
  event = document.createEvent('Events');
  if (data) {
    event.data = data;
  }
  event.initEvent(name, true, true);
  return document.dispatchEvent(event);
};

pageChangePrevented = function(url) {
  return !triggerEvent(EVENTS.BEFORE_CHANGE, {
    url: url
  });
};

processResponse = function() {
  var assetsChanged, clientOrServerError, doc, extractTrackAssets, intersection, validContent;
  clientOrServerError = function() {
    var ref;
    return (400 <= (ref = xhr.status) && ref < 600);
  };
  validContent = function() {
    var contentType;
    return ((contentType = xhr.getResponseHeader('Content-Type')) != null) && contentType.match(/^(?:text\/html|application\/xhtml\+xml|application\/xml)(?:;|$)/);
  };
  extractTrackAssets = function(doc) {
    var i, len, node, ref, results;
    ref = doc.querySelector('head').childNodes;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      if ((typeof node.getAttribute === "function" ? node.getAttribute('data-turbolinks-track') : void 0) != null) {
        results.push(node.getAttribute('src') || node.getAttribute('href'));
      }
    }
    return results;
  };
  assetsChanged = function(doc) {
    var fetchedAssets;
    loadedAssets || (loadedAssets = extractTrackAssets(document));
    fetchedAssets = extractTrackAssets(doc);
    return fetchedAssets.length !== loadedAssets.length || intersection(fetchedAssets, loadedAssets).length !== loadedAssets.length;
  };
  intersection = function(a, b) {
    var i, len, ref, results, value;
    if (a.length > b.length) {
      ref = [b, a], a = ref[0], b = ref[1];
    }
    results = [];
    for (i = 0, len = a.length; i < len; i++) {
      value = a[i];
      if (indexOf.call(b, value) >= 0) {
        results.push(value);
      }
    }
    return results;
  };
  if (!clientOrServerError() && validContent()) {
    doc = createDocument(xhr.responseText);
    if (doc && !assetsChanged(doc)) {
      return doc;
    }
  }
};

extractTitleAndBody = function(doc) {
  var title;
  title = doc.querySelector('title');
  return [title != null ? title.textContent : void 0, removeNoscriptTags(doc.querySelector('body')), CSRFToken.get(doc).token, 'runScripts'];
};

CSRFToken = {
  get: function(doc) {
    var tag;
    if (doc == null) {
      doc = document;
    }
    return {
      node: tag = doc.querySelector('meta[name="csrf-token"]'),
      token: tag != null ? typeof tag.getAttribute === "function" ? tag.getAttribute('content') : void 0 : void 0
    };
  },
  update: function(latest) {
    var current;
    current = this.get();
    if ((current.token != null) && (latest != null) && current.token !== latest) {
      return current.node.setAttribute('content', latest);
    }
  }
};

browserCompatibleDocumentParser = function() {
  var buildTestsUsing, createDocumentUsingDOM, createDocumentUsingFragment, createDocumentUsingParser, createDocumentUsingWrite, docTest, docTests, e, i, len;
  createDocumentUsingParser = function(html) {
    return (new DOMParser).parseFromString(html, 'text/html');
  };
  createDocumentUsingDOM = function(html) {
    var doc;
    doc = document.implementation.createHTMLDocument('');
    doc.documentElement.innerHTML = html;
    return doc;
  };
  createDocumentUsingWrite = function(html) {
    var doc;
    doc = document.implementation.createHTMLDocument('');
    doc.open('replace');
    doc.write(html);
    doc.close();
    return doc;
  };
  createDocumentUsingFragment = function(html) {
    var body, doc, head, htmlWrapper, ref, ref1;
    head = ((ref = html.match(/<head[^>]*>([\s\S.]*)<\/head>/i)) != null ? ref[0] : void 0) || '<head></head>';
    body = ((ref1 = html.match(/<body[^>]*>([\s\S.]*)<\/body>/i)) != null ? ref1[0] : void 0) || '<body></body>';
    htmlWrapper = document.createElement('html');
    htmlWrapper.innerHTML = head + body;
    doc = document.createDocumentFragment();
    doc.appendChild(htmlWrapper);
    return doc;
  };
  buildTestsUsing = function(createMethod) {
    var buildTest, formNestingTest, structureTest;
    buildTest = function(fallback, passes) {
      return {
        passes: passes(),
        fallback: fallback
      };
    };
    structureTest = buildTest(createDocumentUsingWrite, (function(_this) {
      return function() {
        var ref, ref1;
        return ((ref = createMethod('<html><body><p>test')) != null ? (ref1 = ref.body) != null ? ref1.childNodes.length : void 0 : void 0) === 1;
      };
    })(this));
    formNestingTest = buildTest(createDocumentUsingFragment, (function(_this) {
      return function() {
        var ref, ref1;
        return ((ref = createMethod('<html><body><form></form><div></div></body></html>')) != null ? (ref1 = ref.body) != null ? ref1.childNodes.length : void 0 : void 0) === 2;
      };
    })(this));
    return [structureTest, formNestingTest];
  };
  try {
    if (window.DOMParser) {
      docTests = buildTestsUsing(createDocumentUsingParser);
      return createDocumentUsingParser;
    }
  } catch (_error) {
    e = _error;
    docTests = buildTestsUsing(createDocumentUsingDOM);
    return createDocumentUsingDOM;
  } finally {
    for (i = 0, len = docTests.length; i < len; i++) {
      docTest = docTests[i];
      if (!docTest.passes) {
        return docTest.fallback;
      }
    }
  }
};

ComponentUrl = (function() {
  function ComponentUrl(original1) {
    this.original = original1 != null ? original1 : document.location.href;
    if (this.original.constructor === ComponentUrl) {
      return this.original;
    }
    this._parse();
  }

  ComponentUrl.prototype.withoutHash = function() {
    return this.href.replace(this.hash, '').replace('#', '');
  };

  ComponentUrl.prototype.withoutHashForIE10compatibility = function() {
    return this.withoutHash();
  };

  ComponentUrl.prototype.hasNoHash = function() {
    return this.hash.length === 0;
  };

  ComponentUrl.prototype.crossOrigin = function() {
    return this.origin !== (new ComponentUrl).origin;
  };

  ComponentUrl.prototype._parse = function() {
    var ref;
    (this.link != null ? this.link : this.link = document.createElement('a')).href = this.original;
    ref = this.link, this.href = ref.href, this.protocol = ref.protocol, this.host = ref.host, this.hostname = ref.hostname, this.port = ref.port, this.pathname = ref.pathname, this.search = ref.search, this.hash = ref.hash;
    this.origin = [this.protocol, '//', this.hostname].join('');
    if (this.port.length !== 0) {
      this.origin += ":" + this.port;
    }
    this.relative = [this.pathname, this.search, this.hash].join('');
    return this.absolute = this.href;
  };

  return ComponentUrl;

})();

Link = (function(superClass) {
  extend(Link, superClass);

  Link.HTML_EXTENSIONS = ['html'];

  Link.allowExtensions = function() {
    var extension, extensions, i, len;
    extensions = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (i = 0, len = extensions.length; i < len; i++) {
      extension = extensions[i];
      Link.HTML_EXTENSIONS.push(extension);
    }
    return Link.HTML_EXTENSIONS;
  };

  function Link(link1) {
    this.link = link1;
    if (this.link.constructor === Link) {
      return this.link;
    }
    this.original = this.link.href;
    this.originalElement = this.link;
    this.link = this.link.cloneNode(false);
    Link.__super__.constructor.apply(this, arguments);
  }

  Link.prototype.shouldIgnore = function() {
    return this.crossOrigin() || this._anchored() || this._nonHtml() || this._optOut() || this._target();
  };

  Link.prototype._anchored = function() {
    return (this.hash.length > 0 || this.href.charAt(this.href.length - 1) === '#') && (this.withoutHash() === (new ComponentUrl).withoutHash());
  };

  Link.prototype._nonHtml = function() {
    return this.pathname.match(/\.[a-z]+$/g) && !this.pathname.match(new RegExp("\\.(?:" + (Link.HTML_EXTENSIONS.join('|')) + ")?$", 'g'));
  };

  Link.prototype._optOut = function() {
    var ignore, link;
    link = this.originalElement;
    while (!(ignore || link === document)) {
      ignore = link.getAttribute('data-no-turbolink') != null;
      link = link.parentNode;
    }
    return ignore;
  };

  Link.prototype._target = function() {
    return this.link.target.length !== 0;
  };

  return Link;

})(ComponentUrl);

Click = (function() {
  Click.installHandlerLast = function(event) {
    if (!event.defaultPrevented) {
      document.removeEventListener('click', Click.handle, false);
      return document.addEventListener('click', Click.handle, false);
    }
  };

  Click.handle = function(event) {
    return new Click(event);
  };

  function Click(event1) {
    this.event = event1;
    if (this.event.defaultPrevented) {
      return;
    }
    this._extractLink();
    if (this._validForTurbolinks()) {
      if (!pageChangePrevented(this.link.absolute)) {
        visit(this.link.href);
      }
      this.event.preventDefault();
    }
  }

  Click.prototype._extractLink = function() {
    var link;
    link = this.event.target;
    while (!(!link.parentNode || link.nodeName === 'A')) {
      link = link.parentNode;
    }
    if (link.nodeName === 'A' && link.href.length !== 0) {
      return this.link = new Link(link);
    }
  };

  Click.prototype._validForTurbolinks = function() {
    return (this.link != null) && !(this.link.shouldIgnore() || this._nonStandardClick());
  };

  Click.prototype._nonStandardClick = function() {
    return this.event.which > 1 || this.event.metaKey || this.event.ctrlKey || this.event.shiftKey || this.event.altKey;
  };

  return Click;

})();

ProgressBar = (function() {
  var className;

  className = 'turbolinks-progress-bar';

  function ProgressBar(elementSelector) {
    this.elementSelector = elementSelector;
    this._trickle = bind(this._trickle, this);
    this.value = 0;
    this.opacity = 1;
    this.content = '';
    this.speed = 300;
    this.install();
  }

  ProgressBar.prototype.install = function() {
    this.element = document.querySelector(this.elementSelector);
    this.element.classList.add(className);
    this.styleElement = document.createElement('style');
    document.head.appendChild(this.styleElement);
    return this._updateStyle();
  };

  ProgressBar.prototype.uninstall = function() {
    this.element.classList.remove(className);
    return document.head.removeChild(this.styleElement);
  };

  ProgressBar.prototype.start = function() {
    return this.advanceTo(5);
  };

  ProgressBar.prototype.advanceTo = function(value) {
    var ref;
    if ((value > (ref = this.value) && ref <= 100)) {
      this.value = value;
      this._updateStyle();
      if (this.value === 100) {
        return this._stopTrickle();
      } else if (this.value > 0) {
        return this._startTrickle();
      }
    }
  };

  ProgressBar.prototype.done = function() {
    if (this.value > 0) {
      this.advanceTo(100);
      return this._reset();
    }
  };

  ProgressBar.prototype._reset = function() {
    setTimeout((function(_this) {
      return function() {
        _this.opacity = 0;
        return _this._updateStyle();
      };
    })(this), this.speed / 2);
    return setTimeout((function(_this) {
      return function() {
        _this.value = 0;
        _this.opacity = 1;
        return _this._withSpeed(0, function() {
          return _this._updateStyle(true);
        });
      };
    })(this), this.speed);
  };

  ProgressBar.prototype._startTrickle = function() {
    if (this.trickling) {
      return;
    }
    this.trickling = true;
    return setTimeout(this._trickle, this.speed);
  };

  ProgressBar.prototype._stopTrickle = function() {
    return delete this.trickling;
  };

  ProgressBar.prototype._trickle = function() {
    if (!this.trickling) {
      return;
    }
    this.advanceTo(this.value + Math.random() / 2);
    return setTimeout(this._trickle, this.speed);
  };

  ProgressBar.prototype._withSpeed = function(speed, fn) {
    var originalSpeed, result;
    originalSpeed = this.speed;
    this.speed = speed;
    result = fn();
    this.speed = originalSpeed;
    return result;
  };

  ProgressBar.prototype._updateStyle = function(forceRepaint) {
    if (forceRepaint == null) {
      forceRepaint = false;
    }
    if (forceRepaint) {
      this._changeContentToForceRepaint();
    }
    return this.styleElement.textContent = this._createCSSRule();
  };

  ProgressBar.prototype._changeContentToForceRepaint = function() {
    return this.content = this.content === '' ? ' ' : '';
  };

  ProgressBar.prototype._createCSSRule = function() {
    return this.elementSelector + "." + className + "::before {\n  content: '" + this.content + "';\n  position: fixed;\n  top: 0;\n  left: 0;\n  background-color: #0076ff;\n  height: 3px;\n  opacity: " + this.opacity + ";\n  width: " + this.value + "%;\n  transition: width " + this.speed + "ms ease-out, opacity " + (this.speed / 2) + "ms ease-in;\n  transform: translate3d(0,0,0);\n}";
  };

  return ProgressBar;

})();

bypassOnLoadPopstate = function(fn) {
  return setTimeout(fn, 500);
};

installDocumentReadyPageEventTriggers = function() {
  return document.addEventListener('DOMContentLoaded', (function() {
    triggerEvent(EVENTS.CHANGE);
    return triggerEvent(EVENTS.UPDATE);
  }), true);
};

installJqueryAjaxSuccessPageUpdateTrigger = function() {
  if (typeof jQuery !== 'undefined') {
    return jQuery(document).on('ajaxSuccess', function(event, xhr, settings) {
      if (!jQuery.trim(xhr.responseText)) {
        return;
      }
      return triggerEvent(EVENTS.UPDATE);
    });
  }
};

installHistoryChangeHandler = function(event) {
  var cachedPage, ref;
  if ((ref = event.state) != null ? ref.turbolinks : void 0) {
    if (cachedPage = pageCache[(new ComponentUrl(event.state.url)).absolute]) {
      cacheCurrentPage();
      return fetchHistory(cachedPage);
    } else {
      return visit(event.target.location.href);
    }
  }
};

initializeTurbolinks = function() {
  rememberCurrentUrl();
  rememberCurrentState();
  createDocument = browserCompatibleDocumentParser();
  document.addEventListener('click', Click.installHandlerLast, true);
  window.addEventListener('hashchange', function(event) {
    rememberCurrentUrl();
    return rememberCurrentState();
  }, false);
  return bypassOnLoadPopstate(function() {
    return window.addEventListener('popstate', installHistoryChangeHandler, false);
  });
};

historyStateIsDefined = window.history.state !== void 0 || navigator.userAgent.match(/Firefox\/2[6|7]/);

browserSupportsPushState = window.history && window.history.pushState && window.history.replaceState && historyStateIsDefined;

browserIsntBuggy = !navigator.userAgent.match(/CriOS\//);

requestMethodIsSafe = (ref = popCookie('request_method')) === 'GET' || ref === '';

browserSupportsTurbolinks = browserSupportsPushState && browserIsntBuggy && requestMethodIsSafe;

browserSupportsCustomEvents = document.addEventListener && document.createEvent;

if (browserSupportsCustomEvents) {
  installDocumentReadyPageEventTriggers();
  installJqueryAjaxSuccessPageUpdateTrigger();
}

if (browserSupportsTurbolinks) {
  visit = fetch;
  initializeTurbolinks();
} else {
  visit = function(url) {
    return document.location.href = url;
  };
}

this.Turbolinks = {
  visit: visit,
  pagesCached: pagesCached,
  enableTransitionCache: enableTransitionCache,
  enableProgressBar: enableProgressBar,
  allowLinkExtensions: Link.allowExtensions,
  supported: browserSupportsTurbolinks,
  EVENTS: clone(EVENTS)
};
},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJfc3RyZWFtXzAuanMiLCIvYXBwL2FwcC9hc3NldHMvamF2YXNjcmlwdHMvbGliL2Jzb24uanMuY29mZmVlIiwibGliL2RhdGUuZm9ybWF0LmpzIiwibGliL3R1cmJvZm9ybXMuanMiLCJtb25nb2RiL2NvbGxlY3Rpb25zLmpzIiwibW9uZ29kYi9kb2N1bWVudHMuanMiLCJtb25nb2RiL2luZGV4LmpzIiwibW9uZ29kYi9pbmRleGVzLmpzIiwibW9uZ29kYi9tb25pdG9yaW5nL2luZGV4LmpzIiwibW9uZ29kYi9tb25pdG9yaW5nL2xvZ3MuanMiLCJtb25nb2RiL21vbml0b3Jpbmcvb3BlcmF0aW9ucy5qcyIsIm1vbmdvZGIvbW9uaXRvcmluZy9zZXJ2ZXJfc3RhdHVzLmpzIiwibW9uZ29kYi91c2Vycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb3NlLXJvdXRlci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb3NlLXJvdXRlci9ub2RlX21vZHVsZXMvcm91dGVzL2Rpc3Qvcm91dGVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvc2Utc2hlbGwvY29tcG9zZS1zaGVsbC1idXR0b24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9zZS1zaGVsbC9jb21wb3NlLXNoZWxsLXBhcmFtLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvc2Utc2hlbGwvY29tcG9zZS1zaGVsbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb3NlLXNoZWxsL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvc2Utc2hlbGwvbGliL2FuaW0tZXZlbnRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvc2Utc2hlbGwvbGliL2Jzb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9zZS1zaGVsbC9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzLnJ1bnRpbWUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9zZS1zaGVsbC9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2Jhc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9zZS1zaGVsbC9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2V4Y2VwdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb3NlLXNoZWxsL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb3NlLXNoZWxsL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9zZS1zaGVsbC9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL3V0aWxzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvc2Utc2hlbGwvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb3NlLXNoZWxsL25vZGVfbW9kdWxlcy9oYnNmeS9ydW50aW1lLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvc2Utc2hlbGwvdGVtcGxhdGVzL2J1dHRvbi5oYnMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29tcG9zZS1zaGVsbC90ZW1wbGF0ZXMvcGFyYW0uaGJzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbXBvc2Utc2hlbGwvdGVtcGxhdGVzL3NoZWxsLmhicyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb21wb3NlLXNoZWxsL3ZlbmRvci94LXRhZy1jb3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25wcm9ncmVzcy9ucHJvZ3Jlc3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcXMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi9wYXJzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9ub2RlX21vZHVsZXMvcmVkdWNlLWNvbXBvbmVudC9pbmRleC5qcyIsIi4uLy4uLy4uL3ZlbmRvci9hc3NldHMvamF2YXNjcmlwdHMvc2VyaWFsaXplLmpzIiwiLi4vLi4vLi4vdmVuZG9yL2Fzc2V0cy9qYXZhc2NyaXB0cy90dXJib2xpbmtzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0EsSUFBQTs7QUFBQSxDQUFBLEdBQUksUUFBUSxDQUFDOztBQUNiLFVBQUEsR0FBYSxPQUFBLENBQVEsZUFBUjs7QUFFYixNQUFNLENBQUMsT0FBUCxHQUNFO0VBQUEsY0FBQSxFQUFnQixTQUFDLEtBQUQsRUFBUSxXQUFSO0FBQ2QsUUFBQTtJQUFBLElBQUcsV0FBSDtNQUNFLEdBQUEsR0FBTTtNQUNOLENBQUMsQ0FBQyxLQUFGLENBQVMsS0FBQSxHQUFRLFdBQWpCLEVBQStCLENBQUEsU0FBQSxLQUFBO2VBQUEsU0FBQTtpQkFDN0IsR0FBQSxJQUFPO1FBRHNCO01BQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUEvQjthQUVBLElBSkY7S0FBQSxNQUFBO2FBTUUsSUFORjs7RUFEYyxDQUFoQjtFQVNBLFlBQUEsRUFBYyxTQUFDLElBQUQsRUFBTyxPQUFQO0FBQ1osUUFBQTs7TUFEbUIsVUFBUTs7SUFDM0IsS0FBQSxHQUFRLE9BQU8sQ0FBQyxLQUFSLElBQWlCO0lBQ3pCLElBQUcsMkJBQUg7TUFDRSxXQUFBLEdBQWMsT0FBTyxDQUFDLFlBRHhCO0tBQUEsTUFBQTtNQUdFLFdBQUEsR0FBYyxFQUhoQjs7SUFLQSxNQUFBLEdBQVM7SUFDVCxXQUFBLEdBQWM7SUFFZCxJQUEwRCxNQUFBLEtBQVUsRUFBcEU7TUFBQSxNQUFBLElBQVUsRUFBQSxHQUFFLENBQUMsSUFBQyxDQUFBLGNBQUQsQ0FBZ0IsS0FBaEIsRUFBdUIsV0FBdkIsQ0FBRCxFQUFaOztJQUVBLElBQUcsT0FBTyxDQUFDLFNBQVg7QUFDRSxhQUFPLElBQUMsQ0FBQSxVQUFELENBQVksSUFBWixFQUFrQixNQUFsQixFQUEwQixLQUExQixFQUFpQyxXQUFqQyxFQUE4QyxPQUE5QyxFQURUO0tBQUEsTUFFSyxJQUFHLElBQUEsWUFBZ0IsS0FBbkI7TUFDSCxNQUFBLElBQVUsSUFEUDtLQUFBLE1BRUEsSUFBRyxJQUFBLFlBQWdCLE1BQW5CO01BQ0gsTUFBQSxJQUFVLElBRFA7O0FBR0wsU0FBQSxTQUFBOztNQUNFLFdBQUEsR0FBYztNQUNkLE1BQUEsSUFBVSxJQUFDLENBQUEsY0FBRCxDQUFnQixLQUFBLEdBQU0sQ0FBdEIsRUFBeUIsV0FBekI7TUFFVixJQUFBLENBQUEsQ0FBTyxJQUFBLFlBQWdCLEtBQXZCLENBQUE7UUFDRSxJQUFHLE9BQU8sQ0FBQyxJQUFYO1VBQ0UsSUFBRyxDQUFDLENBQUMsS0FBRixDQUFRLFlBQVIsQ0FBSDtZQUNFLENBQUEsR0FBSSxRQUFRLENBQUMsYUFBVCxDQUF1QixLQUF2QjtZQUNKLENBQUMsQ0FBQyxXQUFGLEdBQWdCO1lBQ2hCLE1BQUEsSUFBVSxzQkFBQSxHQUF1QixDQUFDLENBQUMsU0FBekIsR0FBbUMsY0FIL0M7V0FBQSxNQUFBO1lBS0UsTUFBQSxJQUFVLG9CQUFBLEdBQXFCLENBQXJCLEdBQXVCLFlBTG5DO1dBREY7U0FBQSxNQUFBO1VBUUUsSUFBRyxDQUFDLENBQUMsS0FBRixDQUFRLGdCQUFSLENBQUg7WUFDRSxNQUFBLElBQVUsSUFBQSxHQUFJLENBQUMsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxJQUFWLEVBQWdCLEtBQWhCLENBQUQsQ0FBSixHQUE0QixPQUR4QztXQUFBLE1BQUE7WUFHRSxNQUFBLElBQWEsQ0FBRCxHQUFHLEtBSGpCO1dBUkY7U0FERjs7TUFjQSxNQUFBLEdBQVMsSUFBQyxDQUFBLFVBQUQsQ0FBWSxDQUFaLEVBQWUsTUFBZixFQUF1QixLQUF2QixFQUE4QixXQUE5QixFQUEyQyxPQUEzQztBQWxCWDtJQXFCQSxJQUFnQyxNQUFNLENBQUMsS0FBUCxDQUFhLENBQUMsQ0FBZCxDQUFBLEtBQW9CLEdBQXBEO01BQUEsTUFBQSxHQUFTLE1BQU0sQ0FBQyxLQUFQLENBQWEsQ0FBYixFQUFnQixDQUFDLENBQWpCLEVBQVQ7O0lBRUEsSUFBQSxDQUFxRCxXQUFyRDtNQUFBLE1BQUEsSUFBVSxJQUFDLENBQUEsY0FBRCxDQUFnQixLQUFoQixFQUF1QixXQUF2QixFQUFWOztJQUVBLElBQUcsSUFBQSxZQUFnQixLQUFuQjthQUNFLE1BQUEsSUFBVSxJQURaO0tBQUEsTUFFSyxJQUFHLElBQUEsWUFBZ0IsTUFBbkI7YUFDSCxNQUFBLElBQVUsSUFEUDs7RUE5Q08sQ0FUZDtFQTBEQSxVQUFBLEVBQVksU0FBQyxDQUFELEVBQUksTUFBSixFQUFZLEtBQVosRUFBbUIsV0FBbkIsRUFBZ0MsT0FBaEM7QUFDVixRQUFBO0lBQUEsSUFBRyxDQUFDLENBQUMsTUFBRixDQUFTLENBQVQsQ0FBSDtNQUNFLElBQUcsT0FBTyxDQUFDLElBQVg7UUFDRSxNQUFBLElBQVUsbUNBRFo7T0FBQSxNQUFBO1FBR0UsTUFBQSxJQUFVLFFBSFo7T0FERjtLQUFBLE1BS0ssSUFBRyxPQUFPLENBQVAsS0FBYSxRQUFoQjtBQUNILGNBQU8sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFyQjtBQUFBLGFBRU8sVUFGUDtVQUdJLElBQUcsT0FBTyxDQUFDLElBQVg7WUFDRSxNQUFBLElBQVUsa0ZBQUEsR0FBa0YsQ0FBQyxDQUFDLENBQUMsUUFBRixDQUFBLENBQUQsQ0FBbEYsR0FBZ0cscUJBRDVHO1dBQUEsTUFBQTtZQUdFLE1BQUEsSUFBVSxhQUFBLEdBQWEsQ0FBQyxDQUFDLENBQUMsUUFBRixDQUFBLENBQUQsQ0FBYixHQUEyQixPQUh2Qzs7QUFERztBQUZQLGFBUU8sTUFSUDtVQVNJLEVBQUEsR0FBUyxJQUFBLElBQUEsQ0FBSyxDQUFDLENBQUMsUUFBRixDQUFBLENBQUw7VUFDVCxHQUFBLEdBQU0sVUFBQSxDQUFXLEVBQVgsRUFBZSxnQkFBZjtVQUNOLElBQUcsRUFBRSxDQUFDLGVBQUgsQ0FBQSxDQUFBLEdBQXVCLENBQTFCO1lBQ0UsR0FBQSxHQUFNLEdBQUcsQ0FBQyxPQUFKLENBQVksSUFBWixFQUFrQixHQUFBLEdBQUcsQ0FBQyxVQUFBLENBQVcsRUFBWCxFQUFlLEdBQWYsQ0FBRCxDQUFILEdBQXdCLEdBQTFDLEVBRFI7O1VBRUEsSUFBRyxPQUFPLENBQUMsSUFBWDtZQUVFLE1BQUEsSUFBVSwrREFBQSxHQUFnRSxHQUFoRSxHQUFvRSxjQUZoRjtXQUFBLE1BQUE7WUFJRSxNQUFBLElBQVUsWUFBQSxHQUFhLEdBQWIsR0FBaUIsT0FKN0I7O0FBTEc7QUFSUCxhQWtCTyxRQWxCUDtVQW1CSSxJQUFHLE9BQU8sQ0FBQyxJQUFYO1lBQ0UsTUFBQSxJQUFVLHVCQUFBLEdBQXVCLENBQUMsQ0FBQyxDQUFDLFFBQUYsQ0FBQSxDQUFELENBQXZCLEdBQXFDLFdBRGpEO1dBQUEsTUFBQTtZQUdFLE1BQUEsSUFBVSxHQUFBLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBRixDQUFBLENBQUQsQ0FBSCxHQUFpQixJQUg3Qjs7QUFERztBQWxCUDtVQXlCSSxJQUFHLENBQUUsQ0FBQSxNQUFBLENBQUw7WUFDRSxJQUFHLE9BQU8sQ0FBQyxJQUFYO2NBQ0UsTUFBQSxJQUFVLGtGQUFBLEdBQW1GLENBQUUsQ0FBQSxNQUFBLENBQXJGLEdBQTZGLHFCQUR6RzthQUFBLE1BQUE7Y0FHRSxNQUFBLElBQVUsYUFBQSxHQUFjLENBQUUsQ0FBQSxNQUFBLENBQWhCLEdBQXdCLE9BSHBDO2FBREY7V0FBQSxNQUtLLElBQUcsa0JBQUg7WUFDSCxFQUFBLEdBQVMsSUFBQSxJQUFBLENBQUssQ0FBRSxDQUFBLE9BQUEsQ0FBUDtZQUNULEdBQUEsR0FBTSxVQUFBLENBQVcsRUFBWCxFQUFlLGdCQUFmO1lBQ04sSUFBRyxFQUFFLENBQUMsZUFBSCxDQUFBLENBQUEsR0FBdUIsQ0FBMUI7Y0FDRSxHQUFBLEdBQU0sR0FBRyxDQUFDLE9BQUosQ0FBWSxJQUFaLEVBQWtCLEdBQUEsR0FBRyxDQUFDLFVBQUEsQ0FBVyxFQUFYLEVBQWUsR0FBZixDQUFELENBQUgsR0FBd0IsR0FBMUMsRUFEUjs7WUFFQSxJQUFHLE9BQU8sQ0FBQyxJQUFYO2NBRUUsTUFBQSxJQUFVLCtEQUFBLEdBQWdFLEdBQWhFLEdBQW9FLGNBRmhGO2FBQUEsTUFBQTtjQUlFLE1BQUEsSUFBVSxZQUFBLEdBQWEsR0FBYixHQUFpQixPQUo3QjthQUxHO1dBQUEsTUFVQSxJQUFHLENBQUUsQ0FBQSxPQUFBLENBQUw7WUFDSCxJQUFHLE9BQU8sQ0FBQyxJQUFYO2NBQ0UsTUFBQSxJQUFVLDZDQUFBLEdBQThDLENBQUUsQ0FBQSxPQUFBLENBQWhELEdBQXlELE9BRHJFO2FBQUEsTUFBQTtjQUdFLE1BQUEsSUFBVSxlQUFBLEdBQWdCLENBQUUsQ0FBQSxPQUFBLENBQWxCLEdBQTJCLE9BSHZDO2FBREc7V0FBQSxNQUtBLElBQUcsQ0FBRSxDQUFBLFFBQUEsQ0FBTDtZQUNILElBQUcsT0FBTyxDQUFDLElBQVg7Y0FDRSxNQUFBLElBQVUsdUJBQUEsR0FBd0IsQ0FBRSxDQUFBLFFBQUEsQ0FBMUIsR0FBb0MsR0FBcEMsR0FBdUMsQ0FBRSxDQUFBLFVBQUEsQ0FBekMsR0FBcUQsV0FEakU7YUFBQSxNQUFBO2NBR0UsTUFBQSxJQUFVLEdBQUEsR0FBSSxDQUFFLENBQUEsUUFBQSxDQUFOLEdBQWdCLEdBQWhCLEdBQW1CLENBQUUsQ0FBQSxVQUFBLENBQXJCLEdBQWlDLElBSDdDO2FBREc7V0FBQSxNQUtBLElBQUcsQ0FBRSxDQUFBLEdBQUEsQ0FBRixJQUFVLENBQVYsSUFBZSxDQUFFLENBQUEsR0FBQSxDQUFGLElBQVUsQ0FBNUI7WUFDSCxJQUFHLE9BQU8sQ0FBQyxJQUFYO2NBQ0UsTUFBQSxJQUFVLDBDQUFBLEdBQTJDLENBQUUsQ0FBQSxHQUFBLENBQTdDLEdBQWtELElBQWxELEdBQXNELENBQUUsQ0FBQSxHQUFBLENBQXhELEdBQTZELEtBRHpFO2FBQUEsTUFBQTtjQUdFLE1BQUEsSUFBVSxZQUFBLEdBQWEsQ0FBRSxDQUFBLEdBQUEsQ0FBZixHQUFvQixJQUFwQixHQUF3QixDQUFFLENBQUEsR0FBQSxDQUExQixHQUErQixLQUgzQzthQURHO1dBQUEsTUFLQSxJQUFHLENBQUUsQ0FBQSxNQUFBLENBQUw7WUFDSCxJQUFHLE9BQU8sQ0FBQyxJQUFYO2NBQ0UsTUFBQSxJQUFVLDZEQUFBLEdBQThELENBQUUsQ0FBQSxNQUFBLENBQWhFLEdBQXdFLGFBQXhFLEdBQW9GLENBQUMsSUFBQyxDQUFBLFlBQUQsQ0FBYyxDQUFFLENBQUEsS0FBQSxDQUFoQixFQUF3QjtnQkFBQyxLQUFBLEVBQU8sS0FBQSxHQUFNLENBQWQ7Z0JBQWlCLFNBQUEsRUFBVyxJQUE1QjtnQkFBa0MsSUFBQSxFQUFNLElBQXhDO2VBQXhCLENBQUQ7Y0FDOUYsSUFBNkQsQ0FBRSxDQUFBLEtBQUEsQ0FBL0Q7Z0JBQUEsTUFBQSxJQUFVLDJCQUFBLEdBQTRCLENBQUUsQ0FBQSxLQUFBLENBQTlCLEdBQXFDLFlBQS9DOztjQUNBLE1BQUEsSUFBVSxLQUhaO2FBQUEsTUFBQTtjQUtFLE1BQUEsSUFBVSxVQUFBLEdBQVcsQ0FBRSxDQUFBLE1BQUEsQ0FBYixHQUFxQixNQUFyQixHQUEwQixDQUFDLElBQUMsQ0FBQSxZQUFELENBQWMsQ0FBRSxDQUFBLEtBQUEsQ0FBaEIsRUFBd0I7Z0JBQUMsS0FBQSxFQUFPLEtBQUEsR0FBTSxDQUFkO2dCQUFpQixTQUFBLEVBQVcsSUFBNUI7Z0JBQWtDLElBQUEsRUFBTSxLQUF4QztlQUF4QixDQUFELENBQTFCLEdBQWtHLEtBTDlHO2FBREc7V0FBQSxNQU9BLElBQUcsQ0FBRSxDQUFBLFNBQUEsQ0FBTDtZQUNILElBQUcsT0FBTyxDQUFDLElBQVg7Y0FDRSxNQUFBLElBQVUsNkRBQUEsR0FBOEQsQ0FBRSxDQUFBLE9BQUEsQ0FBaEUsR0FBeUUsaUNBQXpFLEdBQTBHLENBQUUsQ0FBQSxTQUFBLENBQTVHLEdBQXVILGNBRG5JO2FBQUEsTUFBQTtjQUdFLE1BQUEsSUFBVSxVQUFBLEdBQVcsQ0FBRSxDQUFBLE9BQUEsQ0FBYixHQUFzQixNQUF0QixHQUE0QixDQUFFLENBQUEsU0FBQSxDQUE5QixHQUF5QyxPQUhyRDthQURHO1dBQUEsTUFBQTtZQU1ILE1BQUEsSUFBWSxDQUFDLElBQUMsQ0FBQSxZQUFELENBQWMsQ0FBZCxFQUFpQjtjQUFDLEtBQUEsRUFBTyxLQUFBLEdBQU0sQ0FBZDtjQUFpQixXQUFBLEVBQWEsV0FBOUI7Y0FBMkMsSUFBQSxFQUFNLE9BQU8sQ0FBQyxJQUF6RDthQUFqQixDQUFELENBQUEsR0FBaUYsSUFOMUY7O0FBOURULE9BREc7S0FBQSxNQUFBO01BdUVILEdBQUEsR0FBTSxJQUFJLENBQUMsU0FBTCxDQUFlLENBQWY7TUFDTixJQUFHLE9BQU8sQ0FBQyxJQUFYO1FBQ0UsR0FBQSxHQUFNLEdBQUcsQ0FBQyxPQUFKLENBQVksSUFBWixFQUFrQixNQUFsQjtRQUNOLFNBQUEsR0FBWTtRQUNaLElBQXVCLEdBQUEsS0FBTyxPQUFQLElBQWtCLEdBQUEsS0FBTyxNQUFoRDtVQUFBLFNBQUEsR0FBWSxRQUFaOztRQUNBLElBQXdCLE9BQU8sQ0FBUCxLQUFhLFFBQXJDO1VBQUEsU0FBQSxHQUFZLFNBQVo7O1FBQ0EsTUFBQSxJQUFVLGVBQUEsR0FBZ0IsU0FBaEIsR0FBMEIsSUFBMUIsR0FBOEIsR0FBOUIsR0FBa0MsV0FMOUM7T0FBQSxNQUFBO1FBT0UsTUFBQSxJQUFhLEdBQUQsR0FBSyxJQVBuQjtPQXhFRzs7SUFpRkwsSUFBRyxPQUFPLENBQUMsU0FBWDtNQUNFLElBQWdDLE1BQU0sQ0FBQyxLQUFQLENBQWEsQ0FBQyxDQUFkLENBQUEsS0FBb0IsR0FBcEQ7UUFBQSxNQUFBLEdBQVMsTUFBTSxDQUFDLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLENBQUMsQ0FBakIsRUFBVDtPQURGOztBQUdBLFdBQU87RUExRkcsQ0ExRFo7RUFzSkEsYUFBQSxFQUFlLFNBQUMsSUFBRDtBQUNiLFFBQUE7QUFBQSxTQUFBLFNBQUE7O01BQ0UsSUFBSSxDQUFBLFlBQWEsTUFBakI7UUFDRSxZQUFBLEdBQWUsQ0FBQyxDQUFDLFFBQUYsQ0FBQSxDQUFZLENBQUMsS0FBYixDQUFtQixvQkFBbkI7UUFDZixJQUFLLENBQUEsQ0FBQSxDQUFMLEdBQVU7VUFBQyxNQUFBLEVBQVEsWUFBYSxDQUFBLENBQUEsQ0FBdEI7VUFBMEIsUUFBQSxFQUFVLFlBQWEsQ0FBQSxDQUFBLENBQWpEO1VBRlo7T0FBQSxNQUdLLElBQUcsQ0FBQSxLQUFLLE1BQUwsSUFBZ0IsT0FBTyxDQUFQLEtBQVksV0FBL0I7UUFDSCxLQUFBLENBQU0sMERBQU4sRUFERztPQUFBLE1BRUEsSUFBRyxDQUFBLEtBQUssT0FBTCxJQUFpQixPQUFPLENBQVAsS0FBWSxXQUFoQztRQUNILElBQUssQ0FBQSxDQUFBLENBQUwsR0FBVSxDQUFLLElBQUEsSUFBQSxDQUFBLENBQUwsQ0FBWSxDQUFDLE9BQWIsQ0FBQSxFQURQO09BQUEsTUFFQSxJQUFHLE9BQU8sQ0FBUCxLQUFhLFFBQWhCO1FBQ0gsSUFBSyxDQUFBLENBQUEsQ0FBTCxHQUFVLElBQUMsQ0FBQSxhQUFELENBQWUsQ0FBZixFQURQOztBQVJQO1dBV0E7RUFaYSxDQXRKZjtFQW9LQSxRQUFBLEVBQVUsU0FBQyxHQUFEO0FBQ1IsUUFBQTtBQUFBO01BQ0UsSUFBQSxHQUFPO0FBQ1AsV0FBQSxTQUFBOztRQUNFLElBQUssQ0FBQSxDQUFBLENBQUwsR0FBVTtBQURaO01BR0EsSUFBSSxDQUFDLFFBQUwsR0FBZ0IsU0FBQyxFQUFEO2VBQU87VUFBQyxJQUFBLEVBQU0sRUFBUDs7TUFBUDtNQUNoQixJQUFJLENBQUMsSUFBTCxHQUFZLFNBQUMsSUFBRDtlQUFTO1VBQUMsS0FBQSxFQUFPLElBQVI7O01BQVQ7TUFDWixJQUFJLENBQUMsT0FBTCxHQUFlLFNBQUMsSUFBRDtlQUFTO1VBQUMsS0FBQSxFQUFPLENBQUssSUFBQSxJQUFBLENBQUssSUFBTCxDQUFMLENBQWdCLENBQUMsT0FBakIsQ0FBQSxDQUFSOztNQUFUO01BQ2YsSUFBSSxDQUFDLFNBQUwsR0FBaUIsU0FBQyxDQUFELEVBQUksQ0FBSjtlQUFTO1VBQUMsR0FBQSxFQUFLLENBQU47VUFBUyxHQUFBLEVBQUssQ0FBZDs7TUFBVDtNQUNqQixJQUFJLENBQUMsS0FBTCxHQUFhLFNBQUMsSUFBRCxFQUFPLEVBQVAsRUFBVyxFQUFYO2VBQWlCO1VBQUMsSUFBQSxFQUFNLElBQVA7VUFBYSxHQUFBLEVBQUssRUFBbEI7VUFBc0IsR0FBQSxFQUFLLEVBQTNCOztNQUFqQjtNQUNiLElBQUksQ0FBQyxVQUFMLEdBQWtCLFNBQUMsR0FBRDtlQUFRO1VBQUMsS0FBQSxFQUFPLEdBQUcsQ0FBQyxRQUFKLENBQUEsQ0FBUjs7TUFBUjtNQUNsQixJQUFJLENBQUMsT0FBTCxHQUFlLFNBQUMsSUFBRCxFQUFPLElBQVA7ZUFBZTtVQUFDLEtBQUEsRUFBTyxJQUFSO1VBQWMsT0FBQSxFQUFTLElBQXZCOztNQUFmO01BRWYsSUFBQSxHQUFPLENBQUssSUFBQSxRQUFBLENBQVMscUJBQUEsR0FBc0IsR0FBdEIsR0FBMEIsSUFBbkMsQ0FBTCxDQUE2QyxDQUFDLElBQTlDLENBQW1ELElBQW5EO2FBRVAsSUFBQyxDQUFBLGFBQUQsQ0FBZSxJQUFmLEVBZkY7S0FBQSxjQUFBO01BZ0JNO0FBQ0osWUFBTSxNQWpCUjs7RUFEUSxDQXBLVjs7Ozs7O0FDSkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0cEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1ZEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6akNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIFR1cmJvbGlua3MgPSB3aW5kb3cuVHVyYm9saW5rcyA9IHJlcXVpcmUoJ3R1cmJvbGlua3MnKS5UdXJib2xpbmtzXG5yZXF1aXJlKCcuL2xpYi90dXJib2Zvcm1zJylcbnJlcXVpcmUoJ2NvbXBvc2Utc2hlbGwnKVxuXG4vLyBTZXR1cCByb3V0ZXNcbnJlcXVpcmUoJ2NvbXBvc2Utcm91dGVyJykuc2V0RXJyb3JIYW5kbGVyKGZ1bmN0aW9uKGVycm9yKXtcbiAgTWVnYXRyb24ubm90aWZ5LmVycm9yKGVycm9yLm1lc3NhZ2UpXG59KVxuXG5yZXF1aXJlKCcuL21vbmdvZGInKVxuXG52YXIgTlByb2dyZXNzID0gcmVxdWlyZSgnbnByb2dyZXNzJylcblxuTlByb2dyZXNzLmNvbmZpZ3VyZSh7c2hvd1NwaW5uZXI6IGZhbHNlfSlcblxuTWVnYXRyb24uRXZlbnQub24oZG9jdW1lbnQsICdwYWdlOmZldGNoJywgZnVuY3Rpb24oKSB7IE5Qcm9ncmVzcy5zdGFydCgpIH0pXG5NZWdhdHJvbi5FdmVudC5vbihkb2N1bWVudCwgJ3BhZ2U6Y2hhbmdlJywgZnVuY3Rpb24oKSB7IE5Qcm9ncmVzcy5kb25lKCkgfSlcbk1lZ2F0cm9uLkV2ZW50Lm9uKGRvY3VtZW50LCAncGFnZTpyZXN0b3JlJywgZnVuY3Rpb24oKSB7IE5Qcm9ncmVzcy5yZW1vdmUoKSB9KVxuXG5NZWdhdHJvbi5FdmVudC5vbihkb2N1bWVudCwgJ2NsaWNrJywgJy50dXJiby1uYXYnLCBmdW5jdGlvbihldmVudCl7XG4gIHZhciBzZWxlY3RlZFRleHQgPSBnZXRTZWxlY3Rpb25UZXh0KClcbiAgaWYgKHNlbGVjdGVkVGV4dClcbiAgICByZXR1cm5cbiAgdmFyIGhyZWYgPSBldmVudC5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2EnKS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgd2luZG93Lm9wZW4oaHJlZiwgJ19ibGFuaycpXG4gIH0gZWxzZSB7XG4gICAgVHVyYm9saW5rcy52aXNpdChocmVmKVxuICB9XG59KVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uVGV4dCgpIHtcbiAgdmFyIHRleHQgPSBcIlwiXG4gIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdGV4dCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi50eXBlICE9IFwiQ29udHJvbFwiKSB7XG4gICAgdGV4dCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLnRleHRcbiAgfVxuICByZXR1cm4gdGV4dFxufVxuO1xuIiwiXyA9IE1lZ2F0cm9uLl9cbmRhdGVGb3JtYXQgPSByZXF1aXJlKFwiLi9kYXRlLmZvcm1hdFwiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFxuICBnZXRJbmRlbnRhdGlvbjogKGxldmVsLCBpbmRlbnRhdGlvbiktPlxuICAgIGlmIGluZGVudGF0aW9uXG4gICAgICBwYWQgPSBcIlxcblwiXG4gICAgICBfLnRpbWVzIChsZXZlbCAqIGluZGVudGF0aW9uKSwgPT5cbiAgICAgICAgcGFkICs9IFwiIFwiXG4gICAgICBwYWRcbiAgICBlbHNlXG4gICAgICBcIiBcIlxuXG4gIHRvQnNvblN0cmluZzogKGpzb24sIG9wdGlvbnM9e30pLT5cbiAgICBsZXZlbCA9IG9wdGlvbnMubGV2ZWwgfHwgMFxuICAgIGlmIG9wdGlvbnMuaW5kZW50YXRpb24/XG4gICAgICBpbmRlbnRhdGlvbiA9IG9wdGlvbnMuaW5kZW50YXRpb25cbiAgICBlbHNlXG4gICAgICBpbmRlbnRhdGlvbiA9IDJcblxuICAgIHJlc3VsdCA9IFwiXCJcbiAgICBlbXB0eU9iamVjdCA9IHRydWVcblxuICAgIHJlc3VsdCArPSBcIiN7QGdldEluZGVudGF0aW9uKGxldmVsLCBpbmRlbnRhdGlvbil9XCIgdW5sZXNzIHJlc3VsdCBpcyBcIlwiXG5cbiAgICBpZiBvcHRpb25zLnZhbHVlT25seVxuICAgICAgcmV0dXJuIEBwYXJzZVZhbHVlKGpzb24sIHJlc3VsdCwgbGV2ZWwsIGluZGVudGF0aW9uLCBvcHRpb25zKVxuICAgIGVsc2UgaWYganNvbiBpbnN0YW5jZW9mIEFycmF5XG4gICAgICByZXN1bHQgKz0gXCJbXCJcbiAgICBlbHNlIGlmIGpzb24gaW5zdGFuY2VvZiBPYmplY3RcbiAgICAgIHJlc3VsdCArPSBcIntcIlxuXG4gICAgZm9yIHAsdiBvZiBqc29uXG4gICAgICBlbXB0eU9iamVjdCA9IGZhbHNlXG4gICAgICByZXN1bHQgKz0gQGdldEluZGVudGF0aW9uKGxldmVsKzEsIGluZGVudGF0aW9uKVxuXG4gICAgICB1bmxlc3MganNvbiBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgIGlmIG9wdGlvbnMuaHRtbFxuICAgICAgICAgIGlmIHAubWF0Y2goL1teQS16MC05X10vKVxuICAgICAgICAgICAgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICBkLnRleHRDb250ZW50ID0gcFxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2tleSc+XFxcIiN7ZC5pbm5lckhUTUx9XFxcIjwvc3Bhbj46IFwiICMgRXNjYXBlIEhUTUxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQgKz0gXCI8c3BhbiBjbGFzcz0na2V5Jz4je3B9PC9zcGFuPjogXCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIHAubWF0Y2goL15cXGR8W15BLXowLTlfXS8pICMgQWRkIHF1b3RlcyB0byBhbnl0aGluZyBub25lLWFscGhhbnVtZXJpY1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcIiN7cC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyl9XFxcIjogXCJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIje3B9OiBcIlxuXG4gICAgICByZXN1bHQgPSBAcGFyc2VWYWx1ZSh2LCByZXN1bHQsIGxldmVsLCBpbmRlbnRhdGlvbiwgb3B0aW9ucylcblxuXG4gICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIC0xKSBpZiByZXN1bHQuc2xpY2UoLTEpIGlzIFwiLFwiICNyZW1vdmUgbGFzdCAsXG5cbiAgICByZXN1bHQgKz0gQGdldEluZGVudGF0aW9uKGxldmVsLCBpbmRlbnRhdGlvbikgdW5sZXNzIGVtcHR5T2JqZWN0XG5cbiAgICBpZiBqc29uIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgIHJlc3VsdCArPSBcIl1cIlxuICAgIGVsc2UgaWYganNvbiBpbnN0YW5jZW9mIE9iamVjdFxuICAgICAgcmVzdWx0ICs9IFwifVwiXG5cbiAgcGFyc2VWYWx1ZTogKHYsIHJlc3VsdCwgbGV2ZWwsIGluZGVudGF0aW9uLCBvcHRpb25zKS0+XG4gICAgaWYgXy5pc051bGwodilcbiAgICAgIGlmIG9wdGlvbnMuaHRtbFxuICAgICAgICByZXN1bHQgKz0gXCI8c3BhbiBjbGFzcz0ndmFsdWUnPm51bGw8L3NwYW4+LFwiXG4gICAgICBlbHNlXG4gICAgICAgIHJlc3VsdCArPSBcIm51bGwsXCJcbiAgICBlbHNlIGlmIHR5cGVvZih2KSBpcyBcIm9iamVjdFwiXG4gICAgICBzd2l0Y2ggdi5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgIFxuICAgICAgICB3aGVuIFwiT2JqZWN0SURcIlxuICAgICAgICAgIGlmIG9wdGlvbnMuaHRtbFxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5PYmplY3RJZDwvc3Bhbj4oPHNwYW4gY2xhc3M9J3N0cmluZyc+XFxcIjxzcGFuIGNsYXNzPSdfaWQnPiN7di50b1N0cmluZygpfTwvc3Bhbj5cXFwiPC9zcGFuPiksXCJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQgKz0gXCJPYmplY3RJZChcXFwiI3t2LnRvU3RyaW5nKCl9XFxcIiksXCJcbiAgICAgICAgXG4gICAgICAgIHdoZW4gXCJEYXRlXCJcbiAgICAgICAgICBkdCA9IG5ldyBEYXRlKHYudG9TdHJpbmcoKSlcbiAgICAgICAgICBkdGYgPSBkYXRlRm9ybWF0KGR0LCAnaXNvVXRjRGF0ZVRpbWUnKVxuICAgICAgICAgIGlmIGR0LmdldE1pbGxpc2Vjb25kcygpID4gMFxuICAgICAgICAgICAgZHRmID0gZHRmLnJlcGxhY2UoL1okLywgXCIuI3tkYXRlRm9ybWF0KGR0LCAnbCcpfVpcIilcbiAgICAgICAgICBpZiBvcHRpb25zLmh0bWxcblxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5JU09EYXRlPC9zcGFuPig8c3BhbiBjbGFzcz0nc3RyaW5nJz5cXFwiI3tkdGZ9XFxcIjwvc3Bhbj4pLFwiXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiSVNPRGF0ZShcXFwiI3tkdGZ9XFxcIiksXCJcbiAgICAgICAgd2hlbiBcIlJlZ0V4cFwiXG4gICAgICAgICAgaWYgb3B0aW9ucy5odG1sXG4gICAgICAgICAgICByZXN1bHQgKz0gXCI8c3BhbiBjbGFzcz0ncmVnZXgnPi8je3YudG9TdHJpbmcoKX08L3NwYW4+LFwiXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiLyN7di50b1N0cmluZygpfSxcIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgIyBSZW1vdmUgdGhpcyBqdW5rIG9uY2UgcHJvYmUgdHJhbnNpdGlvbiBpcyBkb25lLlxuICAgICAgICAgIGlmIHZbXCIkb2lkXCJdXG4gICAgICAgICAgICBpZiBvcHRpb25zLmh0bWxcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5PYmplY3RJZDwvc3Bhbj4oPHNwYW4gY2xhc3M9J3N0cmluZyc+XFxcIjxzcGFuIGNsYXNzPSdfaWQnPiN7dltcIiRvaWRcIl19PC9zcGFuPlxcXCI8L3NwYW4+KSxcIlxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICByZXN1bHQgKz0gXCJPYmplY3RJZChcXFwiI3t2W1wiJG9pZFwiXX1cXFwiKSxcIlxuICAgICAgICAgIGVsc2UgaWYgdltcIiRkYXRlXCJdP1xuICAgICAgICAgICAgZHQgPSBuZXcgRGF0ZSh2WyckZGF0ZSddKVxuICAgICAgICAgICAgZHRmID0gZGF0ZUZvcm1hdChkdCwgJ2lzb1V0Y0RhdGVUaW1lJylcbiAgICAgICAgICAgIGlmIGR0LmdldE1pbGxpc2Vjb25kcygpID4gMFxuICAgICAgICAgICAgICBkdGYgPSBkdGYucmVwbGFjZSgvWiQvLCBcIi4je2RhdGVGb3JtYXQoZHQsICdsJyl9WlwiKVxuICAgICAgICAgICAgaWYgb3B0aW9ucy5odG1sXG5cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5JU09EYXRlPC9zcGFuPig8c3BhbiBjbGFzcz0nc3RyaW5nJz5cXFwiI3tkdGZ9XFxcIjwvc3Bhbj4pLFwiXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIklTT0RhdGUoXFxcIiN7ZHRmfVxcXCIpLFwiXG4gICAgICAgICAgZWxzZSBpZiB2W1wiJGxvbmdcIl1cbiAgICAgICAgICAgIGlmIG9wdGlvbnMuaHRtbFxuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI8c3BhbiBjbGFzcz0nZnVuY3Rpb24nPk51bWJlckxvbmc8L3NwYW4+KFxcXCIje3ZbJyRsb25nJ119XFxcIiksXCJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiTnVtYmVyTG9uZyhcXFwiI3t2WyckbG9uZyddfVxcXCIpLFwiXG4gICAgICAgICAgZWxzZSBpZiB2W1wiJHJlZ2V4XCJdXG4gICAgICAgICAgICBpZiBvcHRpb25zLmh0bWxcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J3JlZ2V4Jz4vI3t2W1wiJHJlZ2V4XCJdfS8je3ZbXCIkb3B0aW9uc1wiXX08L3NwYW4+LFwiXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIi8je3ZbXCIkcmVnZXhcIl19LyN7dltcIiRvcHRpb25zXCJdfSxcIlxuICAgICAgICAgIGVsc2UgaWYgdltcInRcIl0gPj0gMCAmJiB2W1wiaVwiXSA+PSAwXG4gICAgICAgICAgICBpZiBvcHRpb25zLmh0bWxcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5UaW1lc3RhbXA8L3NwYW4+KCN7dltcInRcIl19LCAje3ZbXCJpXCJdfSksXCJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiVGltZXN0YW1wKCN7dltcInRcIl19LCAje3ZbXCJpXCJdfSksXCJcbiAgICAgICAgICBlbHNlIGlmIHZbXCIkcmVmXCJdXG4gICAgICAgICAgICBpZiBvcHRpb25zLmh0bWxcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5EQlJlZjwvc3Bhbj4oXFxcIjxzcGFuIGNsYXNzPSdzdHJpbmcnPiN7dltcIiRyZWZcIl19PC9zcGFuPlxcXCIsICN7QHRvQnNvblN0cmluZyB2W1wiJGlkXCJdLCB7bGV2ZWw6IGxldmVsKzEsIHZhbHVlT25seTogdHJ1ZSwgaHRtbDogdHJ1ZX19XCJcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiLCBcXFwiPHNwYW4gY2xhc3M9J3N0cmluZyc+I3t2W1wiJGRiXCJdfTwvc3Bhbj5cXFwiXCIgaWYgdltcIiRkYlwiXVxuICAgICAgICAgICAgICByZXN1bHQgKz0gXCIpLFwiXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIkRCUmVmKFxcXCIje3ZbXCIkcmVmXCJdfVxcXCIsICN7QHRvQnNvblN0cmluZyB2W1wiJGlkXCJdLCB7bGV2ZWw6IGxldmVsKzEsIHZhbHVlT25seTogdHJ1ZSwgaHRtbDogZmFsc2V9fSksXCJcbiAgICAgICAgICBlbHNlIGlmIHZbJyRiaW5hcnknXVxuICAgICAgICAgICAgaWYgb3B0aW9ucy5odG1sXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIjxzcGFuIGNsYXNzPSdmdW5jdGlvbic+QmluRGF0YTwvc3Bhbj4oPHNwYW4gY2xhc3M9J251bWJlcic+I3t2WyckdHlwZSddfTwvc3Bhbj4sPHNwYW4gY2xhc3M9J3N0cmluZyc+XFxcIiN7dlsnJGJpbmFyeSddfVxcXCI8L3NwYW4+KSxcIlxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICByZXN1bHQgKz0gXCJCaW5EYXRhKCN7dlsnJHR5cGUnXX0sIFxcXCIje3ZbJyRiaW5hcnknXX1cXFwiKSxcIlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiN7QHRvQnNvblN0cmluZyB2LCB7bGV2ZWw6IGxldmVsKzEsIGluZGVudGF0aW9uOiBpbmRlbnRhdGlvbiwgaHRtbDogb3B0aW9ucy5odG1sfX0sXCJcbiAgICBlbHNlXG4gICAgICB2YWwgPSBKU09OLnN0cmluZ2lmeSB2XG4gICAgICBpZiBvcHRpb25zLmh0bWxcbiAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UgLzwvZywgJyZsdDsnXG4gICAgICAgIGNsYXNzTmFtZSA9ICdzdHJpbmcnXG4gICAgICAgIGNsYXNzTmFtZSA9ICd2YWx1ZScgaWYgdmFsIGlzICdmYWxzZScgb3IgdmFsIGlzICd0cnVlJ1xuICAgICAgICBjbGFzc05hbWUgPSAnbnVtYmVyJyBpZiB0eXBlb2YodikgaXMgJ251bWJlcidcbiAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9JyN7Y2xhc3NOYW1lfSc+I3t2YWx9PC9zcGFuPixcIlxuICAgICAgZWxzZVxuICAgICAgICByZXN1bHQgKz0gXCIje3ZhbH0sXCJcblxuICAgIGlmIG9wdGlvbnMudmFsdWVPbmx5XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgLTEpIGlmIHJlc3VsdC5zbGljZSgtMSkgaXMgXCIsXCIgI3JlbW92ZSBsYXN0ICxcblxuICAgIHJldHVybiByZXN1bHRcblxuICBzYW5pdGl6ZVJlZ2V4OiAoanNvbiktPlxuICAgIGZvciBwLHYgb2YganNvblxuICAgICAgaWYgKHYgaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgIHJlZ2V4cF9wYXJ0cyA9IHYudG9TdHJpbmcoKS5tYXRjaCgvXlxcLyguKilcXC8oW2dpbV0qKSQvKVxuICAgICAgICBqc29uW3BdID0geyRyZWdleDogcmVnZXhwX3BhcnRzWzFdLCAkb3B0aW9uczogcmVnZXhwX3BhcnRzWzJdfVxuICAgICAgZWxzZSBpZiBwIGlzIFwiJG9pZFwiIGFuZCB0eXBlb2YgdiBpcyBcInVuZGVmaW5lZFwiXG4gICAgICAgIGFsZXJ0IFwianNvbltwXSA9IHdpbmRvdy5kYmxheWVyLnBhZ2VfZGF0YS5kb2N1bWVudF9vaWRzLnNoaWZ0KClcIlxuICAgICAgZWxzZSBpZiBwIGlzIFwiJGRhdGVcIiBhbmQgdHlwZW9mIHYgaXMgXCJ1bmRlZmluZWRcIlxuICAgICAgICBqc29uW3BdID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKVxuICAgICAgZWxzZSBpZiB0eXBlb2YodikgaXMgXCJvYmplY3RcIlxuICAgICAgICBqc29uW3BdID0gQHNhbml0aXplUmVnZXgodilcblxuICAgIGpzb25cblxuICBic29uRXZhbDogKHNyYyktPlxuICAgIHRyeVxuICAgICAgbWFzayA9IHt9XG4gICAgICBmb3IgcCx2IG9mIHRoaXNcbiAgICAgICAgbWFza1t2XSA9IHVuZGVmaW5lZFxuXG4gICAgICBtYXNrLk9iamVjdElkID0gKGlkKS0+IHskb2lkOiBpZH1cbiAgICAgIG1hc2suRGF0ZSA9IChkYXRlKS0+IHskZGF0ZTogZGF0ZX1cbiAgICAgIG1hc2suSVNPRGF0ZSA9IChkYXRlKS0+IHskZGF0ZTogKG5ldyBEYXRlKGRhdGUpKS5nZXRUaW1lKCkgfVxuICAgICAgbWFzay5UaW1lc3RhbXAgPSAodCwgaSktPiB7XCJ0XCI6IHQsIFwiaVwiOiBpfVxuICAgICAgbWFzay5EQlJlZiA9IChuYW1lLCBpZCwgZGIpLT4geyRyZWY6IG5hbWUsICRpZDogaWQsICRkYjogZGJ9XG4gICAgICBtYXNrLk51bWJlckxvbmcgPSAobnVtKS0+IHskbG9uZzogbnVtLnRvU3RyaW5nKCl9XG4gICAgICBtYXNrLkJpbkRhdGEgPSAodHlwZSwgZGF0YSktPiB7JHR5cGU6IHR5cGUsICRiaW5hcnk6IGRhdGF9XG5cbiAgICAgIGpzb24gPSAobmV3IEZ1bmN0aW9uKFwid2l0aCh0aGlzKXsgcmV0dXJuICN7c3JjfSB9XCIpKS5jYWxsKG1hc2spXG5cbiAgICAgIEBzYW5pdGl6ZVJlZ2V4KGpzb24pXG4gICAgY2F0Y2ggZXJyb3JcbiAgICAgIHRocm93IGVycm9yXG4iLCIvKlxuICogRGF0ZSBGb3JtYXQgMS4yLjNcbiAqIChjKSAyMDA3LTIwMDkgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gKiBNSVQgbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9kYXRlLXRpbWUtZm9ybWF0XG4gKiBJbmNsdWRlcyBlbmhhbmNlbWVudHMgYnkgU2NvdHQgVHJlbmRhIDxzY290dC50cmVuZGEubmV0PlxuICogYW5kIEtyaXMgS293YWwgPGNpeGFyLmNvbS9+a3Jpcy5rb3dhbC8+XG4gKlxuICogQWNjZXB0cyBhIGRhdGUsIGEgbWFzaywgb3IgYSBkYXRlIGFuZCBhIG1hc2suXG4gKiBSZXR1cm5zIGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgZGF0ZSBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBkYXRlL3RpbWUuXG4gKiBUaGUgbWFzayBkZWZhdWx0cyB0byBkYXRlRm9ybWF0Lm1hc2tzLmRlZmF1bHQuXG4gKi9cblxudmFyIGRhdGVGb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRva2VuID0gL2R7MSw0fXxtezEsNH18eXkoPzp5eSk/fChbSGhNc1R0XSlcXDE/fFtMbG9TWl18XCJbXlwiXSpcInwnW14nXSonL2csXG4gICAgdGltZXpvbmUgPSAvXFxiKD86W1BNQ0VBXVtTRFBdVHwoPzpQYWNpZmljfE1vdW50YWlufENlbnRyYWx8RWFzdGVybnxBdGxhbnRpYykgKD86U3RhbmRhcmR8RGF5bGlnaHR8UHJldmFpbGluZykgVGltZXwoPzpHTVR8VVRDKSg/OlstK11cXGR7NH0pPylcXGIvZyxcbiAgICB0aW1lem9uZUNsaXAgPSAvW14tK1xcZEEtWl0vZyxcbiAgICBwYWQgPSBmdW5jdGlvbiAodmFsLCBsZW4pIHtcbiAgICAgIHZhbCA9IFN0cmluZyh2YWwpO1xuICAgICAgbGVuID0gbGVuIHx8IDI7XG4gICAgICB3aGlsZSAodmFsLmxlbmd0aCA8IGxlbikgdmFsID0gXCIwXCIgKyB2YWw7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgLy8gUmVnZXhlcyBhbmQgc3VwcG9ydGluZyBmdW5jdGlvbnMgYXJlIGNhY2hlZCB0aHJvdWdoIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBtYXNrLCB1dGMpIHtcbiAgICB2YXIgZEYgPSBkYXRlRm9ybWF0O1xuXG4gICAgLy8gWW91IGNhbid0IHByb3ZpZGUgdXRjIGlmIHlvdSBza2lwIG90aGVyIGFyZ3MgKHVzZSB0aGUgXCJVVEM6XCIgbWFzayBwcmVmaXgpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0ZSkgPT0gXCJbb2JqZWN0IFN0cmluZ11cIiAmJiAhL1xcZC8udGVzdChkYXRlKSkge1xuICAgICAgbWFzayA9IGRhdGU7XG4gICAgICBkYXRlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFBhc3NpbmcgZGF0ZSB0aHJvdWdoIERhdGUgYXBwbGllcyBEYXRlLnBhcnNlLCBpZiBuZWNlc3NhcnlcbiAgICBkYXRlID0gZGF0ZSA/IG5ldyBEYXRlKGRhdGUpIDogbmV3IERhdGU7XG4gICAgaWYgKGlzTmFOKGRhdGUpKSB0aHJvdyBTeW50YXhFcnJvcihcImludmFsaWQgZGF0ZVwiKTtcblxuICAgIG1hc2sgPSBTdHJpbmcoZEYubWFza3NbbWFza10gfHwgbWFzayB8fCBkRi5tYXNrc1tcImRlZmF1bHRcIl0pO1xuXG4gICAgLy8gQWxsb3cgc2V0dGluZyB0aGUgdXRjIGFyZ3VtZW50IHZpYSB0aGUgbWFza1xuICAgIGlmIChtYXNrLnNsaWNlKDAsIDQpID09IFwiVVRDOlwiKSB7XG4gICAgICBtYXNrID0gbWFzay5zbGljZSg0KTtcbiAgICAgIHV0YyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIF8gPSB1dGMgPyBcImdldFVUQ1wiIDogXCJnZXRcIixcbiAgICAgIGQgPSBkYXRlW18gKyBcIkRhdGVcIl0oKSxcbiAgICAgIEQgPSBkYXRlW18gKyBcIkRheVwiXSgpLFxuICAgICAgbSA9IGRhdGVbXyArIFwiTW9udGhcIl0oKSxcbiAgICAgIHkgPSBkYXRlW18gKyBcIkZ1bGxZZWFyXCJdKCksXG4gICAgICBIID0gZGF0ZVtfICsgXCJIb3Vyc1wiXSgpLFxuICAgICAgTSA9IGRhdGVbXyArIFwiTWludXRlc1wiXSgpLFxuICAgICAgcyA9IGRhdGVbXyArIFwiU2Vjb25kc1wiXSgpLFxuICAgICAgTCA9IGRhdGVbXyArIFwiTWlsbGlzZWNvbmRzXCJdKCksXG4gICAgICBvID0gdXRjID8gMCA6IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgIGZsYWdzID0ge1xuICAgICAgICBkOiAgICBkLFxuICAgICAgICBkZDogICBwYWQoZCksXG4gICAgICAgIGRkZDogIGRGLmkxOG4uZGF5TmFtZXNbRF0sXG4gICAgICAgIGRkZGQ6IGRGLmkxOG4uZGF5TmFtZXNbRCArIDddLFxuICAgICAgICBtOiAgICBtICsgMSxcbiAgICAgICAgbW06ICAgcGFkKG0gKyAxKSxcbiAgICAgICAgbW1tOiAgZEYuaTE4bi5tb250aE5hbWVzW21dLFxuICAgICAgICBtbW1tOiBkRi5pMThuLm1vbnRoTmFtZXNbbSArIDEyXSxcbiAgICAgICAgeXk6ICAgU3RyaW5nKHkpLnNsaWNlKDIpLFxuICAgICAgICB5eXl5OiB5LFxuICAgICAgICBoOiAgICBIICUgMTIgfHwgMTIsXG4gICAgICAgIGhoOiAgIHBhZChIICUgMTIgfHwgMTIpLFxuICAgICAgICBIOiAgICBILFxuICAgICAgICBISDogICBwYWQoSCksXG4gICAgICAgIE06ICAgIE0sXG4gICAgICAgIE1NOiAgIHBhZChNKSxcbiAgICAgICAgczogICAgcyxcbiAgICAgICAgc3M6ICAgcGFkKHMpLFxuICAgICAgICBsOiAgICBwYWQoTCwgMyksXG4gICAgICAgIEw6ICAgIHBhZChMID4gOTkgPyBNYXRoLnJvdW5kKEwgLyAxMCkgOiBMKSxcbiAgICAgICAgdDogICAgSCA8IDEyID8gXCJhXCIgIDogXCJwXCIsXG4gICAgICAgIHR0OiAgIEggPCAxMiA/IFwiYW1cIiA6IFwicG1cIixcbiAgICAgICAgVDogICAgSCA8IDEyID8gXCJBXCIgIDogXCJQXCIsXG4gICAgICAgIFRUOiAgIEggPCAxMiA/IFwiQU1cIiA6IFwiUE1cIixcbiAgICAgICAgWjogICAgdXRjID8gXCJVVENcIiA6IChTdHJpbmcoZGF0ZSkubWF0Y2godGltZXpvbmUpIHx8IFtcIlwiXSkucG9wKCkucmVwbGFjZSh0aW1lem9uZUNsaXAsIFwiXCIpLFxuICAgICAgICBvOiAgICAobyA+IDAgPyBcIi1cIiA6IFwiK1wiKSArIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCksXG4gICAgICAgIFM6ICAgIFtcInRoXCIsIFwic3RcIiwgXCJuZFwiLCBcInJkXCJdW2QgJSAxMCA+IDMgPyAwIDogKGQgJSAxMDAgLSBkICUgMTAgIT0gMTApICogZCAlIDEwXVxuICAgICAgfTtcblxuICAgIHJldHVybiBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uICgkMCkge1xuICAgICAgcmV0dXJuICQwIGluIGZsYWdzID8gZmxhZ3NbJDBdIDogJDAuc2xpY2UoMSwgJDAubGVuZ3RoIC0gMSk7XG4gICAgfSk7XG4gIH07XG59KCk7XG5cbi8vIFNvbWUgY29tbW9uIGZvcm1hdCBzdHJpbmdzXG5kYXRlRm9ybWF0Lm1hc2tzID0ge1xuICBcImRlZmF1bHRcIjogICAgICBcImRkZCBtbW0gZGQgeXl5eSBISDpNTTpzc1wiLFxuICBzaG9ydERhdGU6ICAgICAgXCJtL2QveXlcIixcbiAgbWVkaXVtRGF0ZTogICAgIFwibW1tIGQsIHl5eXlcIixcbiAgbG9uZ0RhdGU6ICAgICAgIFwibW1tbSBkLCB5eXl5XCIsXG4gIGZ1bGxEYXRlOiAgICAgICBcImRkZGQsIG1tbW0gZCwgeXl5eVwiLFxuICBzaG9ydFRpbWU6ICAgICAgXCJoOk1NIFRUXCIsXG4gIG1lZGl1bVRpbWU6ICAgICBcImg6TU06c3MgVFRcIixcbiAgbG9uZ1RpbWU6ICAgICAgIFwiaDpNTTpzcyBUVCBaXCIsXG4gIGlzb0RhdGU6ICAgICAgICBcInl5eXktbW0tZGRcIixcbiAgaXNvVGltZTogICAgICAgIFwiSEg6TU06c3NcIixcbiAgaXNvRGF0ZVRpbWU6ICAgIFwieXl5eS1tbS1kZCdUJ0hIOk1NOnNzXCIsXG4gIGlzb1V0Y0RhdGVUaW1lOiBcIlVUQzp5eXl5LW1tLWRkJ1QnSEg6TU06c3MnWidcIlxufTtcblxuLy8gSW50ZXJuYXRpb25hbGl6YXRpb24gc3RyaW5nc1xuZGF0ZUZvcm1hdC5pMThuID0ge1xuICBkYXlOYW1lczogW1xuICAgIFwiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsXG4gICAgXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXG4gIF0sXG4gIG1vbnRoTmFtZXM6IFtcbiAgICBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiLFxuICAgIFwiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIlxuICBdXG59O1xuXG4vLyBGb3IgY29udmVuaWVuY2UuLi5cbkRhdGUucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChtYXNrLCB1dGMpIHtcbiAgcmV0dXJuIGRhdGVGb3JtYXQodGhpcywgbWFzaywgdXRjKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGF0ZUZvcm1hdDsiLCJ2YXIgc2VyaWFsaXplID0gcmVxdWlyZSgnc2VyaWFsaXplJylcbnZhciBUdXJib2xpbmtzID0gcmVxdWlyZSgndHVyYm9saW5rcycpLlR1cmJvbGlua3NcblxuTWVnYXRyb24uRXZlbnQub24oZG9jdW1lbnQsICdzdWJtaXQnLCAnZm9ybVtkYXRhLXR1cmJvZm9ybV0nLCBmdW5jdGlvbihldmVudCl7XG4gIGNvbnNvbGUubG9nKCdNZWdhdHJvbi5ldmVudCBmb3JtW2RhdGEtdHVyYm9mb3JtXSBzdWJtaXQnKVxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIFR1cmJvbGlua3MudmlzaXQobG9jYXRpb24ucGF0aG5hbWUgKyAnPycgKyBzZXJpYWxpemUoZXZlbnQuY3VycmVudFRhcmdldCkpXG59KSIsInZhciByb3V0ZSA9IHJlcXVpcmUoJ2NvbXBvc2Utcm91dGVyJylcbnZhciBCU09OID0gcmVxdWlyZSgnLi4vbGliL2Jzb24nKVxuXG4vLyBDb2xsZWN0aW9uIHNldHRpbmdzIHBhZ2UuXG5yb3V0ZShcbiAgJy86YWNjb3VudC9kZXBsb3ltZW50cy86ZGVwbG95bWVudC9tb25nb2RiL2RhdGFiYXNlcy86ZGF0YWJhc2UvY29sbGVjdGlvbnMvOmNvbGxlY3Rpb24vZWRpdCcsXG4gIGNvbGxlY3Rpb25TZXR0aW5nc1BhZ2VcbilcblxuLy8gU2FuZGJveGVzXG5yb3V0ZShcbiAgJy86YWNjb3VudC9tb25nb2RiL2RhdGFiYXNlcy86ZGF0YWJhc2UvY29sbGVjdGlvbnMvOmNvbGxlY3Rpb24vZWRpdCcsXG4gIGNvbGxlY3Rpb25TZXR0aW5nc1BhZ2VcbilcblxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uU2V0dGluZ3NQYWdlKGN0eCwgbmV4dCl7XG4gIHZhciBzdGF0c0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbGxlY3Rpb24taW5mbycpXG4gIHN0YXRzRWwuY2xhc3NOYW1lICs9IFwiIGxhbmd1YWdlLWpzb25cIlxuICBzdGF0c0VsLmlubmVySFRNTCA9IEJTT04udG9Cc29uU3RyaW5nKEpTT04ucGFyc2Uoc3RhdHNFbC5pbm5lckhUTUwpKVxuICBNZWdhdHJvbi51dGlscy5oaWdobGlnaHRDb2RlKClcbn0iLCJ2YXIgcm91dGUgPSByZXF1aXJlKCdjb21wb3NlLXJvdXRlcicpXG52YXIgQlNPTiA9IHJlcXVpcmUoJy4uL2xpYi9ic29uJylcbnZhciBUdXJib2xpbmtzID0gcmVxdWlyZSgndHVyYm9saW5rcycpLlR1cmJvbGlua3NcblxuLy8gQ2x1c3RlciBzaG93IHBhZ2UuXG5yb3V0ZShcbiAgJy86YWNjb3VudC9kZXBsb3ltZW50cy86ZGVwbG95bWVudC9tb25nb2RiL2NsdXN0ZXInLFxuICBkb2N1bWVudHNJbmRleFBhZ2Vcbilcbi8vIERvY3VtZW50cyBpbmRleCBwYWdlLlxucm91dGUoXG4gICcvOmFjY291bnQvZGVwbG95bWVudHMvOmRlcGxveW1lbnQvbW9uZ29kYi9kYXRhYmFzZXMvOmRhdGFiYXNlL2NvbGxlY3Rpb25zLzpjb2xsZWN0aW9uL2RvY3VtZW50cycsXG4gIGRvY3VtZW50c0luZGV4UGFnZVxuKVxucm91dGUoXG4gICcvOmFjY291bnQvbW9uZ29kYi9kYXRhYmFzZXMvOmRhdGFiYXNlL2NvbGxlY3Rpb25zLzpjb2xsZWN0aW9uL2RvY3VtZW50cycsXG4gIGRvY3VtZW50c0luZGV4UGFnZVxuKVxuXG4vLyBEb2N1bWVudCBTSE9XIHBhZ2UuXG5yb3V0ZShcbiAgJy86YWNjb3VudC9kZXBsb3ltZW50cy86ZGVwbG95bWVudC9tb25nb2RiL2RhdGFiYXNlcy86ZGF0YWJhc2UvY29sbGVjdGlvbnMvOmNvbGxlY3Rpb24vZG9jdW1lbnRzLzpkb2NfaWQnLFxuICBkb2N1bWVudHNTaG93UGFnZVxuKVxucm91dGUoXG4gICcvOmFjY291bnQvbW9uZ29kYi9kYXRhYmFzZXMvOmRhdGFiYXNlL2NvbGxlY3Rpb25zLzpjb2xsZWN0aW9uL2RvY3VtZW50cy86ZG9jX2lkJyxcbiAgZG9jdW1lbnRzU2hvd1BhZ2Vcbilcblxud2luZG93LmluaXRpYWxWYWx1ZSA9IG51bGxcblxuZnVuY3Rpb24gcHJldHR5QnNvbigpe1xuICB2YXIgYnNvbkVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5ic29uLXBsYWluJylcbiAgTWVnYXRyb24uXy5lYWNoKGJzb25FbHMsIGZ1bmN0aW9uKGJzb25FbCl7XG4gICAgdmFyIGJzb25TdHJpbmcgPSBCU09OLnRvQnNvblN0cmluZyhKU09OLnBhcnNlKGJzb25FbC5pbm5lckhUTUwpLCB7XG4gICAgICB2YWx1ZU9ubHk6IHRydWVcbiAgICB9KVxuICAgIGJzb25FbC5pbm5lckhUTUwgPSBic29uU3RyaW5nXG4gICAgYnNvbkVsLmNsYXNzTGlzdC5yZW1vdmUoJ2Jzb24tcGxhaW4nKVxuICB9KVxufVxuXG5mdW5jdGlvbiBkb2N1bWVudHNJbmRleFBhZ2UoY3R4LCBuZXh0KXtcbiAgLy8gQlNPTiBwYXJzaW5nLlxuXG4gIHZhciBkb2NFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYnNvbi1jb2RlID4gZGl2JylcbiAgTWVnYXRyb24uXy5lYWNoKGRvY0VscywgZnVuY3Rpb24oZG9jRWwpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgYnNvbiA9IEJTT04udG9Cc29uU3RyaW5nKEpTT04ucGFyc2UoZG9jRWwuaW5uZXJIVE1MKSwge1xuICAgICAgICBpbmRlbnRhdGlvbjogY3R4LnF1ZXJ5WydleHBsYWluJ10gPyAyIDogMCxcbiAgICAgICAgaHRtbDogdHJ1ZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEJ1Z3NuYWcgcHJvYi4uLlxuICAgIH1cbiAgICBpZiAodHlwZW9mIGJzb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoY3R4LnF1ZXJ5WydleHBsYWluJ10pXG4gICAgICAgIGRvY0VsLnBhcmVudE5vZGUuaW5uZXJIVE1MID0gJzxwcmU+Jytic29uKyc8L3ByZT4nXG4gICAgICBlbHNlXG4gICAgICAgIGRvY0VsLmlubmVySFRNTCA9IGJzb25cbiAgICB9XG4gIH0pXG5cbiAgTWVnYXRyb24uRXZlbnQub24oZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpdGUnKSwgJ2NsaWNrJywgJy5kb2N1bWVudC1zdW1tYXJ5JywgZnVuY3Rpb24oZXZlbnQpe1xuICAgIHZhciBzZWxlY3RlZFRleHQgPSBnZXRTZWxlY3Rpb25UZXh0KClcbiAgICBpZiAoIXNlbGVjdGVkVGV4dCkge1xuICAgICAgdmFyIGhyZWYgPSBldmVudC5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2EnKS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgICAgICB3aW5kb3cub3BlbihocmVmLCAnX2JsYW5rJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFR1cmJvbGlua3MudmlzaXQoaHJlZilcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcHJldHR5QnNvbigpXG4gIG5leHQoKSBcbn1cblxuZnVuY3Rpb24gZG9jdW1lbnRzU2hvd1BhZ2UoY3R4LCBuZXh0KXtcbiAgdmFyIGRvY1R4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb2RlLWVkaXRvci1jb250ZW50IHRleHRhcmVhJylcbiAgaWYgKCFkb2NUeHQpXG4gICAgcmV0dXJuXG4gIHRyeSB7XG4gICAgaW5pdGlhbFZhbHVlID0gZG9jVHh0LnZhbHVlID0gQlNPTi50b0Jzb25TdHJpbmcoSlNPTi5wYXJzZShkb2NUeHQudmFsdWUpLCB7XG4gICAgICBpbmRlbnRhdGlvbjogMixcbiAgICAgIGh0bWw6IGZhbHNlXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBQcm9iYWJseSBhbHJlYWR5IHBhcnNlZCwgdGhlIHVzZXIgbWlnaHQgaGF2ZSBwcmVzc2VkIHRoZSBiYWNrIGJ1dHRvbi5cbiAgICAvLyBNZWdhdHJvbi5ub3RpZnkuZXJyb3IoXCJQYXJzaW5nIGZhaWxlZDogXCIrZXJyb3IubWVzc2FnZSlcbiAgICBpbml0aWFsVmFsdWUgPSBkb2NUeHQudmFsdWVcbiAgfVxuICBcbiAgTWVnYXRyb24udXRpbHMuQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEoZG9jVHh0LCB7XG4gICAgbW9kZToge1xuICAgICAgbmFtZTogXCJqYXZhc2NyaXB0XCIsXG4gICAgICBqc29uOiB0cnVlXG4gICAgfSxcbiAgICBpbmRlbnRVbml0OiAyLFxuICAgIG1hdGNoQnJhY2tldHM6IHRydWUsXG4gICAgbGluZVdyYXBwaW5nOiB0cnVlXG4gIH0pXG5cbiAgcHJldHR5QnNvbigpXG4gIG5leHQoKVxufVxuXG5mdW5jdGlvbiBmb3JtYXRCU09ORXJyb3IoZXJyb3IpIHtcbiAgY29uc29sZS5sb2coJ0JTT04gZXJyb3InLCBlcnJvcilcbiAgdmFyIG1zZyA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3JcbiAgaWYgKG1zZyAhPT0gJ0Nhbm5vdCBzYXZlIGRvY3VtZW50cyB3aXRoIEJpbmFyeSB2YWx1ZXMnKVxuICAgIHJldHVybiAnVGhpcyBkb2N1bWVudCBjb250YWlucyBpbnZhbGlkIEJTT04nXG4gIHJldHVybiBtc2dcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uVGV4dCgpIHtcbiAgdmFyIHRleHQgPSBcIlwiXG4gIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdGV4dCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi50eXBlICE9IFwiQ29udHJvbFwiKSB7XG4gICAgdGV4dCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLnRleHRcbiAgfVxuICByZXR1cm4gdGV4dFxufVxuXG4vLyBFdmVudCBkZWxlZ2F0aW9uXG5cbi8vIFZhbGlkYXRpb25cbk1lZ2F0cm9uLkV2ZW50Lm9uKGRvY3VtZW50LCAnY2xpY2snLCAnLnZhbGlkYXRlLWRvY3VtZW50JywgZnVuY3Rpb24oZXZlbnQpe1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIHZhciBlZGl0b3IgPSBnZXREb2N1bWVudEVkaXRvcigpXG4gIHRyeSB7XG4gICAgZWRpdG9yLnNldFZhbHVlKEJTT04udG9Cc29uU3RyaW5nKEJTT04uYnNvbkV2YWwoZWRpdG9yLmdldFZhbHVlKCkpKSlcbiAgICBNZWdhdHJvbi5ub3RpZnkuc3VjY2VzcygnVGhpcyBkb2N1bWVudCBpcyB2YWxpZC4nKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIE1lZ2F0cm9uLm5vdGlmeS5lcnJvcihmb3JtYXRCU09ORXJyb3IoZXJyb3IpKVxuICB9XG59KVxuXG4vLyBTYXZlXG5NZWdhdHJvbi5FdmVudC5vbihkb2N1bWVudCwgJ2NsaWNrJywgJy5zYXZlLWRvY3VtZW50JywgZnVuY3Rpb24oZXZlbnQpe1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIHZhciBlZGl0b3IgPSBnZXREb2N1bWVudEVkaXRvcigpXG4gIC8vIFVwZGF0ZSBhIGhpZGRlbiBmaWVsZCB3aXRoIHRoZSBuZXcgZG9jdW1lbnQgZGF0YVxuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZG9jdW1lbnRfZG9jJykudmFsdWUgPSBKU09OLnN0cmluZ2lmeShCU09OLmJzb25FdmFsKGVkaXRvci5nZXRWYWx1ZSgpKSlcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RvYy1mb3JtJykuc3VibWl0KClcbn0pXG5cbi8vIFJldmVydCB0byBvcmlnaW5hbCB2YWx1ZVxuTWVnYXRyb24uRXZlbnQub24oZG9jdW1lbnQsICdjbGljaycsICcucmV2ZXJ0LWRvY3VtZW50JywgZnVuY3Rpb24oZXZlbnQpe1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIHZhciBlZGl0b3IgPSBnZXREb2N1bWVudEVkaXRvcigpXG4gIGVkaXRvci5zZXRWYWx1ZShpbml0aWFsVmFsdWUpXG4gIE1lZ2F0cm9uLm5vdGlmeS5zdWNjZXNzKCdEb2N1bWVudCBlZGl0b3IgcmV2ZXJ0ZWQgdG8gdmFsdWUgd2hlbiB0aGUgcGFnZSB3YXMgaW5pdGlhbGx5IGxvYWRlZC4nKVxufSlcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFZGl0b3IoKXtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb2RlLWVkaXRvci1jb250ZW50IC5Db2RlTWlycm9yJykuQ29kZU1pcnJvclxufVxuIiwicmVxdWlyZSgnLi9kb2N1bWVudHMnKVxucmVxdWlyZSgnLi9pbmRleGVzJylcbnJlcXVpcmUoJy4vY29sbGVjdGlvbnMnKVxucmVxdWlyZSgnLi91c2VycycpXG5cbnJlcXVpcmUoJy4vbW9uaXRvcmluZycpIiwidmFyIHJvdXRlID0gcmVxdWlyZSgnY29tcG9zZS1yb3V0ZXInKVxudmFyIEJTT04gPSByZXF1aXJlKCcuLi9saWIvYnNvbicpXG4gXG4vLyBJbmRleGVzIGluZGV4IHBhZ2UuXG5yb3V0ZShcbiAgJy86YWNjb3VudC9kZXBsb3ltZW50cy86ZGVwbG95bWVudC9tb25nb2RiL2RhdGFiYXNlcy86ZGF0YWJhc2UvY29sbGVjdGlvbnMvOmNvbGxlY3Rpb24vaW5kZXhlcycsXG4gIGluZGV4ZXNJbmRleFBhZ2VcbilcbnJvdXRlKFxuICAnLzphY2NvdW50L21vbmdvZGIvZGF0YWJhc2VzLzpkYXRhYmFzZS9jb2xsZWN0aW9ucy86Y29sbGVjdGlvbi9pbmRleGVzJyxcbiAgaW5kZXhlc0luZGV4UGFnZVxuKVxuXG5mdW5jdGlvbiBpbmRleGVzSW5kZXhQYWdlKGN0eCwgbmV4dCl7XG4gIHZhciBkb2NFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYnNvbi1jb2RlIC50YWJsZS1jZWxsJylcbiAgTWVnYXRyb24uXy5lYWNoKGRvY0VscywgZnVuY3Rpb24oZG9jRWwpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgYnNvbiA9IEJTT04udG9Cc29uU3RyaW5nKEpTT04ucGFyc2UoZG9jRWwuaW5uZXJIVE1MKSwge1xuICAgICAgICBpbmRlbnRhdGlvbjogMCxcbiAgICAgICAgaHRtbDogdHJ1ZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEJ1Z3NuYWcgcHJvYi4uLlxuICAgIH1cbiAgICBpZiAodHlwZW9mIGJzb24gIT09ICd1bmRlZmluZWQnKVxuICAgICAgZG9jRWwuaW5uZXJIVE1MID0gYnNvblxuICB9KVxuXG4gIG5leHQoKVxufSIsInJlcXVpcmUoJy4vb3BlcmF0aW9ucycpXG5yZXF1aXJlKCcuL2xvZ3MnKVxucmVxdWlyZSgnLi9zZXJ2ZXJfc3RhdHVzJykiLCJ2YXIgcm91dGUgPSByZXF1aXJlKCdjb21wb3NlLXJvdXRlcicpXG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKVxuXG53aW5kb3cubG9nU3RyZWFtSW50ZXJ2YWwgPSBudWxsXG5cbk1lZ2F0cm9uLkV2ZW50Lm9uKGRvY3VtZW50LCAncGFnZTpiZWZvcmUtY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpe1xuICBpZiAobG9nU3RyZWFtSW50ZXJ2YWwpXG4gICAgY2xlYXJJbnRlcnZhbChsb2dTdHJlYW1JbnRlcnZhbClcbn0pXG5cbi8vIEluZGV4ZXMgaW5kZXggcGFnZS5cbnJvdXRlKFxuICAnLzphY2NvdW50L2RlcGxveW1lbnRzLzpkZXBsb3ltZW50L21vbmdvZGIvbW9uaXRvcmluZy86aG9zdG5hbWUvbG9ncycsXG4gIGZ1bmN0aW9uKGN0eCwgbmV4dCl7XG4gICAgLy8gcmV0dXJuIG5leHQoKVxuICAgIHZhciBsb2dzQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1vbmdvbG9nIHVsJylcbiAgICB2YXIgbG9ncyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb25nb2xvZyBsaScpXG4gICAgaWYgKGxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGxhc3RMb2dUaW1lc3RhbXAgPSBsb2dzW2xvZ3MubGVuZ3RoIC0gMV0uZ2V0QXR0cmlidXRlKCdkYXRhLXRpbWVzdGFtcCcpXG4gICAgICBsb2dTdHJlYW1JbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAuZ2V0KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICAgICAgICAucXVlcnkoe2Zyb206IGxhc3RMb2dUaW1lc3RhbXB9KVxuICAgICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICAgICAgICAgIC5lbmQoZnVuY3Rpb24oZXJyb3IsIHJlc3Ape1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8ICFyZXNwLm9rIHx8IHJlc3AuYm9keS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgdmFyIGxvZ3NGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IHJlc3AuYm9keS5sZW5ndGggPiBpOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0xvZ0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKVxuICAgICAgICAgICAgICBuZXdMb2dFbC50ZXh0Q29udGVudCA9IHJlc3AuYm9keVtpXS5yYXdcbiAgICAgICAgICAgICAgbG9nc0ZyYWdtZW50LmFwcGVuZENoaWxkKG5ld0xvZ0VsKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TG9nVGltZXN0YW1wID0gcmVzcC5ib2R5W3Jlc3AuYm9keS5sZW5ndGggLSAxXS50aW1lc3RhbXBcbiAgICAgICAgICAgIGxvZ3NDb250YWluZXIuYXBwZW5kQ2hpbGQobG9nc0ZyYWdtZW50KVxuICAgICAgICAgIH0pXG4gICAgICB9LCAxMDAwICogNSlcbiAgICB9XG4gICAgbmV4dCgpXG4gIH1cbikiLCJ2YXIgcm91dGUgPSByZXF1aXJlKCdjb21wb3NlLXJvdXRlcicpXG52YXIgQlNPTiA9IHJlcXVpcmUoJy4uLy4uL2xpYi9ic29uJylcbiBcbi8vIEluZGV4ZXMgaW5kZXggcGFnZS5cbnJvdXRlKFxuICAnLzphY2NvdW50L2RlcGxveW1lbnRzLzpkZXBsb3ltZW50L21vbmdvZGIvbW9uaXRvcmluZy86aG9zdG5hbWUvb3BlcmF0aW9ucycsXG4gIGZ1bmN0aW9uKGN0eCwgbmV4dCl7XG4gICAgdmFyIGRvY0VscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50YWJsZS1jZWxsLmJzb24tY29kZScpXG4gICAgTWVnYXRyb24uXy5lYWNoKGRvY0VscywgZnVuY3Rpb24oZG9jRWwpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGJzb24gPSBCU09OLnRvQnNvblN0cmluZyhKU09OLnBhcnNlKGRvY0VsLmlubmVySFRNTCksIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbjogMCxcbiAgICAgICAgICBodG1sOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciBwYXJzaW5nXCIsIGVycilcbiAgICAgICAgLy8gQnVnc25hZyBwcm9iLi4uXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGJzb24gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBkb2NFbC5pbm5lckhUTUwgPSBic29uXG4gICAgfSlcblxuICAgIG5leHQoKVxuICB9XG4pIiwidmFyIHJvdXRlID0gcmVxdWlyZSgnY29tcG9zZS1yb3V0ZXInKVxudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50Jylcblxud2luZG93LnNlcnZlclN0YXR1c1N0cmVhbUludGVydmFsID0gbnVsbFxuXG5NZWdhdHJvbi5FdmVudC5vbihkb2N1bWVudCwgJ3BhZ2U6YmVmb3JlLWNoYW5nZScsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgaWYgKHNlcnZlclN0YXR1c1N0cmVhbUludGVydmFsKVxuICAgIGNsZWFySW50ZXJ2YWwoc2VydmVyU3RhdHVzU3RyZWFtSW50ZXJ2YWwpXG59KVxuXG4vLyBJbmRleGVzIGluZGV4IHBhZ2UuXG5yb3V0ZShcbiAgJy86YWNjb3VudC9kZXBsb3ltZW50cy86ZGVwbG95bWVudC9tb25nb2RiL21vbml0b3JpbmcvOmhvc3RuYW1lL3NlcnZlcl9zdGF0dXMnLFxuICBmdW5jdGlvbihjdHgsIG5leHQpe1xuICAgIGNvbnNvbGUubG9nKCdoZWxsbycpXG5cbiAgICByZXR1cm4gbmV4dCgpXG4gICAgLy8gdmFyIGxvZ3NDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubW9uZ29sb2cgdWwnKVxuICAgIC8vIHZhciBsb2dzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1vbmdvbG9nIGxpJylcbiAgICAvLyBpZiAobG9ncy5sZW5ndGggPiAwKSB7XG4gICAgLy8gICB2YXIgbGFzdExvZ1RpbWVzdGFtcCA9IGxvZ3NbbG9ncy5sZW5ndGggLSAxXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGltZXN0YW1wJylcbiAgICAvLyAgIGxvZ1N0cmVhbUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAvLyAgICAgcmVxdWVzdFxuICAgIC8vICAgICAgIC5nZXQod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgIC8vICAgICAgIC5xdWVyeSh7ZnJvbTogbGFzdExvZ1RpbWVzdGFtcH0pXG4gICAgLy8gICAgICAgLmFjY2VwdCgnanNvbicpXG4gICAgLy8gICAgICAgLmVuZChmdW5jdGlvbihlcnJvciwgcmVzcCl7XG4gICAgLy8gICAgICAgICBpZiAoZXJyb3IgfHwgIXJlc3Aub2sgfHwgcmVzcC5ib2R5Lmxlbmd0aCA9PT0gMClcbiAgICAvLyAgICAgICAgICAgcmV0dXJuXG4gICAgLy8gICAgICAgICB2YXIgbG9nc0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgLy8gICAgICAgICBmb3IgKHZhciBpID0gMDsgcmVzcC5ib2R5Lmxlbmd0aCA+IGk7IGkrKykge1xuICAgIC8vICAgICAgICAgICB2YXIgbmV3TG9nRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpXG4gICAgLy8gICAgICAgICAgIG5ld0xvZ0VsLnRleHRDb250ZW50ID0gcmVzcC5ib2R5W2ldLnJhd1xuICAgIC8vICAgICAgICAgICBsb2dzRnJhZ21lbnQuYXBwZW5kQ2hpbGQobmV3TG9nRWwpXG5cbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIGxhc3RMb2dUaW1lc3RhbXAgPSByZXNwLmJvZHlbcmVzcC5ib2R5Lmxlbmd0aCAtIDFdLnRpbWVzdGFtcFxuICAgIC8vICAgICAgICAgbG9nc0NvbnRhaW5lci5hcHBlbmRDaGlsZChsb2dzRnJhZ21lbnQpXG4gICAgLy8gICAgICAgfSlcbiAgICAvLyAgIH0sIDEwMDApXG4gICAgLy8gfVxuICAgIC8vIG5leHQoKVxuICB9XG4pIiwidmFyIHJvdXRlID0gcmVxdWlyZSgnY29tcG9zZS1yb3V0ZXInKVxudmFyIEJTT04gPSByZXF1aXJlKCcuLi9saWIvYnNvbicpXG4gXG4vLyBVc2VycyBpbmRleCBwYWdlLlxucm91dGUoXG4gICcvOmFjY291bnQvZGVwbG95bWVudHMvOmRlcGxveW1lbnQvbW9uZ29kYi9kYXRhYmFzZXMvOmRhdGFiYXNlL3VzZXJzJyxcbiAgdXNlcnNJbmRleFBhZ2VcbilcbnJvdXRlKFxuICAnLzphY2NvdW50L21vbmdvZGIvZGF0YWJhc2VzLzpkYXRhYmFzZS91c2VycycsXG4gIHVzZXJzSW5kZXhQYWdlXG4pXG5cbmZ1bmN0aW9uIHVzZXJzSW5kZXhQYWdlKGN0eCwgbmV4dCl7XG4gIHZhciBkb2NFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYnNvbi1jb2RlIC50YWJsZS1jZWxsJylcbiAgTWVnYXRyb24uXy5lYWNoKGRvY0VscywgZnVuY3Rpb24oZG9jRWwpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgYnNvbiA9IEJTT04udG9Cc29uU3RyaW5nKEpTT04ucGFyc2UoZG9jRWwuaW5uZXJIVE1MKSwge1xuICAgICAgICBpbmRlbnRhdGlvbjogMCxcbiAgICAgICAgaHRtbDogdHJ1ZVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEJ1Z3NuYWcgcHJvYi4uLlxuICAgIH1cbiAgICBpZiAodHlwZW9mIGJzb24gIT09ICd1bmRlZmluZWQnKVxuICAgICAgZG9jRWwuaW5uZXJIVE1MID0gYnNvblxuICB9KVxuXG4gIG5leHQoKVxufVxuIiwidmFyIFJvdXRlciA9IHJlcXVpcmUoJ3JvdXRlcycpXG52YXIgcm91dGVyID0gUm91dGVyKClcbnZhciBxcyA9IHJlcXVpcmUoJ3FzJylcblxuLy8gbm9vcCBlcnJvciBoYW5kbGVyLCBtb2RpZnkgYnkgdXNpbmcgYHJvdXRlLnNldEVycm9ySGFuZGxlcihmdW5jKWBcbnZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbigpe31cblxubW9kdWxlLmV4cG9ydHMgPSByb3V0ZVxuXG4vLyBUdXJib2xpbmtzIGZpcmVzIGEgcGFnZTpjaGFuZ2UgZXZlbnQgb24gdGhlIGRvY3VtZW50XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYWdlOmNoYW5nZScsIGZ1bmN0aW9uKCl7XG4gIC8vIERlbGF5IGlzIGZvciByZWRpcmVjdGlvbnMuLi5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgIGNhbGxIYW5kbGVyRnJvbU1hdGNoKHJvdXRlci5tYXRjaCh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpKVxuICB9LCAyNSlcbn0pXG5cbmZ1bmN0aW9uIHJvdXRlKCl7XG4gIHJvdXRlci5hZGRSb3V0ZS5hcHBseShyb3V0ZXIsIGFyZ3VtZW50cylcbn1cblxucm91dGUuc2V0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gc2V0RXJyb3JIYW5kbGVyKGZuKXtcbiAgZXJyb3JIYW5kbGVyID0gZm5cbn1cblxuZnVuY3Rpb24gYnVpbGROZXh0RnJvbU1hdGNoKG1hdGNoKXtcbiAgdmFyIG5leHQgPSBtYXRjaC5uZXh0KClcbiAgaWYgKCFuZXh0KSByZXR1cm4gaGFuZGxlTmV4dEVycm9yXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKXtcbiAgICBpZiAoZXJyb3IpIHJldHVybiBoYW5kbGVOZXh0RXJyb3IoZXJyb3IpXG4gICAgY2FsbEhhbmRsZXJGcm9tTWF0Y2gobmV4dClcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVOZXh0RXJyb3IoZXJyb3Ipe1xuICBpZiAoIWVycm9yKSByZXR1cm5cbiAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpXG4gICAgdGhyb3cgXCJQYXNzZWQgZXJyb3IgbmVlZHMgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgRXJyb3JcIlxuXG4gIGVycm9ySGFuZGxlcihlcnJvcilcbn1cblxuZnVuY3Rpb24gYnVpbGRDb250ZXh0RnJvbU1hdGNoKG1hdGNoKSB7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zOiBtYXRjaFsncGFyYW1zJ10sXG4gICAgc3BsYXRzOiBtYXRjaFsnc3BsYXRzJ10sXG4gICAgcXVlcnk6IGxvY2F0aW9uLnNlYXJjaCA/IHFzLnBhcnNlKGxvY2F0aW9uLnNlYXJjaC5zbGljZSgxKSkgOiB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIYW5kbGVyRnJvbU1hdGNoKG1hdGNoKSB7XG4gIGlmICghbWF0Y2gpIHJldHVyblxuICBtYXRjaC5mbi5jYWxsKG51bGwsIGJ1aWxkQ29udGV4dEZyb21NYXRjaChtYXRjaCksIGJ1aWxkTmV4dEZyb21NYXRjaChtYXRjaCkpXG59XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5yb3V0ZXM9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbnZhciBsb2NhbFJvdXRlcyA9IFtdO1xuXG5cbi8qKlxuICogQ29udmVydCBwYXRoIHRvIHJvdXRlIG9iamVjdFxuICpcbiAqIEEgc3RyaW5nIG9yIFJlZ0V4cCBzaG91bGQgYmUgcGFzc2VkLFxuICogd2lsbCByZXR1cm4geyByZSwgc3JjLCBrZXlzfSBvYmpcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmcgLyBSZWdFeHB9IHBhdGhcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG52YXIgUm91dGUgPSBmdW5jdGlvbihwYXRoKXtcbiAgLy91c2luZyAnbmV3JyBpcyBvcHRpb25hbFxuXG4gIHZhciBzcmMsIHJlLCBrZXlzID0gW107XG5cbiAgaWYocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCl7XG4gICAgcmUgPSBwYXRoO1xuICAgIHNyYyA9IHBhdGgudG9TdHJpbmcoKTtcbiAgfWVsc2V7XG4gICAgcmUgPSBwYXRoVG9SZWdFeHAocGF0aCwga2V5cyk7XG4gICAgc3JjID0gcGF0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gIFx0IHJlOiByZSxcbiAgXHQgc3JjOiBwYXRoLnRvU3RyaW5nKCksXG4gIFx0IGtleXM6IGtleXNcbiAgfVxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLFxuICogcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IHNob3VsZCBiZSBwYXNzZWQsXG4gKiB3aGljaCB3aWxsIGNvbnRhaW4gdGhlIHBsYWNlaG9sZGVyXG4gKiBrZXkgbmFtZXMuIEZvciBleGFtcGxlIFwiL3VzZXIvOmlkXCIgd2lsbFxuICogdGhlbiBjb250YWluIFtcImlkXCJdLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9IGtleXNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xudmFyIHBhdGhUb1JlZ0V4cCA9IGZ1bmN0aW9uIChwYXRoLCBrZXlzKSB7XG5cdHBhdGggPSBwYXRoXG5cdFx0LmNvbmNhdCgnLz8nKVxuXHRcdC5yZXBsYWNlKC9cXC9cXCgvZywgJyg/Oi8nKVxuXHRcdC5yZXBsYWNlKC8oXFwvKT8oXFwuKT86KFxcdyspKD86KFxcKC4qP1xcKSkpPyhcXD8pP3xcXCovZywgZnVuY3Rpb24oXywgc2xhc2gsIGZvcm1hdCwga2V5LCBjYXB0dXJlLCBvcHRpb25hbCl7XG5cdFx0XHRpZiAoXyA9PT0gXCIqXCIpe1xuXHRcdFx0XHRrZXlzLnB1c2godW5kZWZpbmVkKTtcblx0XHRcdFx0cmV0dXJuIF87XG5cdFx0XHR9XG5cblx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0c2xhc2ggPSBzbGFzaCB8fCAnJztcblx0XHRcdHJldHVybiAnJ1xuXHRcdFx0XHQrIChvcHRpb25hbCA/ICcnIDogc2xhc2gpXG5cdFx0XHRcdCsgJyg/Oidcblx0XHRcdFx0KyAob3B0aW9uYWwgPyBzbGFzaCA6ICcnKVxuXHRcdFx0XHQrIChmb3JtYXQgfHwgJycpICsgKGNhcHR1cmUgfHwgJyhbXi9dKz8pJykgKyAnKSdcblx0XHRcdFx0KyAob3B0aW9uYWwgfHwgJycpO1xuXHRcdH0pXG5cdFx0LnJlcGxhY2UoLyhbXFwvLl0pL2csICdcXFxcJDEnKVxuXHRcdC5yZXBsYWNlKC9cXCovZywgJyguKiknKTtcblx0cmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcGF0aCArICckJywgJ2knKTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdCB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVxdWVzdCB0b1xuICogb25lIG9mIHRoZSByb3V0ZXMuIFdoZW4gc3VjY2Vzc2Z1bFxuICogYSAge2ZuLCBwYXJhbXMsIHNwbGF0c30gb2JqIGlzIHJldHVybmVkXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IHJvdXRlc1xuICogQHBhcmFtICB7U3RyaW5nfSB1cmlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIG1hdGNoID0gZnVuY3Rpb24gKHJvdXRlcywgdXJpLCBzdGFydEF0KSB7XG5cdHZhciBjYXB0dXJlcywgaSA9IHN0YXJ0QXQgfHwgMDtcblxuXHRmb3IgKHZhciBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHR2YXIgcm91dGUgPSByb3V0ZXNbaV0sXG5cdFx0ICAgIHJlID0gcm91dGUucmUsXG5cdFx0ICAgIGtleXMgPSByb3V0ZS5rZXlzLFxuXHRcdCAgICBzcGxhdHMgPSBbXSxcblx0XHQgICAgcGFyYW1zID0ge307XG5cblx0XHRpZiAoY2FwdHVyZXMgPSB1cmkubWF0Y2gocmUpKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMSwgbGVuID0gY2FwdHVyZXMubGVuZ3RoOyBqIDwgbGVuOyArK2opIHtcblx0XHRcdFx0dmFyIGtleSA9IGtleXNbai0xXSxcblx0XHRcdFx0XHR2YWwgPSB0eXBlb2YgY2FwdHVyZXNbal0gPT09ICdzdHJpbmcnXG5cdFx0XHRcdFx0XHQ/IHVuZXNjYXBlKGNhcHR1cmVzW2pdKVxuXHRcdFx0XHRcdFx0OiBjYXB0dXJlc1tqXTtcblx0XHRcdFx0aWYgKGtleSkge1xuXHRcdFx0XHRcdHBhcmFtc1trZXldID0gdmFsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNwbGF0cy5wdXNoKHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHBhcmFtczogcGFyYW1zLFxuXHRcdFx0XHRzcGxhdHM6IHNwbGF0cyxcblx0XHRcdFx0cm91dGU6IHJvdXRlLnNyYyxcblx0XHRcdFx0bmV4dDogaSArIDFcblx0XHRcdH07XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcbiAqIERlZmF1bHQgXCJub3JtYWxcIiByb3V0ZXIgY29uc3RydWN0b3IuXG4gKiBhY2NlcHRzIHBhdGgsIGZuIHR1cGxlcyB2aWEgYWRkUm91dGVcbiAqIHJldHVybnMge2ZuLCBwYXJhbXMsIHNwbGF0cywgcm91dGV9XG4gKiAgdmlhIG1hdGNoXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbnZhciBSb3V0ZXIgPSBmdW5jdGlvbigpe1xuICAvL3VzaW5nICduZXcnIGlzIG9wdGlvbmFsXG4gIHJldHVybiB7XG4gICAgcm91dGVzOiBbXSxcbiAgICByb3V0ZU1hcCA6IHt9LFxuICAgIGFkZFJvdXRlOiBmdW5jdGlvbihwYXRoLCBmbil7XG4gICAgICBpZiAoIXBhdGgpIHRocm93IG5ldyBFcnJvcignIHJvdXRlIHJlcXVpcmVzIGEgcGF0aCcpO1xuICAgICAgaWYgKCFmbikgdGhyb3cgbmV3IEVycm9yKCcgcm91dGUgJyArIHBhdGgudG9TdHJpbmcoKSArICcgcmVxdWlyZXMgYSBjYWxsYmFjaycpO1xuXG4gICAgICB2YXIgcm91dGUgPSBSb3V0ZShwYXRoKTtcbiAgICAgIHJvdXRlLmZuID0gZm47XG5cbiAgICAgIHRoaXMucm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgdGhpcy5yb3V0ZU1hcFtwYXRoXSA9IGZuO1xuICAgIH0sXG5cbiAgICBtYXRjaDogZnVuY3Rpb24ocGF0aG5hbWUsIHN0YXJ0QXQpe1xuICAgICAgdmFyIHJvdXRlID0gbWF0Y2godGhpcy5yb3V0ZXMsIHBhdGhuYW1lLCBzdGFydEF0KTtcbiAgICAgIGlmKHJvdXRlKXtcbiAgICAgICAgcm91dGUuZm4gPSB0aGlzLnJvdXRlTWFwW3JvdXRlLnJvdXRlXTtcbiAgICAgICAgcm91dGUubmV4dCA9IHRoaXMubWF0Y2guYmluZCh0aGlzLCBwYXRobmFtZSwgcm91dGUubmV4dClcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9XG4gIH1cbn07XG5cblJvdXRlci5Sb3V0ZSA9IFJvdXRlXG5Sb3V0ZXIucGF0aFRvUmVnRXhwID0gcGF0aFRvUmVnRXhwXG5Sb3V0ZXIubWF0Y2ggPSBtYXRjaFxuLy8gYmFjayBjb21wYXRcblJvdXRlci5Sb3V0ZXIgPSBSb3V0ZXJcblxubW9kdWxlLmV4cG9ydHMgPSBSb3V0ZXJcblxufSx7fV19LHt9LFsxXSlcbigxKVxufSk7XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUwyNXZaR1ZmYlc5a2RXeGxjeTlqYjIxd2IzTmxMWEp2ZFhSbGNpOXViMlJsWDIxdlpIVnNaWE12Y205MWRHVnpMMlJwYzNRdmNtOTFkR1Z6TG1weklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lJV1oxYm1OMGFXOXVLR1VwZTJsbUtGd2liMkpxWldOMFhDSTlQWFI1Y0dWdlppQmxlSEJ2Y25SektXMXZaSFZzWlM1bGVIQnZjblJ6UFdVb0tUdGxiSE5sSUdsbUtGd2lablZ1WTNScGIyNWNJajA5ZEhsd1pXOW1JR1JsWm1sdVpTWW1aR1ZtYVc1bExtRnRaQ2xrWldacGJtVW9aU2s3Wld4elpYdDJZWElnWmp0Y0luVnVaR1ZtYVc1bFpGd2lJVDEwZVhCbGIyWWdkMmx1Wkc5M1AyWTlkMmx1Wkc5M09sd2lkVzVrWldacGJtVmtYQ0loUFhSNWNHVnZaaUJuYkc5aVlXdy9aajFuYkc5aVlXdzZYQ0oxYm1SbFptbHVaV1JjSWlFOWRIbHdaVzltSUhObGJHWW1KaWhtUFhObGJHWXBMR1l1Y205MWRHVnpQV1VvS1gxOUtHWjFibU4wYVc5dUtDbDdkbUZ5SUdSbFptbHVaU3h0YjJSMWJHVXNaWGh3YjNKMGN6dHlaWFIxY200Z0tHWjFibU4wYVc5dUlHVW9kQ3h1TEhJcGUyWjFibU4wYVc5dUlITW9ieXgxS1h0cFppZ2hibHR2WFNsN2FXWW9JWFJiYjEwcGUzWmhjaUJoUFhSNWNHVnZaaUJ5WlhGMWFYSmxQVDFjSW1aMWJtTjBhVzl1WENJbUpuSmxjWFZwY21VN2FXWW9JWFVtSm1FcGNtVjBkWEp1SUdFb2J5d2hNQ2s3YVdZb2FTbHlaWFIxY200Z2FTaHZMQ0V3S1R0MGFISnZkeUJ1WlhjZ1JYSnliM0lvWENKRFlXNXViM1FnWm1sdVpDQnRiMlIxYkdVZ0oxd2lLMjhyWENJblhDSXBmWFpoY2lCbVBXNWJiMTA5ZTJWNGNHOXlkSE02ZTMxOU8zUmJiMTFiTUYwdVkyRnNiQ2htTG1WNGNHOXlkSE1zWm5WdVkzUnBiMjRvWlNsN2RtRnlJRzQ5ZEZ0dlhWc3hYVnRsWFR0eVpYUjFjbTRnY3lodVAyNDZaU2w5TEdZc1ppNWxlSEJ2Y25SekxHVXNkQ3h1TEhJcGZYSmxkSFZ5YmlCdVcyOWRMbVY0Y0c5eWRITjlkbUZ5SUdrOWRIbHdaVzltSUhKbGNYVnBjbVU5UFZ3aVpuVnVZM1JwYjI1Y0lpWW1jbVZ4ZFdseVpUdG1iM0lvZG1GeUlHODlNRHR2UEhJdWJHVnVaM1JvTzI4ckt5bHpLSEpiYjEwcE8zSmxkSFZ5YmlCemZTa29lekU2VzJaMWJtTjBhVzl1S0Y5a1pYSmxjVjhzYlc5a2RXeGxMR1Y0Y0c5eWRITXBlMXh1WEc1MllYSWdiRzlqWVd4U2IzVjBaWE1nUFNCYlhUdGNibHh1WEc0dktpcGNiaUFxSUVOdmJuWmxjblFnY0dGMGFDQjBieUJ5YjNWMFpTQnZZbXBsWTNSY2JpQXFYRzRnS2lCQklITjBjbWx1WnlCdmNpQlNaV2RGZUhBZ2MyaHZkV3hrSUdKbElIQmhjM05sWkN4Y2JpQXFJSGRwYkd3Z2NtVjBkWEp1SUhzZ2NtVXNJSE55WXl3Z2EyVjVjMzBnYjJKcVhHNGdLbHh1SUNvZ1FIQmhjbUZ0SUNCN1UzUnlhVzVuSUM4Z1VtVm5SWGh3ZlNCd1lYUm9YRzRnS2lCQWNtVjBkWEp1SUh0UFltcGxZM1I5WEc0Z0tpOWNibHh1ZG1GeUlGSnZkWFJsSUQwZ1puVnVZM1JwYjI0b2NHRjBhQ2w3WEc0Z0lDOHZkWE5wYm1jZ0oyNWxkeWNnYVhNZ2IzQjBhVzl1WVd4Y2JseHVJQ0IyWVhJZ2MzSmpMQ0J5WlN3Z2EyVjVjeUE5SUZ0ZE8xeHVYRzRnSUdsbUtIQmhkR2dnYVc1emRHRnVZMlZ2WmlCU1pXZEZlSEFwZTF4dUlDQWdJSEpsSUQwZ2NHRjBhRHRjYmlBZ0lDQnpjbU1nUFNCd1lYUm9MblJ2VTNSeWFXNW5LQ2s3WEc0Z0lIMWxiSE5sZTF4dUlDQWdJSEpsSUQwZ2NHRjBhRlJ2VW1WblJYaHdLSEJoZEdnc0lHdGxlWE1wTzF4dUlDQWdJSE55WXlBOUlIQmhkR2c3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnZTF4dUlDQmNkQ0J5WlRvZ2NtVXNYRzRnSUZ4MElITnlZem9nY0dGMGFDNTBiMU4wY21sdVp5Z3BMRnh1SUNCY2RDQnJaWGx6T2lCclpYbHpYRzRnSUgxY2JuMDdYRzVjYmk4cUtseHVJQ29nVG05eWJXRnNhWHBsSUhSb1pTQm5hWFpsYmlCd1lYUm9JSE4wY21sdVp5eGNiaUFxSUhKbGRIVnlibWx1WnlCaElISmxaM1ZzWVhJZ1pYaHdjbVZ6YzJsdmJpNWNiaUFxWEc0Z0tpQkJiaUJsYlhCMGVTQmhjbkpoZVNCemFHOTFiR1FnWW1VZ2NHRnpjMlZrTEZ4dUlDb2dkMmhwWTJnZ2QybHNiQ0JqYjI1MFlXbHVJSFJvWlNCd2JHRmpaV2h2YkdSbGNseHVJQ29nYTJWNUlHNWhiV1Z6TGlCR2IzSWdaWGhoYlhCc1pTQmNJaTkxYzJWeUx6cHBaRndpSUhkcGJHeGNiaUFxSUhSb1pXNGdZMjl1ZEdGcGJpQmJYQ0pwWkZ3aVhTNWNiaUFxWEc0Z0tpQkFjR0Z5WVcwZ0lIdFRkSEpwYm1kOUlIQmhkR2hjYmlBcUlFQndZWEpoYlNBZ2UwRnljbUY1ZlNCclpYbHpYRzRnS2lCQWNtVjBkWEp1SUh0U1pXZEZlSEI5WEc0Z0tpOWNiblpoY2lCd1lYUm9WRzlTWldkRmVIQWdQU0JtZFc1amRHbHZiaUFvY0dGMGFDd2dhMlY1Y3lrZ2UxeHVYSFJ3WVhSb0lEMGdjR0YwYUZ4dVhIUmNkQzVqYjI1allYUW9KeTgvSnlsY2JseDBYSFF1Y21Wd2JHRmpaU2d2WEZ3dlhGd29MMmNzSUNjb1B6b3ZKeWxjYmx4MFhIUXVjbVZ3YkdGalpTZ3ZLRnhjTHlrL0tGeGNMaWsvT2loY1hIY3JLU2cvT2loY1hDZ3VLajljWENrcEtUOG9YRncvS1Q5OFhGd3FMMmNzSUdaMWJtTjBhVzl1S0Y4c0lITnNZWE5vTENCbWIzSnRZWFFzSUd0bGVTd2dZMkZ3ZEhWeVpTd2diM0IwYVc5dVlXd3BlMXh1WEhSY2RGeDBhV1lnS0Y4Z1BUMDlJRndpS2x3aUtYdGNibHgwWEhSY2RGeDBhMlY1Y3k1d2RYTm9LSFZ1WkdWbWFXNWxaQ2s3WEc1Y2RGeDBYSFJjZEhKbGRIVnliaUJmTzF4dVhIUmNkRngwZlZ4dVhHNWNkRngwWEhSclpYbHpMbkIxYzJnb2EyVjVLVHRjYmx4MFhIUmNkSE5zWVhOb0lEMGdjMnhoYzJnZ2ZId2dKeWM3WEc1Y2RGeDBYSFJ5WlhSMWNtNGdKeWRjYmx4MFhIUmNkRngwS3lBb2IzQjBhVzl1WVd3Z1B5QW5KeUE2SUhOc1lYTm9LVnh1WEhSY2RGeDBYSFFySUNjb1B6b25YRzVjZEZ4MFhIUmNkQ3NnS0c5d2RHbHZibUZzSUQ4Z2MyeGhjMmdnT2lBbkp5bGNibHgwWEhSY2RGeDBLeUFvWm05eWJXRjBJSHg4SUNjbktTQXJJQ2hqWVhCMGRYSmxJSHg4SUNjb1cxNHZYU3MvS1NjcElDc2dKeWtuWEc1Y2RGeDBYSFJjZENzZ0tHOXdkR2x2Ym1Gc0lIeDhJQ2NuS1R0Y2JseDBYSFI5S1Z4dVhIUmNkQzV5WlhCc1lXTmxLQzhvVzF4Y0x5NWRLUzluTENBblhGeGNYQ1F4SnlsY2JseDBYSFF1Y21Wd2JHRmpaU2d2WEZ3cUwyY3NJQ2NvTGlvcEp5azdYRzVjZEhKbGRIVnliaUJ1WlhjZ1VtVm5SWGh3S0NkZUp5QXJJSEJoZEdnZ0t5QW5KQ2NzSUNkcEp5azdYRzU5TzF4dVhHNHZLaXBjYmlBcUlFRjBkR1Z0Y0hRZ2RHOGdiV0YwWTJnZ2RHaGxJR2RwZG1WdUlISmxjWFZsYzNRZ2RHOWNiaUFxSUc5dVpTQnZaaUIwYUdVZ2NtOTFkR1Z6TGlCWGFHVnVJSE4xWTJObGMzTm1kV3hjYmlBcUlHRWdJSHRtYml3Z2NHRnlZVzF6TENCemNHeGhkSE45SUc5aWFpQnBjeUJ5WlhSMWNtNWxaRnh1SUNwY2JpQXFJRUJ3WVhKaGJTQWdlMEZ5Y21GNWZTQnliM1YwWlhOY2JpQXFJRUJ3WVhKaGJTQWdlMU4wY21sdVozMGdkWEpwWEc0Z0tpQkFjbVYwZFhKdUlIdFBZbXBsWTNSOVhHNGdLaTljYm5aaGNpQnRZWFJqYUNBOUlHWjFibU4wYVc5dUlDaHliM1YwWlhNc0lIVnlhU3dnYzNSaGNuUkJkQ2tnZTF4dVhIUjJZWElnWTJGd2RIVnlaWE1zSUdrZ1BTQnpkR0Z5ZEVGMElIeDhJREE3WEc1Y2JseDBabTl5SUNoMllYSWdiR1Z1SUQwZ2NtOTFkR1Z6TG14bGJtZDBhRHNnYVNBOElHeGxianNnS3l0cEtTQjdYRzVjZEZ4MGRtRnlJSEp2ZFhSbElEMGdjbTkxZEdWelcybGRMRnh1WEhSY2RDQWdJQ0J5WlNBOUlISnZkWFJsTG5KbExGeHVYSFJjZENBZ0lDQnJaWGx6SUQwZ2NtOTFkR1V1YTJWNWN5eGNibHgwWEhRZ0lDQWdjM0JzWVhSeklEMGdXMTBzWEc1Y2RGeDBJQ0FnSUhCaGNtRnRjeUE5SUh0OU8xeHVYRzVjZEZ4MGFXWWdLR05oY0hSMWNtVnpJRDBnZFhKcExtMWhkR05vS0hKbEtTa2dlMXh1WEhSY2RGeDBabTl5SUNoMllYSWdhaUE5SURFc0lHeGxiaUE5SUdOaGNIUjFjbVZ6TG14bGJtZDBhRHNnYWlBOElHeGxianNnS3l0cUtTQjdYRzVjZEZ4MFhIUmNkSFpoY2lCclpYa2dQU0JyWlhselcyb3RNVjBzWEc1Y2RGeDBYSFJjZEZ4MGRtRnNJRDBnZEhsd1pXOW1JR05oY0hSMWNtVnpXMnBkSUQwOVBTQW5jM1J5YVc1bkoxeHVYSFJjZEZ4MFhIUmNkRngwUHlCMWJtVnpZMkZ3WlNoallYQjBkWEpsYzF0cVhTbGNibHgwWEhSY2RGeDBYSFJjZERvZ1kyRndkSFZ5WlhOYmFsMDdYRzVjZEZ4MFhIUmNkR2xtSUNoclpYa3BJSHRjYmx4MFhIUmNkRngwWEhSd1lYSmhiWE5iYTJWNVhTQTlJSFpoYkR0Y2JseDBYSFJjZEZ4MGZTQmxiSE5sSUh0Y2JseDBYSFJjZEZ4MFhIUnpjR3hoZEhNdWNIVnphQ2gyWVd3cE8xeHVYSFJjZEZ4MFhIUjlYRzVjZEZ4MFhIUjlYRzVjZEZ4MFhIUnlaWFIxY200Z2UxeHVYSFJjZEZ4MFhIUndZWEpoYlhNNklIQmhjbUZ0Y3l4Y2JseDBYSFJjZEZ4MGMzQnNZWFJ6T2lCemNHeGhkSE1zWEc1Y2RGeDBYSFJjZEhKdmRYUmxPaUJ5YjNWMFpTNXpjbU1zWEc1Y2RGeDBYSFJjZEc1bGVIUTZJR2tnS3lBeFhHNWNkRngwWEhSOU8xeHVYSFJjZEgxY2JseDBmVnh1ZlR0Y2JseHVMeW9xWEc0Z0tpQkVaV1poZFd4MElGd2libTl5YldGc1hDSWdjbTkxZEdWeUlHTnZibk4wY25WamRHOXlMbHh1SUNvZ1lXTmpaWEIwY3lCd1lYUm9MQ0JtYmlCMGRYQnNaWE1nZG1saElHRmtaRkp2ZFhSbFhHNGdLaUJ5WlhSMWNtNXpJSHRtYml3Z2NHRnlZVzF6TENCemNHeGhkSE1zSUhKdmRYUmxmVnh1SUNvZ0lIWnBZU0J0WVhSamFGeHVJQ3BjYmlBcUlFQnlaWFIxY200Z2UwOWlhbVZqZEgxY2JpQXFMMXh1WEc1MllYSWdVbTkxZEdWeUlEMGdablZ1WTNScGIyNG9LWHRjYmlBZ0x5OTFjMmx1WnlBbmJtVjNKeUJwY3lCdmNIUnBiMjVoYkZ4dUlDQnlaWFIxY200Z2UxeHVJQ0FnSUhKdmRYUmxjem9nVzEwc1hHNGdJQ0FnY205MWRHVk5ZWEFnT2lCN2ZTeGNiaUFnSUNCaFpHUlNiM1YwWlRvZ1puVnVZM1JwYjI0b2NHRjBhQ3dnWm00cGUxeHVJQ0FnSUNBZ2FXWWdLQ0Z3WVhSb0tTQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0p5QnliM1YwWlNCeVpYRjFhWEpsY3lCaElIQmhkR2duS1R0Y2JpQWdJQ0FnSUdsbUlDZ2habTRwSUhSb2NtOTNJRzVsZHlCRmNuSnZjaWduSUhKdmRYUmxJQ2NnS3lCd1lYUm9MblJ2VTNSeWFXNW5LQ2tnS3lBbklISmxjWFZwY21WeklHRWdZMkZzYkdKaFkyc25LVHRjYmx4dUlDQWdJQ0FnZG1GeUlISnZkWFJsSUQwZ1VtOTFkR1VvY0dGMGFDazdYRzRnSUNBZ0lDQnliM1YwWlM1bWJpQTlJR1p1TzF4dVhHNGdJQ0FnSUNCMGFHbHpMbkp2ZFhSbGN5NXdkWE5vS0hKdmRYUmxLVHRjYmlBZ0lDQWdJSFJvYVhNdWNtOTFkR1ZOWVhCYmNHRjBhRjBnUFNCbWJqdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ2JXRjBZMmc2SUdaMWJtTjBhVzl1S0hCaGRHaHVZVzFsTENCemRHRnlkRUYwS1h0Y2JpQWdJQ0FnSUhaaGNpQnliM1YwWlNBOUlHMWhkR05vS0hSb2FYTXVjbTkxZEdWekxDQndZWFJvYm1GdFpTd2djM1JoY25SQmRDazdYRzRnSUNBZ0lDQnBaaWh5YjNWMFpTbDdYRzRnSUNBZ0lDQWdJSEp2ZFhSbExtWnVJRDBnZEdocGN5NXliM1YwWlUxaGNGdHliM1YwWlM1eWIzVjBaVjA3WEc0Z0lDQWdJQ0FnSUhKdmRYUmxMbTVsZUhRZ1BTQjBhR2x6TG0xaGRHTm9MbUpwYm1Rb2RHaHBjeXdnY0dGMGFHNWhiV1VzSUhKdmRYUmxMbTVsZUhRcFhHNGdJQ0FnSUNCOVhHNGdJQ0FnSUNCeVpYUjFjbTRnY205MWRHVTdYRzRnSUNBZ2ZWeHVJQ0I5WEc1OU8xeHVYRzVTYjNWMFpYSXVVbTkxZEdVZ1BTQlNiM1YwWlZ4dVVtOTFkR1Z5TG5CaGRHaFViMUpsWjBWNGNDQTlJSEJoZEdoVWIxSmxaMFY0Y0Z4dVVtOTFkR1Z5TG0xaGRHTm9JRDBnYldGMFkyaGNiaTh2SUdKaFkyc2dZMjl0Y0dGMFhHNVNiM1YwWlhJdVVtOTFkR1Z5SUQwZ1VtOTFkR1Z5WEc1Y2JtMXZaSFZzWlM1bGVIQnZjblJ6SUQwZ1VtOTFkR1Z5WEc1Y2JuMHNlMzFkZlN4N2ZTeGJNVjBwWEc0b01TbGNibjBwT3lKZGZRPT0iLCJ2YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy9idXR0b24uaGJzJylcblxueHRhZy5yZWdpc3RlcignY29tcG9zZS1zaGVsbC1idXR0b24nLCB7XG4gIGxpZmVjeWNsZToge1xuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLnR5cGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpXG4gICAgICB0aGlzLmlubmVySFRNTCA9IHRlbXBsYXRlKHtcbiAgICAgICAgZW5hYmxlZDogdGhpcy5lbmFibGVkLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMudGV4dENvbnRlbnRcbiAgICAgIH0pXG4gICAgfSxcbiAgICBpbnNlcnRlZDogZnVuY3Rpb24oKXtcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdzdWJtaXQnKVxuICAgICAgICB0aGlzLnNoZWxsLnJlZ2lzdGVyQnV0dG9uKHRoaXMpXG4gICAgfVxuICB9LFxuXG4gIGV2ZW50czoge1xuICAgICdjbGljazpkZWxlZ2F0ZShidXR0b24pJzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0XG4gICAgICBidXR0b24uY2hpbGRyZW5bMF0uYmx1cigpXG4gICAgICBpZiAoYnV0dG9uLnR5cGUgPT09ICdzdWJtaXQnKVxuICAgICAgICByZXR1cm5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuZW5hYmxlZCA9ICFldmVudC5jdXJyZW50VGFyZ2V0LmVuYWJsZWRcbiAgICAgIHh0YWcuZmlyZUV2ZW50KGJ1dHRvbiwgJ3RvZ2dsZScpXG4gICAgfVxuICB9LFxuXG4gIGFjY2Vzc29yczoge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuICEhdGhpcy5nZXRBdHRyaWJ1dGUoJ2VuYWJsZWQnKSB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihlbmFibGVkKXtcbiAgICAgICAgaWYgKGVuYWJsZWQgPT09IHRydWUpXG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2VuYWJsZWQnLCB0cnVlKVxuICAgICAgICBlbHNlIGlmIChlbmFibGVkID09PSBmYWxzZSlcbiAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnZW5hYmxlZCcpXG4gICAgICB9XG4gICAgfSxcbiAgICB0b2dnbGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0b2dnbGUnKSB9XG4gICAgfVxuICB9XG59KVxuIiwidmFyIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZXMvcGFyYW0uaGJzJylcbnZhciBCU09OID0gcmVxdWlyZSgnLi9saWIvYnNvbicpXG52YXIgY3NzQW5pbUV2ZW50VHlwZXMgPSByZXF1aXJlKCcuL2xpYi9hbmltLWV2ZW50cycpXG5cbnh0YWcucmVnaXN0ZXIoJ2NvbXBvc2Utc2hlbGwtcGFyYW0nLCB7XG4gIGxpZmVjeWNsZToge1xuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLnBhcmFtcyA9IHh0YWcucXVlcnlDaGlsZHJlbih0aGlzLCAnY29tcG9zZS1zaGVsbC1wYXJhbScpXG4gICAgICB0aGlzLmdyb3VwID0gISF0aGlzLnBhcmFtcy5sZW5ndGhcblxuICAgICAgdGhpcy5pbm5lckhUTUwgPSB0ZW1wbGF0ZSh7XG4gICAgICAgIGJlZm9yZTogdGhpcy5nZXRBdHRyaWJ1dGUoJ2JlZm9yZScpLFxuICAgICAgICBncm91cDogdGhpcy5ncm91cCxcbiAgICAgICAgZWRpdGFibGU6IHRoaXMuZWRpdGFibGUsXG4gICAgICAgIHZhbHVlOiB0aGlzLnBhcnNlVmFsdWUodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykpLFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMudGV4dENvbnRlbnQsXG4gICAgICAgIGFmdGVyOiB0aGlzLmdldEF0dHJpYnV0ZSgnYWZ0ZXInKSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucGxhY2Vob2xkZXJcbiAgICAgIH0pXG4gICAgfSxcbiAgICBpbnNlcnRlZDogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMuaGlkZSgpXG5cbiAgICAgIGlmICh0aGlzLnBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBncm91cEVsID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcucGFyYW1zLWdyb3VwJylcbiAgICAgICAgZm9yICh2YXIgcGFyYW0gaW4gdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAvLyB0aGlzLm9uU2hlbGxTZXQucHVzaChmdW5jdGlvbigpe1xuICAgICAgICAgIC8vICAgdGhpcy5wYXJhbXNbcGFyYW1dLnNoZWxsID0gdGhpcy5zaGVsbFxuICAgICAgICAgIC8vIH0pXG4gICAgICAgICAgdGhpcy5wYXJhbXNbcGFyYW1dLnNoZWxsID0gdGhpcy5zaGVsbFxuICAgICAgICAgIHRoaXMucGFyYW1zW3BhcmFtXS5hZGRFdmVudExpc3RlbmVyKCdzaG93JywgdGhpcy51cGRhdGVWaXNpYmlsaXR5LmJpbmQodGhpcykpXG4gICAgICAgICAgdGhpcy5wYXJhbXNbcGFyYW1dLmFkZEV2ZW50TGlzdGVuZXIoJ2hpZGUnLCB0aGlzLnVwZGF0ZVZpc2liaWxpdHkuYmluZCh0aGlzKSlcbiAgICAgICAgICBncm91cEVsLmFwcGVuZENoaWxkKHRoaXMucGFyYW1zW3BhcmFtXSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50eXBlKVxuICAgICAgICB0aGlzLnNoZWxsLnJlZ2lzdGVyUGFyYW0odGhpcykvLyB0aGlzLm9uU2hlbGxTZXQgPSBbZnVuY3Rpb24oKXt0aGlzLnNoZWxsLnJlZ2lzdGVyUGFyYW0odGhpcyl9XS5jb25jYXQodGhpcy5vblNoZWxsU2V0KVxuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAndGV4dCcgfHwgKHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8IHRoaXMucmVxdWlyZWQpKVxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlXG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2ZvY3VzJykpXG4gICAgICAgIHRoaXMuZm9jdXNJbnB1dCgpXG4gICAgfVxuICB9LFxuXG4gIGV2ZW50czoge1xuICAgICdmb2N1czpkZWxlZ2F0ZShzcGFuW2NvbnRlbnRlZGl0YWJsZV0pJzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBwYXJhbSA9IGV2ZW50LmN1cnJlbnRUYXJnZXRcbiAgICAgIGlmIChwYXJhbS5ncm91cCkgcmV0dXJuXG4gICAgICBpZiAocGFyYW0ucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dENvbnRlbnQgPT09IHBhcmFtLnBsYWNlaG9sZGVyICYmIC9wbGFjZWhvbGRlci8udGVzdCh0aGlzLmNsYXNzTmFtZSkpXG4gICAgICAgICAgdGhpcy50ZXh0Q29udGVudCA9ICcnXG4gICAgICB9XG4gICAgICBwYXJhbS5zZXRDdXJzb3JBdEVuZCgpXG4gICAgfSxcbiAgICAnYmx1cjpkZWxlZ2F0ZShzcGFuW2NvbnRlbnRlZGl0YWJsZV0pJzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBwYXJhbSA9IGV2ZW50LmN1cnJlbnRUYXJnZXRcbiAgICAgIGlmIChwYXJhbS5ncm91cCkgcmV0dXJuXG4gICAgICBpZiAocGFyYW0ucGxhY2Vob2xkZXIpXG4gICAgICAgIGlmICh0aGlzLnRleHRDb250ZW50ID09PSAnJykge1xuICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBwYXJhbS5wbGFjZWhvbGRlclxuICAgICAgICAgIGlmICghL3BsYWNlaG9sZGVyLy50ZXN0KHRoaXMuY2xhc3NOYW1lKSlcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lICs9ICcgcGxhY2Vob2xkZXInXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKCdwbGFjZWhvbGRlcicsICcnKVxuICAgICAgICB9XG4gICAgfSxcbiAgICAncGFzdGU6ZGVsZWdhdGUoc3Bhbltjb250ZW50ZWRpdGFibGVdKSc6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIHZhciBwYXJhbSA9IGV2ZW50LmN1cnJlbnRUYXJnZXRcbiAgICAgIGlmIChwYXJhbS5ncm91cCkgcmV0dXJuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBpZiAoZXZlbnQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICB2YXIgY29udGVudCA9IChldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50KS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydFRleHQnLCBmYWxzZSwgY29udGVudClcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHdpbmRvdy5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gd2luZG93LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgnVGV4dCcpLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxuICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5wYXN0ZUhUTUwoY29udGVudClcbiAgICAgIH1cblxuICAgIH0sXG4gICAgc2hvdzogZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgaWYgKHRoaXMuaGludClcbiAgICAgICAgdGhpcy5zaG93SGludCgpXG4gICAgfVxuICB9LFxuXG4gIGFjY2Vzc29yczoge1xuICAgIC8vIHBhcmFtczogeyBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB4dGFnLnF1ZXJ5Q2hpbGRyZW4odGhpcywgJ2NvbXBvc2Utc2hlbGwtcGFyYW0nKSB9IH0sXG4gICAgbmFtZTogeyBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnbmFtZScpIH0gfSxcbiAgICB0eXBlOiB7IGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykgfSB9LFxuICAgIHBsYWNlaG9sZGVyOiB7IGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpIH0gfSxcbiAgICBoaW50OiB7IGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdoaW50JykgfSB9LFxuICAgIHJlcXVpcmVkOiB7IGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpIH0gfSxcbiAgICBmb2N1czogICAgeyBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZm9jdXMnKSB9IH0sXG4gICAgLy8gZ3JvdXA6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucGFyYW1zLmxlbmd0aCA+IDAgfSB9LFxuICAgIGVkaXRhYmxlOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAhdGhpcy5ncm91cCAmJiB0aGlzLnR5cGUgJiYgdGhpcy50eXBlICE9PSAnYm9vbGVhbicgfSB9LFxuICAgIG9wdGlvbmFsOiB7IGdldDogZnVuY3Rpb24oKXsgcmV0dXJuICEhdGhpcy5nZXRBdHRyaWJ1dGUoJ29wdGlvbmFsJykgfSB9LFxuICAgIGRlcGVuZGVuY3k6IHsgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RlcGVuZGVuY3knKSB9IH0sXG4gICAgY3VzdG9tSW5wdXQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc3Bhbltjb250ZW50ZWRpdGFibGVdJykgfSB9LFxuICAgIHBhcnNlcjogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhcnNlcicpIH0gfSxcbiAgICB2aXNpYmxlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ2hpZGRlbicpIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZpc2libGUpe1xuICAgICAgICBpZiAodmlzaWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgICAgIHh0YWcuZmlyZUV2ZW50KHRoaXMsICdzaG93JylcbiAgICAgICAgfSBlbHNlIGlmICh2aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgIHh0YWcuZmlyZUV2ZW50KHRoaXMsICdoaWRlJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWx1ZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdmFsO1xuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSlcbiAgICAgICAgICByZXR1cm4gbnVsbCAvLyBubyB2YWx1ZVxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB2YWwgPSAxXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXN0b21JbnB1dCkge1xuICAgICAgICAgIC8vIGVuc3VyZSBzdHVmZiBieSBibHVycmluZy5cbiAgICAgICAgICB0aGlzLmN1c3RvbUlucHV0LmJsdXIoKVxuXG4gICAgICAgICAgdmFsID0gdGhpcy5jdXN0b21JbnB1dC50ZXh0Q29udGVudC5yZXBsYWNlKC9bXFx1MjAwQi1cXHUyMDBEXFx1RkVGRl0vZywgJycpXG4gICAgICAgICAgaWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIGlmICgvcGxhY2Vob2xkZXIvLnRlc3QodGhpcy5jdXN0b21JbnB1dC5jbGFzc05hbWUpICYmIHZhbCA9PT0gdGhpcy5wbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgdmFsID0gXCJcIlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsICYmIHRoaXMudHlwZSA9PT0gJ2hhc2gnKVxuICAgICAgICAgICAgdmFsID0gJ3snICsgdmFsICsgJ30nXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplVmFsdWUodmFsKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlOiBmdW5jdGlvbigpeyB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlIH0sXG4gICAgc2hvdzogZnVuY3Rpb24oKXsgdGhpcy52aXNpYmxlID0gdHJ1ZSB9LFxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7IHRoaXMudmlzaWJsZSA9IGZhbHNlIH0sXG5cbiAgICBmb2N1c0lucHV0OiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMuY3VzdG9tSW5wdXQpXG4gICAgICAgIHRoaXMuY3VzdG9tSW5wdXQuZm9jdXMoKVxuICAgIH0sXG4gICAgXG4gICAgdXBkYXRlVmlzaWJpbGl0eTogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMudmlzaWJsZSA9IFtdLnNvbWUuY2FsbCh0aGlzLnBhcmFtcywgZnVuY3Rpb24oY2hpbGQpeyByZXR1cm4gY2hpbGQudmlzaWJsZSB9KVxuICAgIH0sXG5cbiAgICBzaG93SGludDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBoaW50RWwgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5oaW50JylcbiAgICAgIGlmIChoaW50RWwpXG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoaGludEVsKVxuICAgICAgXG4gICAgICBoaW50RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAgIGhpbnRFbC5jbGFzc05hbWUgPSAnaGludCdcbiAgICAgIGhpbnRFbC50ZXh0Q29udGVudCA9IHRoaXMuaGludFxuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5oaW50VGltZW91dClcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoaGludEVsKVxuICAgICAgdGhpcy5oaW50VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgaGludEVsLmNsYXNzTmFtZSArPSAnIG91dCdcbiAgICAgICAgaGludEVsLmFkZEV2ZW50TGlzdGVuZXIoY3NzQW5pbUV2ZW50VHlwZXMuZW5kLCBmdW5jdGlvbiBhbmltRW5kKGV2ZW50KXtcbiAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGhpbnRFbClcbiAgICAgICAgICBoaW50RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihjc3NBbmltRXZlbnRUeXBlcy5lbmQsIGFuaW1FbmQpXG4gICAgICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpXG4gICAgICB9LmJpbmQodGhpcyksIDIwMDApXG4gICAgfSxcblxuICAgIHNldEN1cnNvckF0RW5kOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRleHQgPSB0aGlzLmN1c3RvbUlucHV0LmZpcnN0Q2hpbGRcbiAgICAgIGlmKHRleHQpXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHRleHQubGVuZ3RoLCAwKVxuICAgIH0sXG5cbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuY3VzdG9tSW5wdXRcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKClcbiAgICAgIHJhbmdlLnNldFN0YXJ0KGVsLmZpcnN0Q2hpbGQsIHN0YXJ0KVxuICAgICAgcmFuZ2Uuc2V0RW5kKGVsLmZpcnN0Q2hpbGQsIHN0YXJ0ICsgbGVuZ3RoKVxuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxuICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpXG4gICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpXG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZiAoIXRoaXMucGFyc2VyKVxuICAgICAgICByZXR1cm4gdmFsdWVcblxuICAgICAgaWYgKHRoaXMucGFyc2VyID09PSAnYnNvbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoQlNPTi5ic29uRXZhbCh2YWx1ZSkpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpXG4gICAgICAgICAgeHRhZy5maXJlRXZlbnQodGhpcywgJ2Vycm9yJywge2RldGFpbDoge2Vycm9yOiBuZXcgRXJyb3IoJ1Vuc2VyaWFsaXphYmxlIHZhbHVlIGZvciAnICsgdGhpcy5uYW1lKX19KVxuICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZiAoIXRoaXMucGFyc2VyKVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGlmICh0aGlzLnBhcnNlciA9PT0gJ2Jzb24nICYmIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmlwV3JhcHBlcihCU09OLnRvQnNvblN0cmluZyhKU09OLnBhcnNlKHZhbHVlKSwge2luZGVudGF0aW9uOiAwfSkpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpXG4gICAgICAgICAgeHRhZy5maXJlRXZlbnQodGhpcywgJ2Vycm9yJywge2RldGFpbDoge2Vycm9yOiBuZXcgRXJyb3IoJ1VucGFyc2FibGUgdmFsdWUgZm9yICcgKyB0aGlzLm5hbWUpfX0pXG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIHN0cmlwV3JhcHBlcihxdWVyeVN0cmluZykge1xuICB2YXIgbWF0Y2hlcyA9IHF1ZXJ5U3RyaW5nLm1hdGNoKC9cXHsoLispXFx9LylcbiAgaWYgKG1hdGNoZXMpXG4gICAgcmV0dXJuIG1hdGNoZXNbMV1cbn1cbiIsInZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGVzL3NoZWxsLmhicycpXG5cbnh0YWcucmVnaXN0ZXIoJ2NvbXBvc2Utc2hlbGwnLCB7XG4gIGxpZmVjeWNsZToge1xuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0geHRhZy5xdWVyeUNoaWxkcmVuKHRoaXMsICdjb21wb3NlLXNoZWxsLXBhcmFtJylcbiAgICAgIHZhciBidXR0b25zID0geHRhZy5xdWVyeUNoaWxkcmVuKHRoaXMsICdjb21wb3NlLXNoZWxsLWJ1dHRvbicpXG4gICAgICB2YXIgb2xkSW5wdXRzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCxzZWxlY3QsdGV4dGFyZWEnKVxuXG4gICAgICAvLyBSZW5kZXIgdGhlIGluaXRpYWwgdGVtcGxhdGVcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdGVtcGxhdGUoKVxuXG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuYXR0cmlidXRlc1tpXS5ub2RlTmFtZVxuICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICB0aGlzLmZvcm0uc2V0QXR0cmlidXRlKG5hbWUsIHRoaXMuYXR0cmlidXRlc1tpXS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgW10uZm9yRWFjaC5jYWxsKG9sZElucHV0cywgZnVuY3Rpb24oaW5wdXQpe1xuICAgICAgICB0aGlzLmZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpXG4gICAgICB9LmJpbmQodGhpcykpXG4gICAgICBcbiAgICAgIHZhciBwYXJhbXNFbCA9IHRoaXMucXVlcnlTZWxlY3RvcignLnBhcmFtcycpXG4gICAgICBmb3IgKHZhciBpIGluIHBhcmFtcykge1xuICAgICAgICBwYXJhbXNbaV0uc2hlbGwgPSB0aGlzXG4gICAgICAgIHBhcmFtc0VsLmFwcGVuZENoaWxkKHBhcmFtc1tpXSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGJ1dHRvbnNFbCA9IHRoaXMucXVlcnlTZWxlY3RvcignLmJ1dHRvbnMnKVxuICAgICAgZm9yICh2YXIgaSBpbiBidXR0b25zKSB7XG4gICAgICAgIGJ1dHRvbnNbaV0uc2hlbGwgPSB0aGlzXG4gICAgICAgIGJ1dHRvbnNFbC5hcHBlbmRDaGlsZChidXR0b25zW2ldKVxuICAgICAgfVxuXG4gICAgfVxuICB9LFxuXG4gIGV2ZW50czoge1xuICAgICdzdWJtaXQ6ZGVsZWdhdGUoZm9ybSknOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgY29uc29sZS5sb2coJ2Zvcm0gc3VibWl0JylcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuZ2VuZXJhdGVJbnB1dHMoKVxuICAgIH0sXG4gICAgJ3RvZ2dsZTpkZWxlZ2F0ZShjb21wb3NlLXNoZWxsLWJ1dHRvbiknOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHRvZ2dsZSA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RvZ2dsZScpXG5cbiAgICAgIHZhciBzaGVsbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXRcbiAgICAgIHZhciBwYXJhbSA9IHNoZWxsLnBhcmFtc1t0b2dnbGVdXG4gICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgcGFyYW0udG9nZ2xlKClcbiAgICAgICAgcGFyYW0uZm9jdXNJbnB1dCgpXG4gICAgICB9XG4gICAgfSxcbiAgICAnc2hvdzpkZWxlZ2F0ZShjb21wb3NlLXNoZWxsLXBhcmFtKSc6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIHZhciBzaGVsbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXRcbiAgICAgIGlmICh0aGlzLmRlcGVuZGVuY3kgJiYgIXNoZWxsLnBhcmFtc1t0aGlzLmRlcGVuZGVuY3ldLnZpc2libGUpIHtcbiAgICAgICAgeHRhZy5maXJlRXZlbnQoc2hlbGwsICdub3RpZnknLCB7ZGV0YWlsOiB7bWVzc2FnZTogdGhpcy5uYW1lICsgJyByZXF1aXJlcyAnICsgdGhpcy5kZXBlbmRlbmN5fX0pXG4gICAgICAgIHNoZWxsLnBhcmFtc1t0aGlzLmRlcGVuZGVuY3ldLnNob3coKVxuICAgICAgfVxuICAgICAgaWYgKHNoZWxsLmJ1dHRvbnMgJiYgc2hlbGwuYnV0dG9uc1t0aGlzLm5hbWVdKVxuICAgICAgICBzaGVsbC5idXR0b25zW3RoaXMubmFtZV0uZW5hYmxlZCA9IHRydWVcbiAgICB9LFxuICAgICdoaWRlOmRlbGVnYXRlKGNvbXBvc2Utc2hlbGwtcGFyYW0pJzogZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgdmFyIHNoZWxsID0gZXZlbnQuY3VycmVudFRhcmdldFxuICAgICAgaWYgKHRoaXMucmVxdWlyZWRCeSAmJiAhdGhpcy52aXNpYmxlICYmIHNoZWxsLnBhcmFtc1t0aGlzLnJlcXVpcmVkQnldLnZpc2libGUpIHtcbiAgICAgICAgc2hlbGwucGFyYW1zW3RoaXMucmVxdWlyZWRCeV0uaGlkZSgpXG4gICAgICB9XG4gICAgICBpZiAoc2hlbGwuYnV0dG9ucyAmJiBzaGVsbC5idXR0b25zW3RoaXMubmFtZV0pXG4gICAgICAgIHNoZWxsLmJ1dHRvbnNbdGhpcy5uYW1lXS5lbmFibGVkID0gZmFsc2VcbiAgICB9LFxuICAgICdrZXlwcmVzczprZXlwYXNzKDEzKTpkZWxlZ2F0ZShjb21wb3NlLXNoZWxsLXBhcmFtKSc6IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHZhciBzdWJtaXRFdmVudCA9IG5ldyBFdmVudCgnc3VibWl0Jywge2J1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWV9KVxuICAgICAgdmFyIGZvcm0gPSBldmVudC5jdXJyZW50VGFyZ2V0LmZvcm1cbiAgICAgIGZvcm0uZGlzcGF0Y2hFdmVudChzdWJtaXRFdmVudClcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKCFzdWJtaXRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgZm9ybS5zdWJtaXQoKVxuICAgICAgICB9XG4gICAgICB9LCA1MClcbiAgICB9LFxuICAgIG5vdGlmeTogZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgaWYgKHRoaXMub25Ob3RpZnkpXG4gICAgICAgIHRoaXMub25Ob3RpZnkoZXZlbnQuZGV0YWlsLm1lc3NhZ2UpXG4gICAgfVxuICB9LFxuXG4gIGFjY2Vzc29yczoge1xuICAgIGZvcm06IHsgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdmb3JtJykgfSB9LFxuICAgIG9uTm90aWZ5OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBub3RpZnkgPSB0aGlzLmdldEF0dHJpYnV0ZSgnb24tbm90aWZ5JylcbiAgICAgICAgcmV0dXJuIG5vdGlmeSAmJiBldmFsKG5vdGlmeSkgfHwgZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHJlZ2lzdGVyUGFyYW06IGZ1bmN0aW9uKHBhcmFtKXtcbiAgICAgIHRoaXMucGFyYW1zID0gdGhpcy5wYXJhbXMgfHwge31cbiAgICAgIHRoaXMucGFyYW1zW3BhcmFtLm5hbWVdID0gcGFyYW1cbiAgICAgIGlmIChwYXJhbS5kZXBlbmRlbmN5ICYmIHRoaXMucGFyYW1zW3BhcmFtLmRlcGVuZGVuY3ldKVxuICAgICAgICB0aGlzLnBhcmFtc1twYXJhbS5kZXBlbmRlbmN5XS5yZXF1aXJlZEJ5ID0gcGFyYW0ubmFtZVxuICAgIH0sXG4gICAgcmVnaXN0ZXJCdXR0b246IGZ1bmN0aW9uKGJ1dHRvbil7XG4gICAgICB0aGlzLmJ1dHRvbnMgPSB0aGlzLmJ1dHRvbnMgfHwge31cbiAgICAgIHRoaXMuYnV0dG9uc1tidXR0b24udG9nZ2xlXSA9IGJ1dHRvblxuICAgICAgaWYgKHRoaXMucGFyYW1zW2J1dHRvbi50b2dnbGVdLnZpc2libGUpXG4gICAgICAgIGJ1dHRvbi5lbmFibGVkID0gdHJ1ZVxuICAgIH0sXG4gICAgZ2VuZXJhdGVJbnB1dHM6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5wYXJhbXNbbmFtZV0udmFsdWUpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgICAgaW5wdXQudHlwZSA9ICdoaWRkZW4nXG4gICAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnBhcmFtc1tuYW1lXS52YWx1ZVxuICAgICAgICAgIGlucHV0Lm5hbWUgPSBuYW1lXG4gICAgICAgICAgdGhpcy5mb3JtLmFwcGVuZENoaWxkKGlucHV0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIiwicmVxdWlyZSgnLi92ZW5kb3IveC10YWctY29yZScpXG5cbnZhciBIYW5kbGViYXJzID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpXG5IYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdpZkVxdWFsJywgZnVuY3Rpb24odjEsIHYyLCBvcHRpb25zKSB7XG4gIGlmICh2MSA9PT0gdjIpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKVxuICB9XG4gIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcylcbn0pXG5cbnJlcXVpcmUoJy4vY29tcG9zZS1zaGVsbCcpXG5yZXF1aXJlKCcuL2NvbXBvc2Utc2hlbGwtcGFyYW0nKVxucmVxdWlyZSgnLi9jb21wb3NlLXNoZWxsLWJ1dHRvbicpXG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2U6bG9hZCcsIGZ1bmN0aW9uKCl7XG4gIHZhciBzaGVsbHMgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvbXBvc2Utc2hlbGwnKVxuICBmb3IgKHZhciBpIGluIHNoZWxscykge1xuICAgIHZhciBzaGVsbCA9IHNoZWxsc1tpXVxuICAgIGlmIChzaGVsbC5wYXJlbnROb2RlKVxuICAgICAgc2hlbGwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9jdW1lbnQuaW1wb3J0Tm9kZShzaGVsbCwgdHJ1ZSksIHNoZWxsKVxuICB9XG59KSIsIm1vZHVsZS5leHBvcnRzID0gZ2V0QW5pbWF0aW9uRXZlbnRUeXBlcygpXG5cbmZ1bmN0aW9uIGNhbWVsQ2FzZUV2ZW50VHlwZXMocHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwcmVmaXggKyAnQW5pbWF0aW9uU3RhcnQnLFxuICAgIGVuZDogcHJlZml4ICsgJ0FuaW1hdGlvbkVuZCcsXG4gICAgaXRlcmF0aW9uOiBwcmVmaXggKyAnQW5pbWF0aW9uSXRlcmF0aW9uJ1xuICB9O1xufVxuXG5mdW5jdGlvbiBsb3dlckNhc2VFdmVudFR5cGVzKHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcHJlZml4ICsgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgICBlbmQ6IHByZWZpeCArICdhbmltYXRpb25lbmQnLFxuICAgIGl0ZXJhdGlvbjogcHJlZml4ICsgJ2FuaW1hdGlvbml0ZXJhdGlvbidcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uRXZlbnRUeXBlcygpIHtcbiAgdmFyIHByZWZpeGVzID0gWyd3ZWJraXQnLCAnTW96JywgJ08nLCAnJ107XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxuICAvLyBicm93c2VyIGNvbXBsaWFudFxuICBpZiAodW5kZWZpbmVkICE9PSBzdHlsZS5hbmltYXRpb25OYW1lKSB7XG4gICAgcmV0dXJuIGxvd2VyQ2FzZUV2ZW50VHlwZXMoKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcmVmaXhlcy5sZW5ndGgsIHByZWZpeDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcHJlZml4ID0gcHJlZml4ZXNbaV07XG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSBzdHlsZVtwcmVmaXggKyAnQW5pbWF0aW9uTmFtZSddKSB7XG4gICAgICAvLyBXZWJraXRcbiAgICAgIGlmICgwID09PSBpKSB7XG4gICAgICAgIHJldHVybiBjYW1lbENhc2VFdmVudFR5cGVzKHByZWZpeC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGVsc2UgaWYgKDEgPT09IGkpIHtcbiAgICAgICAgcmV0dXJuIGxvd2VyQ2FzZUV2ZW50VHlwZXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIE9wZXJhXG4gICAgICBlbHNlIGlmICgyID09PSBpKSB7XG4gICAgICAgIHJldHVybiBsb3dlckNhc2VFdmVudFR5cGVzKHByZWZpeC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge307XG59IiwidmFyIGRhdGVGb3JtYXQgPSByZXF1aXJlKFwiLi9kYXRlLmZvcm1hdFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEluZGVudGF0aW9uOiBmdW5jdGlvbihsZXZlbCwgaW5kZW50YXRpb24pIHtcbiAgICB2YXIgcGFkO1xuICAgIGlmIChpbmRlbnRhdGlvbikge1xuICAgICAgcGFkID0gXCJcXG5cIjtcbiAgICAgIHZhciB0aW1lcyA9IGxldmVsICogaW5kZW50YXRpb25cbiAgICAgIGZvciAodmFyIGkgPSB0aW1lczsgaSA9PSAwOyBpLS0pIHtcbiAgICAgICAgcGFkICs9IFwiIFwiXG4gICAgICB9XG4gICAgICAvLyBfLnRpbWVzKGxldmVsICogaW5kZW50YXRpb24sIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgLy8gICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgICAgcmV0dXJuIHBhZCArPSBcIiBcIjtcbiAgICAgIC8vICAgfTtcbiAgICAgIC8vIH0pKHRoaXMpKTtcbiAgICAgIHJldHVybiBwYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfSxcbiAgdG9Cc29uU3RyaW5nOiBmdW5jdGlvbihqc29uLCBvcHRpb25zKSB7XG4gICAgdmFyIGVtcHR5T2JqZWN0LCBpbmRlbnRhdGlvbiwgbGV2ZWwsIHAsIHJlc3VsdCwgdjtcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGxldmVsID0gb3B0aW9ucy5sZXZlbCB8fCAwO1xuICAgIGlmIChvcHRpb25zLmluZGVudGF0aW9uICE9IG51bGwpIHtcbiAgICAgIGluZGVudGF0aW9uID0gb3B0aW9ucy5pbmRlbnRhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50YXRpb24gPSAyO1xuICAgIH1cbiAgICByZXN1bHQgPSBcIlwiO1xuICAgIGVtcHR5T2JqZWN0ID0gdHJ1ZTtcbiAgICBpZiAocmVzdWx0ICE9PSBcIlwiKSB7XG4gICAgICByZXN1bHQgKz0gXCJcIiArICh0aGlzLmdldEluZGVudGF0aW9uKGxldmVsLCBpbmRlbnRhdGlvbikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52YWx1ZU9ubHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWUoanNvbiwgcmVzdWx0LCBsZXZlbCwgaW5kZW50YXRpb24sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoanNvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXN1bHQgKz0gXCJbXCI7XG4gICAgfSBlbHNlIGlmIChqc29uIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICByZXN1bHQgKz0gXCJ7XCI7XG4gICAgfVxuICAgIGZvciAocCBpbiBqc29uKSB7XG4gICAgICB2ID0ganNvbltwXTtcbiAgICAgIGVtcHR5T2JqZWN0ID0gZmFsc2U7XG4gICAgICByZXN1bHQgKz0gdGhpcy5nZXRJbmRlbnRhdGlvbihsZXZlbCArIDEsIGluZGVudGF0aW9uKTtcbiAgICAgIGlmICghKGpzb24gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaHRtbCkge1xuICAgICAgICAgIGlmIChwLm1hdGNoKC9bXkEtejAtOV9dLykpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIjxzcGFuIGNsYXNzPSdrZXknPlxcXCJcIiArICgkKFwiPGRpdj5cIikudGV4dChwKS5odG1sKCkpICsgXCJcXFwiPC9zcGFuPjogXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIjxzcGFuIGNsYXNzPSdrZXknPlwiICsgcCArIFwiPC9zcGFuPjogXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwLm1hdGNoKC9eXFxkfFteQS16MC05X10vKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcIlwiICsgKHAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpKSArIFwiXFxcIjogXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiICsgcCArIFwiOiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VWYWx1ZSh2LCByZXN1bHQsIGxldmVsLCBpbmRlbnRhdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuc2xpY2UoLTEpID09PSBcIixcIikge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgaWYgKCFlbXB0eU9iamVjdCkge1xuICAgICAgcmVzdWx0ICs9IHRoaXMuZ2V0SW5kZW50YXRpb24obGV2ZWwsIGluZGVudGF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGpzb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArPSBcIl1cIjtcbiAgICB9IGVsc2UgaWYgKGpzb24gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKz0gXCJ9XCI7XG4gICAgfVxuICB9LFxuICBwYXJzZVZhbHVlOiBmdW5jdGlvbih2LCByZXN1bHQsIGxldmVsLCBpbmRlbnRhdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBjbGFzc05hbWUsIGR0LCBkdGYsIHZhbDtcbiAgICBpZiAodiA9PT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMuaHRtbCkge1xuICAgICAgICByZXN1bHQgKz0gXCI8c3BhbiBjbGFzcz0ndmFsdWUnPm51bGw8L3NwYW4+LFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IFwibnVsbCxcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBzd2l0Y2ggKHYuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgICBjYXNlIFwiT2JqZWN0SURcIjpcbiAgICAgICAgICBpZiAob3B0aW9ucy5odG1sKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCI8c3BhbiBjbGFzcz0nZnVuY3Rpb24nPk9iamVjdElkPC9zcGFuPig8c3BhbiBjbGFzcz0nc3RyaW5nJz5cXFwiPHNwYW4gY2xhc3M9J19pZCc+XCIgKyAodi50b1N0cmluZygpKSArIFwiPC9zcGFuPlxcXCI8L3NwYW4+KSxcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiT2JqZWN0SWQoXFxcIlwiICsgKHYudG9TdHJpbmcoKSkgKyBcIlxcXCIpLFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRhdGVcIjpcbiAgICAgICAgICBkdCA9IG5ldyBEYXRlKHYudG9TdHJpbmcoKSk7XG4gICAgICAgICAgZHRmID0gZGF0ZUZvcm1hdChkdCwgJ2lzb1V0Y0RhdGVUaW1lJyk7XG4gICAgICAgICAgaWYgKGR0LmdldE1pbGxpc2Vjb25kcygpID4gMCkge1xuICAgICAgICAgICAgZHRmID0gZHRmLnJlcGxhY2UoL1okLywgXCIuXCIgKyAoZGF0ZUZvcm1hdChkdCwgJ2wnKSkgKyBcIlpcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIjxzcGFuIGNsYXNzPSdmdW5jdGlvbic+SVNPRGF0ZTwvc3Bhbj4oPHNwYW4gY2xhc3M9J3N0cmluZyc+XFxcIlwiICsgZHRmICsgXCJcXFwiPC9zcGFuPiksXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIklTT0RhdGUoXFxcIlwiICsgZHRmICsgXCJcXFwiKSxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSZWdFeHBcIjpcbiAgICAgICAgICBpZiAob3B0aW9ucy5odG1sKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCI8c3BhbiBjbGFzcz0ncmVnZXgnPi9cIiArICh2LnRvU3RyaW5nKCkpICsgXCI8L3NwYW4+LFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCIvXCIgKyAodi50b1N0cmluZygpKSArIFwiLFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodltcIiRvaWRcIl0pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5PYmplY3RJZDwvc3Bhbj4oPHNwYW4gY2xhc3M9J3N0cmluZyc+XFxcIjxzcGFuIGNsYXNzPSdfaWQnPlwiICsgdltcIiRvaWRcIl0gKyBcIjwvc3Bhbj5cXFwiPC9zcGFuPiksXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCJPYmplY3RJZChcXFwiXCIgKyB2W1wiJG9pZFwiXSArIFwiXFxcIiksXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh2W1wiJGRhdGVcIl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZHQgPSBuZXcgRGF0ZSh2WyckZGF0ZSddKTtcbiAgICAgICAgICAgIGR0ZiA9IGRhdGVGb3JtYXQoZHQsICdpc29VdGNEYXRlVGltZScpO1xuICAgICAgICAgICAgaWYgKGR0LmdldE1pbGxpc2Vjb25kcygpID4gMCkge1xuICAgICAgICAgICAgICBkdGYgPSBkdGYucmVwbGFjZSgvWiQvLCBcIi5cIiArIChkYXRlRm9ybWF0KGR0LCAnbCcpKSArIFwiWlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5JU09EYXRlPC9zcGFuPig8c3BhbiBjbGFzcz0nc3RyaW5nJz5cXFwiXCIgKyBkdGYgKyBcIlxcXCI8L3NwYW4+KSxcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIklTT0RhdGUoXFxcIlwiICsgZHRmICsgXCJcXFwiKSxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHZbXCIkcmVnZXhcIl0pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J3JlZ2V4Jz4vXCIgKyB2W1wiJHJlZ2V4XCJdICsgXCIvXCIgKyAodltcIiRvcHRpb25zXCJdIHx8IFwiXCIpICsgXCI8L3NwYW4+LFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiL1wiICsgdltcIiRyZWdleFwiXSArIFwiL1wiICsgKHZbXCIkb3B0aW9uc1wiXSB8fCBcIlwiKSArIFwiLFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodltcIiR0aW1lc3RhbXBcIl0pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5UaW1lc3RhbXA8L3NwYW4+KFwiICsgdltcIiR0aW1lc3RhbXBcIl1bXCJ0XCJdICsgXCIsIFwiICsgdltcIiR0aW1lc3RhbXBcIl1bXCJpXCJdICsgXCIpLFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiVGltZXN0YW1wKFwiICsgdltcIiR0aW1lc3RhbXBcIl1bXCJ0XCJdICsgXCIsIFwiICsgdltcIiR0aW1lc3RhbXBcIl1bXCJpXCJdICsgXCIpLFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodltcIiRyZWZcIl0pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiPHNwYW4gY2xhc3M9J2Z1bmN0aW9uJz5EYnJlZjwvc3Bhbj4oXFxcIjxzcGFuIGNsYXNzPSdzdHJpbmcnPlwiICsgdltcIm5hbWVzcGFjZVwiXSArIFwiPC9zcGFuPlxcXCIsIFwiICsgKHRoaXMudG9Cc29uU3RyaW5nKHZbXCJvaWRcIl0sIHtcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwgKyAxLFxuICAgICAgICAgICAgICAgIHZhbHVlT25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBodG1sOiB0cnVlXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgaWYgKHZbXCJkYlwiXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiwgXFxcIjxzcGFuIGNsYXNzPSdzdHJpbmcnPlwiICsgdltcImRiXCJdICsgXCI8L3NwYW4+XFxcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIiksXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCJEYnJlZihcXFwiXCIgKyB2W1wiJHJlZlwiXSArIFwiXFxcIiwgXCIgKyAodGhpcy50b0Jzb25TdHJpbmcodltcIiRpZFwiXSwge1xuICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCArIDEsXG4gICAgICAgICAgICAgICAgdmFsdWVPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGh0bWw6IGZhbHNlXG4gICAgICAgICAgICAgIH0pKSArIFwiKSxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXCIgKyAodGhpcy50b0Jzb25TdHJpbmcodiwge1xuICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwgKyAxLFxuICAgICAgICAgICAgICBpbmRlbnRhdGlvbjogaW5kZW50YXRpb24sXG4gICAgICAgICAgICAgIGh0bWw6IG9wdGlvbnMuaHRtbFxuICAgICAgICAgICAgfSkpICsgXCIsXCI7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodiA9PT0gXCI8QlNPTjo6QmluYXJ5PlwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5odG1sKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIjxzcGFuIGNsYXNzPSdmdW5jdGlvbic+QmluYXJ5PC9zcGFuPig8c3BhbiBjbGFzcz0nc3RyaW5nJz5cXFwiW0JTT046OkJpbmFyeV1cXFwiPC9zcGFuPiksXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gXCJCaW5hcnkoXFxcIltCU09OOjpCaW5hcnldXFxcIiksXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgaWYgKG9wdGlvbnMuaHRtbCkge1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xuICAgICAgICBjbGFzc05hbWUgPSAnc3RyaW5nJztcbiAgICAgICAgaWYgKHZhbCA9PT0gJ2ZhbHNlJyB8fCB2YWwgPT09ICd0cnVlJykge1xuICAgICAgICAgIGNsYXNzTmFtZSA9ICd2YWx1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGNsYXNzTmFtZSA9ICdudW1iZXInO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIjxzcGFuIGNsYXNzPSdcIiArIGNsYXNzTmFtZSArIFwiJz5cIiArIHZhbCArIFwiPC9zcGFuPixcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBcIlwiICsgdmFsICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZhbHVlT25seSkge1xuICAgICAgaWYgKHJlc3VsdC5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIHNhbml0aXplUmVnZXg6IGZ1bmN0aW9uKGpzb24pIHtcbiAgICB2YXIgcCwgcmVnZXhwX3BhcnRzLCB2O1xuICAgIGZvciAocCBpbiBqc29uKSB7XG4gICAgICB2ID0ganNvbltwXTtcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJlZ2V4cF9wYXJ0cyA9IHYudG9TdHJpbmcoKS5tYXRjaCgvXlxcLyguKilcXC8oW2dpbV0qKSQvKTtcbiAgICAgICAganNvbltwXSA9IHtcbiAgICAgICAgICAkcmVnZXg6IHJlZ2V4cF9wYXJ0c1sxXSxcbiAgICAgICAgICAkb3B0aW9uczogcmVnZXhwX3BhcnRzWzJdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiJG9pZFwiICYmIHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGFsZXJ0KFwianNvbltwXSA9IHdpbmRvdy5kYmxheWVyLnBhZ2VfZGF0YS5kb2N1bWVudF9vaWRzLnNoaWZ0KClcIik7XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiJGRhdGVcIiAmJiB0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBqc29uW3BdID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAganNvbltwXSA9IHRoaXMuc2FuaXRpemVSZWdleCh2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG4gIH0sXG4gIGJzb25FdmFsOiBmdW5jdGlvbihzcmMpIHtcbiAgICB2YXIgZXJyb3IsIGpzb24sIG1hc2ssIHAsIHY7XG4gICAgdHJ5IHtcbiAgICAgIG1hc2sgPSB7fTtcbiAgICAgIGZvciAocCBpbiB0aGlzKSB7XG4gICAgICAgIHYgPSB0aGlzW3BdO1xuICAgICAgICBtYXNrW3ZdID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgbWFzay5PYmplY3RJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJG9pZDogaWRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBtYXNrLkRhdGUgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJGRhdGU6IGRhdGVcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBtYXNrLklTT0RhdGUgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJGRhdGU6IChuZXcgRGF0ZShkYXRlKSkuZ2V0VGltZSgpXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgbWFzay5UaW1lc3RhbXAgPSBmdW5jdGlvbih0LCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJHRpbWVzdGFtcDoge1xuICAgICAgICAgICAgXCJ0XCI6IHQsXG4gICAgICAgICAgICBcImlcIjogaVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBtYXNrLkRicmVmID0gZnVuY3Rpb24obmFtZSwgaWQsIGRiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZXNwYWNlOiBuYW1lLFxuICAgICAgICAgIG9pZDogaWQsXG4gICAgICAgICAgZGI6IGRiXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgbWFzay5CaW5hcnkgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRocm93IFwiQ2Fubm90IHNhdmUgZG9jdW1lbnRzIHdpdGggQmluYXJ5IHZhbHVlc1wiO1xuICAgICAgfTtcbiAgICAgIGpzb24gPSAobmV3IEZ1bmN0aW9uKFwid2l0aCh0aGlzKXsgcmV0dXJuIFwiICsgc3JjICsgXCIgfVwiKSkuY2FsbChtYXNrKTtcbiAgICAgIHJldHVybiB0aGlzLnNhbml0aXplUmVnZXgoanNvbik7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLypnbG9iYWxzIEhhbmRsZWJhcnM6IHRydWUgKi9cbnZhciBiYXNlID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy9iYXNlXCIpO1xuXG4vLyBFYWNoIG9mIHRoZXNlIGF1Z21lbnQgdGhlIEhhbmRsZWJhcnMgb2JqZWN0LiBObyBuZWVkIHRvIHNldHVwIGhlcmUuXG4vLyAoVGhpcyBpcyBkb25lIHRvIGVhc2lseSBzaGFyZSBjb2RlIGJldHdlZW4gY29tbW9uanMgYW5kIGJyb3dzZSBlbnZzKVxudmFyIFNhZmVTdHJpbmcgPSByZXF1aXJlKFwiLi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nXCIpW1wiZGVmYXVsdFwiXTtcbnZhciBFeGNlcHRpb24gPSByZXF1aXJlKFwiLi9oYW5kbGViYXJzL2V4Y2VwdGlvblwiKVtcImRlZmF1bHRcIl07XG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi9oYW5kbGViYXJzL3V0aWxzXCIpO1xudmFyIHJ1bnRpbWUgPSByZXF1aXJlKFwiLi9oYW5kbGViYXJzL3J1bnRpbWVcIik7XG5cbi8vIEZvciBjb21wYXRpYmlsaXR5IGFuZCB1c2FnZSBvdXRzaWRlIG9mIG1vZHVsZSBzeXN0ZW1zLCBtYWtlIHRoZSBIYW5kbGViYXJzIG9iamVjdCBhIG5hbWVzcGFjZVxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGIgPSBuZXcgYmFzZS5IYW5kbGViYXJzRW52aXJvbm1lbnQoKTtcblxuICBVdGlscy5leHRlbmQoaGIsIGJhc2UpO1xuICBoYi5TYWZlU3RyaW5nID0gU2FmZVN0cmluZztcbiAgaGIuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuICBoYi5VdGlscyA9IFV0aWxzO1xuICBoYi5lc2NhcGVFeHByZXNzaW9uID0gVXRpbHMuZXNjYXBlRXhwcmVzc2lvbjtcblxuICBoYi5WTSA9IHJ1bnRpbWU7XG4gIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcbiAgfTtcblxuICByZXR1cm4gaGI7XG59O1xuXG52YXIgSGFuZGxlYmFycyA9IGNyZWF0ZSgpO1xuSGFuZGxlYmFycy5jcmVhdGUgPSBjcmVhdGU7XG5cbkhhbmRsZWJhcnNbJ2RlZmF1bHQnXSA9IEhhbmRsZWJhcnM7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gSGFuZGxlYmFyczsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEV4Y2VwdGlvbiA9IHJlcXVpcmUoXCIuL2V4Y2VwdGlvblwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBWRVJTSU9OID0gXCIyLjAuMFwiO1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjt2YXIgQ09NUElMRVJfUkVWSVNJT04gPSA2O1xuZXhwb3J0cy5DT01QSUxFUl9SRVZJU0lPTiA9IENPTVBJTEVSX1JFVklTSU9OO1xudmFyIFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPT0gMS54LngnLFxuICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXG4gIDY6ICc+PSAyLjAuMC1iZXRhLjEnXG59O1xuZXhwb3J0cy5SRVZJU0lPTl9DSEFOR0VTID0gUkVWSVNJT05fQ0hBTkdFUztcbnZhciBpc0FycmF5ID0gVXRpbHMuaXNBcnJheSxcbiAgICBpc0Z1bmN0aW9uID0gVXRpbHMuaXNGdW5jdGlvbixcbiAgICB0b1N0cmluZyA9IFV0aWxzLnRvU3RyaW5nLFxuICAgIG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuZnVuY3Rpb24gSGFuZGxlYmFyc0Vudmlyb25tZW50KGhlbHBlcnMsIHBhcnRpYWxzKSB7XG4gIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XG4gIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcblxuICByZWdpc3RlckRlZmF1bHRIZWxwZXJzKHRoaXMpO1xufVxuXG5leHBvcnRzLkhhbmRsZWJhcnNFbnZpcm9ubWVudCA9IEhhbmRsZWJhcnNFbnZpcm9ubWVudDtIYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlYmFyc0Vudmlyb25tZW50LFxuXG4gIGxvZ2dlcjogbG9nZ2VyLFxuICBsb2c6IGxvZyxcblxuICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGZuKSB7IHRocm93IG5ldyBFeGNlcHRpb24oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgaGVscGVycycpOyB9XG4gICAgICBVdGlscy5leHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWxwZXJzW25hbWVdID0gZm47XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uKG5hbWUsIHBhcnRpYWwpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgVXRpbHMuZXh0ZW5kKHRoaXMucGFydGlhbHMsICBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdoZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24oLyogW2FyZ3MsIF1vcHRpb25zICovKSB7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHVjdC5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvbWVvbmUgaXMgYWN0dWFsbHkgdHJ5aW5nIHRvIGNhbGwgc29tZXRoaW5nLCBibG93IHVwLlxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIk1pc3NpbmcgaGVscGVyOiAnXCIgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXS5uYW1lICsgXCInXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYoY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZuKHRoaXMpO1xuICAgIH0gZWxzZSBpZihjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgaWYoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVycy5lYWNoKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gVXRpbHMuYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICBvcHRpb25zID0ge2RhdGE6IGRhdGF9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIHZhciBmbiA9IG9wdGlvbnMuZm4sIGludmVyc2UgPSBvcHRpb25zLmludmVyc2U7XG4gICAgdmFyIGkgPSAwLCByZXQgPSBcIlwiLCBkYXRhO1xuXG4gICAgdmFyIGNvbnRleHRQYXRoO1xuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgIGNvbnRleHRQYXRoID0gVXRpbHMuYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSkgKyAnLic7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgaWYoY29udGV4dCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgIGZvcih2YXIgaiA9IGNvbnRleHQubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBkYXRhLmluZGV4ID0gaTtcbiAgICAgICAgICAgIGRhdGEuZmlyc3QgPSAoaSA9PT0gMCk7XG4gICAgICAgICAgICBkYXRhLmxhc3QgID0gKGkgPT09IChjb250ZXh0Lmxlbmd0aC0xKSk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gY29udGV4dFBhdGggKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXQgPSByZXQgKyBmbihjb250ZXh0W2ldLCB7IGRhdGE6IGRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcih2YXIga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZihjb250ZXh0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGlmKGRhdGEpIHtcbiAgICAgICAgICAgICAgZGF0YS5rZXkgPSBrZXk7XG4gICAgICAgICAgICAgIGRhdGEuaW5kZXggPSBpO1xuICAgICAgICAgICAgICBkYXRhLmZpcnN0ID0gKGkgPT09IDApO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGtleTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtrZXldLCB7ZGF0YTogZGF0YX0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGkgPT09IDApe1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaWYnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbmRpdGlvbmFsKSkgeyBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7IH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVuZGVyIHRoZSBwb3NpdGl2ZSBwYXRoIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgYW5kIG5vdCBlbXB0eS5cbiAgICAvLyBUaGUgYGluY2x1ZGVaZXJvYCBvcHRpb24gbWF5IGJlIHNldCB0byB0cmVhdCB0aGUgY29uZHRpb25hbCBhcyBwdXJlbHkgbm90IGVtcHR5IGJhc2VkIG9uIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXG4gICAgaWYgKCghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCkgfHwgVXRpbHMuaXNFbXB0eShjb25kaXRpb25hbCkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnNbJ2lmJ10uY2FsbCh0aGlzLCBjb25kaXRpb25hbCwge2ZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaH0pO1xuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignd2l0aCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkgeyBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpOyB9XG5cbiAgICB2YXIgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKCFVdGlscy5pc0VtcHR5KGNvbnRleHQpKSB7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIHZhciBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IFV0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xuICAgICAgICBvcHRpb25zID0ge2RhdGE6ZGF0YX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb2cnLCBmdW5jdGlvbihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgdmFyIGxldmVsID0gb3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuZGF0YS5sZXZlbCAhPSBudWxsID8gcGFyc2VJbnQob3B0aW9ucy5kYXRhLmxldmVsLCAxMCkgOiAxO1xuICAgIGluc3RhbmNlLmxvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb29rdXAnLCBmdW5jdGlvbihvYmosIGZpZWxkKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmpbZmllbGRdO1xuICB9KTtcbn1cblxudmFyIGxvZ2dlciA9IHtcbiAgbWV0aG9kTWFwOiB7IDA6ICdkZWJ1ZycsIDE6ICdpbmZvJywgMjogJ3dhcm4nLCAzOiAnZXJyb3InIH0sXG5cbiAgLy8gU3RhdGUgZW51bVxuICBERUJVRzogMCxcbiAgSU5GTzogMSxcbiAgV0FSTjogMixcbiAgRVJST1I6IDMsXG4gIGxldmVsOiAzLFxuXG4gIC8vIGNhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gIGxvZzogZnVuY3Rpb24obGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICBpZiAobG9nZ2VyLmxldmVsIDw9IGxldmVsKSB7XG4gICAgICB2YXIgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGVbbWV0aG9kXSkge1xuICAgICAgICBjb25zb2xlW21ldGhvZF0uY2FsbChjb25zb2xlLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5leHBvcnRzLmxvZ2dlciA9IGxvZ2dlcjtcbnZhciBsb2cgPSBsb2dnZXIubG9nO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG52YXIgY3JlYXRlRnJhbWUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIGZyYW1lID0gVXRpbHMuZXh0ZW5kKHt9LCBvYmplY3QpO1xuICBmcmFtZS5fcGFyZW50ID0gb2JqZWN0O1xuICByZXR1cm4gZnJhbWU7XG59O1xuZXhwb3J0cy5jcmVhdGVGcmFtZSA9IGNyZWF0ZUZyYW1lOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIHZhciBsaW5lO1xuICBpZiAobm9kZSAmJiBub2RlLmZpcnN0TGluZSkge1xuICAgIGxpbmUgPSBub2RlLmZpcnN0TGluZTtcblxuICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgbm9kZS5maXJzdENvbHVtbjtcbiAgfVxuXG4gIHZhciB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAvLyBVbmZvcnR1bmF0ZWx5IGVycm9ycyBhcmUgbm90IGVudW1lcmFibGUgaW4gQ2hyb21lIChhdCBsZWFzdCksIHNvIGBmb3IgcHJvcCBpbiB0bXBgIGRvZXNuJ3Qgd29yay5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XG4gIH1cblxuICBpZiAobGluZSkge1xuICAgIHRoaXMubGluZU51bWJlciA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBub2RlLmZpcnN0Q29sdW1uO1xuICB9XG59XG5cbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBFeGNlcHRpb24gPSByZXF1aXJlKFwiLi9leGNlcHRpb25cIilbXCJkZWZhdWx0XCJdO1xudmFyIENPTVBJTEVSX1JFVklTSU9OID0gcmVxdWlyZShcIi4vYmFzZVwiKS5DT01QSUxFUl9SRVZJU0lPTjtcbnZhciBSRVZJU0lPTl9DSEFOR0VTID0gcmVxdWlyZShcIi4vYmFzZVwiKS5SRVZJU0lPTl9DSEFOR0VTO1xudmFyIGNyZWF0ZUZyYW1lID0gcmVxdWlyZShcIi4vYmFzZVwiKS5jcmVhdGVGcmFtZTtcblxuZnVuY3Rpb24gY2hlY2tSZXZpc2lvbihjb21waWxlckluZm8pIHtcbiAgdmFyIGNvbXBpbGVyUmV2aXNpb24gPSBjb21waWxlckluZm8gJiYgY29tcGlsZXJJbmZvWzBdIHx8IDEsXG4gICAgICBjdXJyZW50UmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTjtcblxuICBpZiAoY29tcGlsZXJSZXZpc2lvbiAhPT0gY3VycmVudFJldmlzaW9uKSB7XG4gICAgaWYgKGNvbXBpbGVyUmV2aXNpb24gPCBjdXJyZW50UmV2aXNpb24pIHtcbiAgICAgIHZhciBydW50aW1lVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2N1cnJlbnRSZXZpc2lvbl0sXG4gICAgICAgICAgY29tcGlsZXJWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY29tcGlsZXJSZXZpc2lvbl07XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYW4gb2xkZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gXCIrXG4gICAgICAgICAgICBcIlBsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKFwiK3J1bnRpbWVWZXJzaW9ucytcIikgb3IgZG93bmdyYWRlIHlvdXIgcnVudGltZSB0byBhbiBvbGRlciB2ZXJzaW9uIChcIitjb21waWxlclZlcnNpb25zK1wiKS5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZSB0aGUgZW1iZWRkZWQgdmVyc2lvbiBpbmZvIHNpbmNlIHRoZSBydW50aW1lIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHJldmlzaW9uIHlldFxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIlRlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gXCIrXG4gICAgICAgICAgICBcIlBsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoXCIrY29tcGlsZXJJbmZvWzFdK1wiKS5cIik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY2hlY2tSZXZpc2lvbiA9IGNoZWNrUmV2aXNpb247Ly8gVE9ETzogUmVtb3ZlIHRoaXMgbGluZSBhbmQgYnJlYWsgdXAgY29tcGlsZVBhcnRpYWxcblxuZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiTm8gZW52aXJvbm1lbnQgcGFzc2VkIHRvIHRlbXBsYXRlXCIpO1xuICB9XG4gIGlmICghdGVtcGxhdGVTcGVjIHx8ICF0ZW1wbGF0ZVNwZWMubWFpbikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XG4gIH1cblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gIHZhciBpbnZva2VQYXJ0aWFsV3JhcHBlciA9IGZ1bmN0aW9uKHBhcnRpYWwsIGluZGVudCwgbmFtZSwgY29udGV4dCwgaGFzaCwgaGVscGVycywgcGFydGlhbHMsIGRhdGEsIGRlcHRocykge1xuICAgIGlmIChoYXNoKSB7XG4gICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBoYXNoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBuYW1lLCBjb250ZXh0LCBoZWxwZXJzLCBwYXJ0aWFscywgZGF0YSwgZGVwdGhzKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7IGhlbHBlcnM6IGhlbHBlcnMsIHBhcnRpYWxzOiBwYXJ0aWFscywgZGF0YTogZGF0YSwgZGVwdGhzOiBkZXB0aHMgfTtcbiAgICAgIHBhcnRpYWxzW25hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgeyBkYXRhOiBkYXRhICE9PSB1bmRlZmluZWQsIGNvbXBhdDogdGVtcGxhdGVTcGVjLmNvbXBhdCB9LCBlbnYpO1xuICAgICAgcmVzdWx0ID0gcGFydGlhbHNbbmFtZV0oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICB2YXIgbGluZXMgPSByZXN1bHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICghbGluZXNbaV0gJiYgaSArIDEgPT09IGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpbmVzW2ldID0gaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVGhlIHBhcnRpYWwgXCIgKyBuYW1lICsgXCIgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSnVzdCBhZGQgd2F0ZXJcbiAgdmFyIGNvbnRhaW5lciA9IHtcbiAgICBsb29rdXA6IGZ1bmN0aW9uKGRlcHRocywgbmFtZSkge1xuICAgICAgdmFyIGxlbiA9IGRlcHRocy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChkZXB0aHNbaV0gJiYgZGVwdGhzW2ldW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZGVwdGhzW2ldW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsYW1iZGE6IGZ1bmN0aW9uKGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXG4gICAgaW52b2tlUGFydGlhbDogaW52b2tlUGFydGlhbFdyYXBwZXIsXG5cbiAgICBmbjogZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlU3BlY1tpXTtcbiAgICB9LFxuXG4gICAgcHJvZ3JhbXM6IFtdLFxuICAgIHByb2dyYW06IGZ1bmN0aW9uKGksIGRhdGEsIGRlcHRocykge1xuICAgICAgdmFyIHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSxcbiAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XG4gICAgICBpZiAoZGF0YSB8fCBkZXB0aHMpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSBwcm9ncmFtKHRoaXMsIGksIGZuLCBkYXRhLCBkZXB0aHMpO1xuICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldID0gcHJvZ3JhbSh0aGlzLCBpLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3JhbVdyYXBwZXI7XG4gICAgfSxcblxuICAgIGRhdGE6IGZ1bmN0aW9uKGRhdGEsIGRlcHRoKSB7XG4gICAgICB3aGlsZSAoZGF0YSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLl9wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbihwYXJhbSwgY29tbW9uKSB7XG4gICAgICB2YXIgcmV0ID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIChwYXJhbSAhPT0gY29tbW9uKSkge1xuICAgICAgICByZXQgPSBVdGlscy5leHRlbmQoe30sIGNvbW1vbiwgcGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBub29wOiBlbnYuVk0ubm9vcCxcbiAgICBjb21waWxlckluZm86IHRlbXBsYXRlU3BlYy5jb21waWxlclxuICB9O1xuXG4gIHZhciByZXQgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRhdGEgPSBvcHRpb25zLmRhdGE7XG5cbiAgICByZXQuX3NldHVwKG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsICYmIHRlbXBsYXRlU3BlYy51c2VEYXRhKSB7XG4gICAgICBkYXRhID0gaW5pdERhdGEoY29udGV4dCwgZGF0YSk7XG4gICAgfVxuICAgIHZhciBkZXB0aHM7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMpIHtcbiAgICAgIGRlcHRocyA9IG9wdGlvbnMuZGVwdGhzID8gW2NvbnRleHRdLmNvbmNhdChvcHRpb25zLmRlcHRocykgOiBbY29udGV4dF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlU3BlYy5tYWluLmNhbGwoY29udGFpbmVyLCBjb250ZXh0LCBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLCBkYXRhLCBkZXB0aHMpO1xuICB9O1xuICByZXQuaXNUb3AgPSB0cnVlO1xuXG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuaGVscGVycywgZW52LmhlbHBlcnMpO1xuXG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMucGFydGlhbHMsIGVudi5wYXJ0aWFscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gb3B0aW9ucy5oZWxwZXJzO1xuICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3B0aW9ucy5wYXJ0aWFscztcbiAgICB9XG4gIH07XG5cbiAgcmV0Ll9jaGlsZCA9IGZ1bmN0aW9uKGksIGRhdGEsIGRlcHRocykge1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzICYmICFkZXB0aHMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW0oY29udGFpbmVyLCBpLCB0ZW1wbGF0ZVNwZWNbaV0sIGRhdGEsIGRlcHRocyk7XG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydHMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtmdW5jdGlvbiBwcm9ncmFtKGNvbnRhaW5lciwgaSwgZm4sIGRhdGEsIGRlcHRocykge1xuICB2YXIgcHJvZyA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHJldHVybiBmbi5jYWxsKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgb3B0aW9ucy5kYXRhIHx8IGRhdGEsIGRlcHRocyAmJiBbY29udGV4dF0uY29uY2F0KGRlcHRocykpO1xuICB9O1xuICBwcm9nLnByb2dyYW0gPSBpO1xuICBwcm9nLmRlcHRoID0gZGVwdGhzID8gZGVwdGhzLmxlbmd0aCA6IDA7XG4gIHJldHVybiBwcm9nO1xufVxuXG5leHBvcnRzLnByb2dyYW0gPSBwcm9ncmFtO2Z1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgbmFtZSwgY29udGV4dCwgaGVscGVycywgcGFydGlhbHMsIGRhdGEsIGRlcHRocykge1xuICB2YXIgb3B0aW9ucyA9IHsgcGFydGlhbDogdHJ1ZSwgaGVscGVyczogaGVscGVycywgcGFydGlhbHM6IHBhcnRpYWxzLCBkYXRhOiBkYXRhLCBkZXB0aHM6IGRlcHRocyB9O1xuXG4gIGlmKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJUaGUgcGFydGlhbCBcIiArIG5hbWUgKyBcIiBjb3VsZCBub3QgYmUgZm91bmRcIik7XG4gIH0gZWxzZSBpZihwYXJ0aWFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnRzLmludm9rZVBhcnRpYWwgPSBpbnZva2VQYXJ0aWFsO2Z1bmN0aW9uIG5vb3AoKSB7IHJldHVybiBcIlwiOyB9XG5cbmV4cG9ydHMubm9vcCA9IG5vb3A7ZnVuY3Rpb24gaW5pdERhdGEoY29udGV4dCwgZGF0YSkge1xuICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YSA/IGNyZWF0ZUZyYW1lKGRhdGEpIDoge307XG4gICAgZGF0YS5yb290ID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcbi8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXG5mdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbn1cblxuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiXCIgKyB0aGlzLnN0cmluZztcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU2FmZVN0cmluZzsiLCJcInVzZSBzdHJpY3RcIjtcbi8qanNoaW50IC1XMDA0ICovXG52YXIgU2FmZVN0cmluZyA9IHJlcXVpcmUoXCIuL3NhZmUtc3RyaW5nXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIGVzY2FwZSA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjeDI3O1wiLFxuICBcImBcIjogXCImI3g2MDtcIlxufTtcblxudmFyIGJhZENoYXJzID0gL1smPD5cIidgXS9nO1xudmFyIHBvc3NpYmxlID0gL1smPD5cIidgXS87XG5cbmZ1bmN0aW9uIGVzY2FwZUNoYXIoY2hyKSB7XG4gIHJldHVybiBlc2NhcGVbY2hyXTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaiAvKiAsIC4uLnNvdXJjZSAqLykge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJndW1lbnRzW2ldLCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbi8vIFNvdXJjZWQgZnJvbSBsb2Rhc2hcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG59XG52YXIgaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgPyB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyA6IGZhbHNlO1xufTtcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGVzY2FwZUV4cHJlc3Npb24oc3RyaW5nKSB7XG4gIC8vIGRvbid0IGVzY2FwZSBTYWZlU3RyaW5ncywgc2luY2UgdGhleSdyZSBhbHJlYWR5IHNhZmVcbiAgaWYgKHN0cmluZyBpbnN0YW5jZW9mIFNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAoc3RyaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyArICcnO1xuICB9XG5cbiAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gIC8vIHRoZSByZWdleCB0ZXN0IHdpbGwgZG8gdGhpcyB0cmFuc3BhcmVudGx5IGJlaGluZCB0aGUgc2NlbmVzLCBjYXVzaW5nIGlzc3VlcyBpZlxuICAvLyBhbiBvYmplY3QncyB0byBzdHJpbmcgaGFzIGVzY2FwZWQgY2hhcmFjdGVycyBpbiBpdC5cbiAgc3RyaW5nID0gXCJcIiArIHN0cmluZztcblxuICBpZighcG9zc2libGUudGVzdChzdHJpbmcpKSB7IHJldHVybiBzdHJpbmc7IH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbn1cblxuZXhwb3J0cy5lc2NhcGVFeHByZXNzaW9uID0gZXNjYXBlRXhwcmVzc2lvbjtmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcbiAgcmV0dXJuIChjb250ZXh0UGF0aCA/IGNvbnRleHRQYXRoICsgJy4nIDogJycpICsgaWQ7XG59XG5cbmV4cG9ydHMuYXBwZW5kQ29udGV4dFBhdGggPSBhcHBlbmRDb250ZXh0UGF0aDsiLCIvLyBDcmVhdGUgYSBzaW1wbGUgcGF0aCBhbGlhcyB0byBhbGxvdyBicm93c2VyaWZ5IHRvIHJlc29sdmVcbi8vIHRoZSBydW50aW1lIG9uIGEgc3VwcG9ydGVkIHBhdGguXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9janMvaGFuZGxlYmFycy5ydW50aW1lJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJoYW5kbGViYXJzL3J1bnRpbWVcIilbXCJkZWZhdWx0XCJdO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHJldHVybiBcImVuYWJsZWRcIjtcbiAgfSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCI8YnV0dG9uXFxuICBjbGFzcz1cXFwiXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5lbmFibGVkIDogZGVwdGgwKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIHJldHVybiBidWZmZXIgKyBcIlxcXCJcXG4gIHR5cGU9XFxcIlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudHlwZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudHlwZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0eXBlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jb250ZW50IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250ZW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImNvbnRlbnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9idXR0b24+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICByZXR1cm4gXCI8c3BhbiBjbGFzcz1cXFwicGFyYW1zLWdyb3VwXFxcIj48L3NwYW4+XCI7XG4gIH0sXCIzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB2YXIgc3RhY2sxLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYnVmZmVyID0gXCJcIjtcbiAgc3RhY2sxID0gKChoZWxwZXJzLmlmRXF1YWwgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWZFcXVhbCkgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50eXBlIDogZGVwdGgwKSwgXCJ0ZXh0XCIsIHtcIm5hbWVcIjpcImlmRXF1YWxcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDQsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMucHJvZ3JhbSg2LCBkYXRhKSxcImRhdGFcIjpkYXRhfSkpO1xuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICByZXR1cm4gYnVmZmVyO1xufSxcIjRcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcbiAgcmV0dXJuIFwiPHNwYW4+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jb250ZW50IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250ZW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImNvbnRlbnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9zcGFuPlwiO1xufSxcIjZcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHZhciBzdGFjazEsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBidWZmZXIgPSBcIlwiO1xuICBzdGFjazEgPSAoKGhlbHBlcnMuaWZFcXVhbCB8fCAoZGVwdGgwICYmIGRlcHRoMC5pZkVxdWFsKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnR5cGUgOiBkZXB0aDApLCBcImJvb2xlYW5cIiwge1wibmFtZVwiOlwiaWZFcXVhbFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oNywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDksIGRhdGEpLFwiZGF0YVwiOmRhdGF9KSk7XG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIHJldHVybiBidWZmZXI7XG59LFwiN1wiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xuICByZXR1cm4gXCI8c3BhbiBjbGFzcz1cXFwiYm9vbGVhblxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jb250ZW50IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250ZW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImNvbnRlbnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcbiAgICArIFwiPC9zcGFuPlwiO1xufSxcIjlcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIjxzcGFuXFxuICAgICAgICBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCJcXG4gICAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZWRpdGFibGUgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMTAsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgICAgY2xhc3M9XFxcIlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudHlwZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudHlwZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0eXBlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucGxhY2Vob2xkZXIgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMTIsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcXCI+XCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC52YWx1ZSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxNCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDE2LCBkYXRhKSxcImRhdGFcIjpkYXRhfSk7XG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIHJldHVybiBidWZmZXIgKyBcIjwvc3Bhbj5cIjtcbn0sXCIxMFwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgcmV0dXJuIFwiY29udGVudGVkaXRhYmxlPVxcXCJ0cnVlXFxcIlwiO1xuICB9LFwiMTJcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHJldHVybiBcIiBwbGFjZWhvbGRlclwiO1xuICB9LFwiMTRcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcbiAgcmV0dXJuIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy52YWx1ZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudmFsdWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidmFsdWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSk7XG4gIH0sXCIxNlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xuICByZXR1cm4gZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnBsYWNlaG9sZGVyIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wbGFjZWhvbGRlciA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJwbGFjZWhvbGRlclwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKTtcbiAgfSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCI8c3BhbiBjbGFzcz1cXFwiYmVmb3JlXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmJlZm9yZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYmVmb3JlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImJlZm9yZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxuICAgICsgXCI8L3NwYW4+XCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5ncm91cCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLnByb2dyYW0oMywgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICByZXR1cm4gYnVmZmVyICsgXCI8c3BhbiBjbGFzcz1cXFwiYWZ0ZXJcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuYWZ0ZXIgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmFmdGVyIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImFmdGVyXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIjwvc3Bhbj5cIjtcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKHtcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICByZXR1cm4gXCI8Zm9ybT5cXG4gIDxkaXYgY2xhc3M9XFxcImVkaXRvclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInBhcmFtc1xcXCI+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b25zXFxcIj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2Zvcm0+XCI7XG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0pO1xuIiwiLy8gV2UgZG9uJ3QgdXNlIHRoZSBwbGF0Zm9ybSBib290c3RyYXBwZXIsIHNvIGZha2UgdGhpcyBzdHVmZi5cblxud2luZG93LlBsYXRmb3JtID0ge307XG52YXIgbG9nRmxhZ3MgPSB7fTtcblxuXG4vLyBET01Ub2tlbkxpc3QgcG9seWZpbGwgZm9yIElFOVxuKGZ1bmN0aW9uICgpIHtcblxuaWYgKHR5cGVvZiB3aW5kb3cuRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBcImNsYXNzTGlzdFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgcmV0dXJuO1xuXG52YXIgcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGluZGV4T2YgPSBwcm90b3R5cGUuaW5kZXhPZixcbiAgICBzbGljZSA9IHByb3RvdHlwZS5zbGljZSxcbiAgICBwdXNoID0gcHJvdG90eXBlLnB1c2gsXG4gICAgc3BsaWNlID0gcHJvdG90eXBlLnNwbGljZSxcbiAgICBqb2luID0gcHJvdG90eXBlLmpvaW47XG5cbmZ1bmN0aW9uIERPTVRva2VuTGlzdChlbCkge1xuICB0aGlzLl9lbGVtZW50ID0gZWw7XG4gIGlmIChlbC5jbGFzc05hbWUgIT0gdGhpcy5fY2xhc3NDYWNoZSkge1xuICAgIHRoaXMuX2NsYXNzQ2FjaGUgPSBlbC5jbGFzc05hbWU7XG5cbiAgICBpZiAoIXRoaXMuX2NsYXNzQ2FjaGUpIHJldHVybjtcblxuICAgICAgLy8gVGhlIGNsYXNzTmFtZSBuZWVkcyB0byBiZSB0cmltbWVkIGFuZCBzcGxpdCBvbiB3aGl0ZXNwYWNlXG4gICAgICAvLyB0byByZXRyaWV2ZSBhIGxpc3Qgb2YgY2xhc3Nlcy5cbiAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5fY2xhc3NDYWNoZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCcnKS5zcGxpdCgvXFxzKy8pLFxuICAgICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwdXNoLmNhbGwodGhpcywgY2xhc3Nlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRUb0NsYXNzTmFtZShlbCwgY2xhc3Nlcykge1xuICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbn1cblxuRE9NVG9rZW5MaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbih0b2tlbikge1xuICAgIGlmKHRoaXMuY29udGFpbnModG9rZW4pKSByZXR1cm47XG4gICAgcHVzaC5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICBzZXRUb0NsYXNzTmFtZSh0aGlzLl9lbGVtZW50LCBzbGljZS5jYWxsKHRoaXMsIDApKTtcbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgcmV0dXJuIGluZGV4T2YuY2FsbCh0aGlzLCB0b2tlbikgIT09IC0xO1xuICB9LFxuICBpdGVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzW2luZGV4XSB8fCBudWxsO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICByZXR1cm47XG4gICAgIH1cbiAgICBzcGxpY2UuY2FsbCh0aGlzLCBpLCAxKTtcbiAgICBzZXRUb0NsYXNzTmFtZSh0aGlzLl9lbGVtZW50LCBzbGljZS5jYWxsKHRoaXMsIDApKTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBqb2luLmNhbGwodGhpcywgJyAnKTtcbiAgfSxcbiAgdG9nZ2xlOiBmdW5jdGlvbih0b2tlbikge1xuICAgIGlmIChpbmRleE9mLmNhbGwodGhpcywgdG9rZW4pID09PSAtMSkge1xuICAgICAgdGhpcy5hZGQodG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZSh0b2tlbik7XG4gICAgfVxuICB9XG59O1xuXG53aW5kb3cuRE9NVG9rZW5MaXN0ID0gRE9NVG9rZW5MaXN0O1xuXG5mdW5jdGlvbiBkZWZpbmVFbGVtZW50R2V0dGVyIChvYmosIHByb3AsIGdldHRlcikge1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCx7XG4gICAgICBnZXQgOiBnZXR0ZXJcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIG9iai5fX2RlZmluZUdldHRlcl9fKHByb3AsIGdldHRlcik7XG4gIH1cbn1cblxuZGVmaW5lRWxlbWVudEdldHRlcihFbGVtZW50LnByb3RvdHlwZSwgJ2NsYXNzTGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBET01Ub2tlbkxpc3QodGhpcyk7XG59KTtcblxufSkoKTtcblxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTIgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG4gKi9cblxuaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcblxuICAgIHZhciBXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5hbWUgPSAnX19zdCcgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrICsgJ19fJyk7XG4gICAgfTtcblxuICAgIFdlYWtNYXAucHJvdG90eXBlID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSlcbiAgICAgICAgICBlbnRyeVsxXSA9IHZhbHVlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkoa2V5LCB0aGlzLm5hbWUsIHt2YWx1ZTogW2tleSwgdmFsdWVdLCB3cml0YWJsZTogdHJ1ZX0pO1xuICAgICAgfSxcbiAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgcmV0dXJuIChlbnRyeSA9IGtleVt0aGlzLm5hbWVdKSAmJiBlbnRyeVswXSA9PT0ga2V5ID9cbiAgICAgICAgICAgIGVudHJ5WzFdIDogdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRoaXMuc2V0KGtleSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LldlYWtNYXAgPSBXZWFrTWFwO1xuICB9KSgpO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IDIwMTIgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVyZW5lZCBieSBhIEJTRC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlLlxuICovXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICB2YXIgcmVnaXN0cmF0aW9uc1RhYmxlID0gbmV3IFdlYWtNYXAoKTtcblxuICAvLyBXZSB1c2Ugc2V0SW1tZWRpYXRlIG9yIHBvc3RNZXNzYWdlIGZvciBvdXIgZnV0dXJlIGNhbGxiYWNrLlxuICB2YXIgc2V0SW1tZWRpYXRlID0gd2luZG93Lm1zU2V0SW1tZWRpYXRlO1xuXG4gIC8vIFVzZSBwb3N0IG1lc3NhZ2UgdG8gZW11bGF0ZSBzZXRJbW1lZGlhdGUuXG4gIGlmICghc2V0SW1tZWRpYXRlKSB7XG4gICAgdmFyIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgdmFyIHNlbnRpbmVsID0gU3RyaW5nKE1hdGgucmFuZG9tKCkpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gc2V0SW1tZWRpYXRlUXVldWU7XG4gICAgICAgIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShzZW50aW5lbCwgJyonKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IHdlIG5ldmVyIHNjaGVkdWxlIDIgY2FsbGFzIHRvIHNldEltbWVkaWF0ZVxuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBLZWVwIHRyYWNrIG9mIG9ic2VydmVycyB0aGF0IG5lZWRzIHRvIGJlIG5vdGlmaWVkIG5leHQgdGltZS5cbiAgdmFyIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgfGRpc3BhdGNoQ2FsbGJhY2t8IHRvIGJlIGNhbGxlZCBpbiB0aGUgZnV0dXJlLlxuICAgKiBAcGFyYW0ge011dGF0aW9uT2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAqL1xuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKG9ic2VydmVyKSB7XG4gICAgc2NoZWR1bGVkT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldEltbWVkaWF0ZShkaXNwYXRjaENhbGxiYWNrcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcElmTmVlZGVkKG5vZGUpIHtcbiAgICByZXR1cm4gd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmXG4gICAgICAgIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbC53cmFwSWZOZWVkZWQobm9kZSkgfHxcbiAgICAgICAgbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2tzKCkge1xuICAgIC8vIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNtdXRhdGlvbi1vYnNlcnZlcnNcblxuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7IC8vIFVzZWQgdG8gYWxsb3cgYSBuZXcgc2V0SW1tZWRpYXRlIGNhbGwgYWJvdmUuXG5cbiAgICB2YXIgb2JzZXJ2ZXJzID0gc2NoZWR1bGVkT2JzZXJ2ZXJzO1xuICAgIHNjaGVkdWxlZE9ic2VydmVycyA9IFtdO1xuICAgIC8vIFNvcnQgb2JzZXJ2ZXJzIGJhc2VkIG9uIHRoZWlyIGNyZWF0aW9uIFVJRCAoaW5jcmVtZW50YWwpLlxuICAgIG9ic2VydmVycy5zb3J0KGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgcmV0dXJuIG8xLnVpZF8gLSBvMi51aWRfO1xuICAgIH0pO1xuXG4gICAgdmFyIGFueU5vbkVtcHR5ID0gZmFsc2U7XG4gICAgb2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24ob2JzZXJ2ZXIpIHtcblxuICAgICAgLy8gMi4xLCAyLjJcbiAgICAgIHZhciBxdWV1ZSA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAvLyAyLjMuIFJlbW92ZSBhbGwgdHJhbnNpZW50IHJlZ2lzdGVyZWQgb2JzZXJ2ZXJzIHdob3NlIG9ic2VydmVyIGlzIG1vLlxuICAgICAgcmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yKG9ic2VydmVyKTtcblxuICAgICAgLy8gMi40XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrXyhxdWV1ZSwgb2JzZXJ2ZXIpO1xuICAgICAgICBhbnlOb25FbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAzLlxuICAgIGlmIChhbnlOb25FbXB0eSlcbiAgICAgIGRpc3BhdGNoQ2FsbGJhY2tzKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnNGb3Iob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbnMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gb2JzZXJ2ZXIpXG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciB0aGUgXCJGb3IgZWFjaCByZWdpc3RlcmVkIG9ic2VydmVyIG9ic2VydmVyICh3aXRoXG4gICAqIG9ic2VydmVyJ3Mgb3B0aW9ucyBhcyBvcHRpb25zKSBpbiB0YXJnZXQncyBsaXN0IG9mIHJlZ2lzdGVyZWQgb2JzZXJ2ZXJzLFxuICAgKiBydW4gdGhlc2Ugc3Vic3RlcHM6XCIgYW5kIHRoZSBcIkZvciBlYWNoIGFuY2VzdG9yIGFuY2VzdG9yIG9mIHRhcmdldCwgYW5kIGZvclxuICAgKiBlYWNoIHJlZ2lzdGVyZWQgb2JzZXJ2ZXIgb2JzZXJ2ZXIgKHdpdGggb3B0aW9ucyBvcHRpb25zKSBpbiBhbmNlc3RvcidzIGxpc3RcbiAgICogb2YgcmVnaXN0ZXJlZCBvYnNlcnZlcnMsIHJ1biB0aGVzZSBzdWJzdGVwczpcIiBwYXJ0IG9mIHRoZSBhbGdvcml0aG1zLiBUaGVcbiAgICogfG9wdGlvbnMuc3VidHJlZXwgaXMgY2hlY2tlZCB0byBlbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkXG4gICAqIGNvcnJlY3RseS5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihNdXRhdGlvbk9ic2VydmVySW5pdCk6TXV0YXRpb25SZWNvcmR9IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIG5vZGUgPSB0YXJnZXQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbal07XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSByZWdpc3RyYXRpb24ub3B0aW9ucztcblxuICAgICAgICAgIC8vIE9ubHkgdGFyZ2V0IGlnbm9yZXMgc3VidHJlZS5cbiAgICAgICAgICBpZiAobm9kZSAhPT0gdGFyZ2V0ICYmICFvcHRpb25zLnN1YnRyZWUpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgIHZhciByZWNvcmQgPSBjYWxsYmFjayhvcHRpb25zKTtcbiAgICAgICAgICBpZiAocmVjb3JkKVxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLmVucXVldWUocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1aWRDb3VudGVyID0gMDtcblxuICAvKipcbiAgICogVGhlIGNsYXNzIHRoYXQgbWFwcyB0byB0aGUgRE9NIE11dGF0aW9uT2JzZXJ2ZXIgaW50ZXJmYWNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjay5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBKc011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMubm9kZXNfID0gW107XG4gICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIHRoaXMudWlkXyA9ICsrdWlkQ291bnRlcjtcbiAgfVxuXG4gIEpzTXV0YXRpb25PYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gICAgb2JzZXJ2ZTogZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICB0YXJnZXQgPSB3cmFwSWZOZWVkZWQodGFyZ2V0KTtcblxuICAgICAgLy8gMS4xXG4gICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0ICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSB8fFxuXG4gICAgICAgICAgLy8gMS4yXG4gICAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVPbGRWYWx1ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzIHx8XG5cbiAgICAgICAgICAvLyAxLjNcbiAgICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiZcbiAgICAgICAgICAgICAgIW9wdGlvbnMuYXR0cmlidXRlcyB8fFxuXG4gICAgICAgICAgLy8gMS40XG4gICAgICAgICAgb3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkge1xuXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQodGFyZ2V0KTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucylcbiAgICAgICAgcmVnaXN0cmF0aW9uc1RhYmxlLnNldCh0YXJnZXQsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG5cbiAgICAgIC8vIDJcbiAgICAgIC8vIElmIHRhcmdldCdzIGxpc3Qgb2YgcmVnaXN0ZXJlZCBvYnNlcnZlcnMgYWxyZWFkeSBpbmNsdWRlcyBhIHJlZ2lzdGVyZWRcbiAgICAgIC8vIG9ic2VydmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29udGV4dCBvYmplY3QsIHJlcGxhY2UgdGhhdCByZWdpc3RlcmVkXG4gICAgICAvLyBvYnNlcnZlcidzIG9wdGlvbnMgd2l0aCBvcHRpb25zLlxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXS5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAzLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBhZGQgYSBuZXcgcmVnaXN0ZXJlZCBvYnNlcnZlciB0byB0YXJnZXQncyBsaXN0IG9mIHJlZ2lzdGVyZWRcbiAgICAgIC8vIG9ic2VydmVycyB3aXRoIHRoZSBjb250ZXh0IG9iamVjdCBhcyB0aGUgb2JzZXJ2ZXIgYW5kIG9wdGlvbnMgYXMgdGhlXG4gICAgICAvLyBvcHRpb25zLCBhbmQgYWRkIHRhcmdldCB0byBjb250ZXh0IG9iamVjdCdzIGxpc3Qgb2Ygbm9kZXMgb24gd2hpY2ggaXRcbiAgICAgIC8vIGlzIHJlZ2lzdGVyZWQuXG4gICAgICBpZiAoIXJlZ2lzdHJhdGlvbikge1xuICAgICAgICByZWdpc3RyYXRpb24gPSBuZXcgUmVnaXN0cmF0aW9uKHRoaXMsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xuICAgICAgICB0aGlzLm5vZGVzXy5wdXNoKHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJlZ2lzdHJhdGlvbi5hZGRMaXN0ZW5lcnMoKTtcbiAgICB9LFxuXG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tpXTtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZWdpc3RyYXRpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICByZWdpc3RyYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIC8vIEVhY2ggbm9kZSBjYW4gb25seSBoYXZlIG9uZSByZWdpc3RlcmVkIG9ic2VydmVyIGFzc29jaWF0ZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhpcyBvYnNlcnZlci5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLnJlY29yZHNfID0gW107XG4gICAgfSxcblxuICAgIHRha2VSZWNvcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb3B5T2ZSZWNvcmRzID0gdGhpcy5yZWNvcmRzXztcbiAgICAgIHRoaXMucmVjb3Jkc18gPSBbXTtcbiAgICAgIHJldHVybiBjb3B5T2ZSZWNvcmRzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBudWxsO1xuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY29weU11dGF0aW9uUmVjb3JkKG9yaWdpbmFsKSB7XG4gICAgdmFyIHJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZChvcmlnaW5hbC50eXBlLCBvcmlnaW5hbC50YXJnZXQpO1xuICAgIHJlY29yZC5hZGRlZE5vZGVzID0gb3JpZ2luYWwuYWRkZWROb2Rlcy5zbGljZSgpO1xuICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSBvcmlnaW5hbC5yZW1vdmVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucHJldmlvdXNTaWJsaW5nID0gb3JpZ2luYWwucHJldmlvdXNTaWJsaW5nO1xuICAgIHJlY29yZC5uZXh0U2libGluZyA9IG9yaWdpbmFsLm5leHRTaWJsaW5nO1xuICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZTtcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gb3JpZ2luYWwuYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgIHJlY29yZC5vbGRWYWx1ZSA9IG9yaWdpbmFsLm9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH07XG5cbiAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGUgdHdvIChwb3NzaWJseSBvbmUpIHJlY29yZHMgdXNlZCBpbiBhIHNpbmdsZSBtdXRhdGlvbi5cbiAgdmFyIGN1cnJlbnRSZWNvcmQsIHJlY29yZFdpdGhPbGRWYWx1ZTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlY29yZCB3aXRob3V0IHxvbGRWYWx1ZXwgYW5kIGNhY2hlcyBpdCBhcyB8Y3VycmVudFJlY29yZHwgZm9yXG4gICAqIGxhdGVyIHVzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFZhbHVlXG4gICAqIEByZXR1cm4ge011dGF0aW9uUmVjb3JkfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVjb3JkKHR5cGUsIHRhcmdldCkge1xuICAgIHJldHVybiBjdXJyZW50UmVjb3JkID0gbmV3IE11dGF0aW9uUmVjb3JkKHR5cGUsIHRhcmdldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBvciBjcmVhdGVzIGEgcmVjb3JkIHdpdGggfG9sZFZhbHVlfCBiYXNlZCBpbiB0aGUgfGN1cnJlbnRSZWNvcmR8XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRWYWx1ZVxuICAgKiBAcmV0dXJuIHtNdXRhdGlvblJlY29yZH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSkge1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpXG4gICAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZSA9IGNvcHlNdXRhdGlvblJlY29yZChjdXJyZW50UmVjb3JkKTtcbiAgICByZWNvcmRXaXRoT2xkVmFsdWUub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkV2l0aE9sZFZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJSZWNvcmRzKCkge1xuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNdXRhdGlvblJlY29yZH0gcmVjb3JkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlY29yZCByZXByZXNlbnRzIGEgcmVjb3JkIGZyb20gdGhlIGN1cnJlbnRcbiAgICogbXV0YXRpb24gZXZlbnQuXG4gICAqL1xuICBmdW5jdGlvbiByZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uKHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQgPT09IHJlY29yZFdpdGhPbGRWYWx1ZSB8fCByZWNvcmQgPT09IGN1cnJlbnRSZWNvcmQ7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyB3aGljaCByZWNvcmQsIGlmIGFueSwgdG8gcmVwbGFjZSB0aGUgbGFzdCByZWNvcmQgaW4gdGhlIHF1ZXVlLlxuICAgKiBUaGlzIHJldHVybnMgfG51bGx8IGlmIG5vIHJlY29yZCBzaG91bGQgYmUgcmVwbGFjZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TXV0YXRpb25SZWNvcmR9IGxhc3RSZWNvcmRcbiAgICogQHBhcmFtIHtNdXRhdGlvblJlY29yZH0gbmV3UmVjb3JkXG4gICAqIEBwYXJhbSB7TXV0YXRpb25SZWNvcmR9XG4gICAqL1xuICBmdW5jdGlvbiBzZWxlY3RSZWNvcmQobGFzdFJlY29yZCwgbmV3UmVjb3JkKSB7XG4gICAgaWYgKGxhc3RSZWNvcmQgPT09IG5ld1JlY29yZClcbiAgICAgIHJldHVybiBsYXN0UmVjb3JkO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRoZSByZWNvcmQgd2UgYXJlIGFkZGluZyByZXByZXNlbnRzIHRoZSBzYW1lIHJlY29yZC4gSWZcbiAgICAvLyBzbywgd2Uga2VlcCB0aGUgb25lIHdpdGggdGhlIG9sZFZhbHVlIGluIGl0LlxuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUgJiYgcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihsYXN0UmVjb3JkKSlcbiAgICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFzcyB1c2VkIHRvIHJlcHJlc2VudCBhIHJlZ2lzdGVyZWQgb2JzZXJ2ZXIuXG4gICAqIEBwYXJhbSB7TXV0YXRpb25PYnNlcnZlcn0gb2JzZXJ2ZXJcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtNdXRhdGlvbk9ic2VydmVySW5pdH0gb3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFJlZ2lzdHJhdGlvbihvYnNlcnZlciwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50cmFuc2llbnRPYnNlcnZlZE5vZGVzID0gW107XG4gIH1cblxuICBSZWdpc3RyYXRpb24ucHJvdG90eXBlID0ge1xuICAgIGVucXVldWU6IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xuICAgICAgdmFyIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgY2FzZXMgd2hlcmUgd2UgcmVwbGFjZSB0aGUgbGFzdCByZWNvcmQgd2l0aCB0aGUgbmV3IHJlY29yZC5cbiAgICAgIC8vIEZvciBleGFtcGxlIGlmIHRoZSByZWNvcmQgcmVwcmVzZW50cyB0aGUgc2FtZSBtdXRhdGlvbiB3ZSBuZWVkIHRvIHVzZVxuICAgICAgLy8gdGhlIG9uZSB3aXRoIHRoZSBvbGRWYWx1ZS4gSWYgd2UgZ2V0IHNhbWUgcmVjb3JkICh0aGlzIGNhbiBoYXBwZW4gYXMgd2VcbiAgICAgIC8vIHdhbGsgdXAgdGhlIHRyZWUpIHdlIGlnbm9yZSB0aGUgbmV3IHJlY29yZC5cbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGxhc3RSZWNvcmQgPSByZWNvcmRzW2xlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmVjb3JkVG9SZXBsYWNlTGFzdCA9IHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCByZWNvcmQpO1xuICAgICAgICBpZiAocmVjb3JkVG9SZXBsYWNlTGFzdCkge1xuICAgICAgICAgIHJlY29yZHNbbGVuZ3RoIC0gMV0gPSByZWNvcmRUb1JlcGxhY2VMYXN0O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayh0aGlzLm9ic2VydmVyKTtcbiAgICAgIH1cblxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xuICAgIH0sXG5cbiAgICBhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgYWRkTGlzdGVuZXJzXzogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKVxuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUF0dHJNb2RpZmllZCcsIHRoaXMsIHRydWUpO1xuXG4gICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhKVxuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNoYXJhY3RlckRhdGFNb2RpZmllZCcsIHRoaXMsIHRydWUpO1xuXG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QpXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgdGhpcywgdHJ1ZSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCB8fCBvcHRpb25zLnN1YnRyZWUpXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWQnLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcblxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcylcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdET01BdHRyTW9kaWZpZWQnLCB0aGlzLCB0cnVlKTtcblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSlcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQnLCB0aGlzLCB0cnVlKTtcblxuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KVxuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIHRoaXMsIHRydWUpO1xuXG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKVxuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgdGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0cmFuc2llbnQgb2JzZXJ2ZXIgb24gbm9kZS4gVGhlIHRyYW5zaWVudCBvYnNlcnZlciBnZXRzIHJlbW92ZWRcbiAgICAgKiBuZXh0IHRpbWUgd2UgZGVsaXZlciB0aGUgY2hhbmdlIHJlY29yZHMuXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICovXG4gICAgYWRkVHJhbnNpZW50T2JzZXJ2ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIC8vIERvbid0IGFkZCB0cmFuc2llbnQgb2JzZXJ2ZXJzIG9uIHRoZSB0YXJnZXQgaXRzZWxmLiBXZSBhbHJlYWR5IGhhdmUgYWxsXG4gICAgICAvLyB0aGUgcmVxdWlyZWQgbGlzdGVuZXJzIHNldCB1cCBvbiB0aGUgdGFyZ2V0LlxuICAgICAgaWYgKG5vZGUgPT09IHRoaXMudGFyZ2V0KVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKVxuICAgICAgICByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG5cbiAgICAgIC8vIFdlIGtub3cgdGhhdCByZWdpc3RyYXRpb25zIGRvZXMgbm90IGNvbnRhaW4gdGhpcyBiZWNhdXNlIHdlIGFscmVhZHlcbiAgICAgIC8vIGNoZWNrZWQgaWYgbm9kZSA9PT0gdGhpcy50YXJnZXQuXG4gICAgICByZWdpc3RyYXRpb25zLnB1c2godGhpcyk7XG4gICAgfSxcblxuICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcztcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2RlcyA9IFtdO1xuXG4gICAgICB0cmFuc2llbnRPYnNlcnZlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAvLyBUcmFuc2llbnQgb2JzZXJ2ZXJzIGFyZSBuZXZlciBhZGRlZCB0byB0aGUgdGFyZ2V0LlxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyc18obm9kZSk7XG5cbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAvLyBFYWNoIG5vZGUgY2FuIG9ubHkgaGF2ZSBvbmUgcmVnaXN0ZXJlZCBvYnNlcnZlciBhc3NvY2lhdGVkIHdpdGhcbiAgICAgICAgICAgIC8vIHRoaXMgb2JzZXJ2ZXIuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgLy8gU3RvcCBwcm9wYWdhdGlvbiBzaW5jZSB3ZSBhcmUgbWFuYWdpbmcgdGhlIHByb3BhZ2F0aW9uIG1hbnVhbGx5LlxuICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IG90aGVyIG11dGF0aW9uIGV2ZW50cyBvbiB0aGUgcGFnZSB3aWxsIG5vdCB3b3JrXG4gICAgICAvLyBjb3JyZWN0bHkgYnV0IHRoYXQgaXMgYnkgZGVzaWduLlxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnRE9NQXR0ck1vZGlmaWVkJzpcbiAgICAgICAgICAvLyBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tby1xdWV1ZS1hdHRyaWJ1dGVzXG5cbiAgICAgICAgICB2YXIgbmFtZSA9IGUuYXR0ck5hbWU7XG4gICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IGUucmVsYXRlZE5vZGUubmFtZXNwYWNlVVJJO1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcblxuICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoJ2F0dHJpYnV0ZXMnLCB0YXJnZXQpO1xuICAgICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgICAgICByZWNvcmQuYXR0cmlidXRlTmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gICAgICAgICAgLy8gMi5cbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPVxuICAgICAgICAgICAgICBlLmF0dHJDaGFuZ2UgPT09IE11dGF0aW9uRXZlbnQuQURESVRJT04gPyBudWxsIDogZS5wcmV2VmFsdWU7XG5cbiAgICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyAzLjEsIDQuMlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gMy4yLCA0LjNcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZUZpbHRlciAmJiBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZUZpbHRlci5pbmRleE9mKG5hbWUpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMy4zLCA0LjRcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlKVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcblxuICAgICAgICAgICAgLy8gMy40LCA0LjVcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQnOlxuICAgICAgICAgIC8vIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1vLXF1ZXVlLWNoYXJhY3RlcmRhdGFcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICAgICAgICAvLyAxLlxuICAgICAgICAgIHZhciByZWNvcmQgPSBnZXRSZWNvcmQoJ2NoYXJhY3RlckRhdGEnLCB0YXJnZXQpO1xuXG4gICAgICAgICAgLy8gMi5cbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLnByZXZWYWx1ZTtcblxuXG4gICAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgLy8gMy4xLCA0LjJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKVxuICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIDMuMiwgNC4zXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUpXG4gICAgICAgICAgICAgIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuXG4gICAgICAgICAgICAvLyAzLjMsIDQuNFxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0RPTU5vZGVSZW1vdmVkJzpcbiAgICAgICAgICB0aGlzLmFkZFRyYW5zaWVudE9ic2VydmVyKGUudGFyZ2V0KTtcbiAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICAgIGNhc2UgJ0RPTU5vZGVJbnNlcnRlZCc6XG4gICAgICAgICAgLy8gaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbW8tcXVldWUtY2hpbGRsaXN0XG4gICAgICAgICAgdmFyIHRhcmdldCA9IGUucmVsYXRlZE5vZGU7XG4gICAgICAgICAgdmFyIGNoYW5nZWROb2RlID0gZS50YXJnZXQ7XG4gICAgICAgICAgdmFyIGFkZGVkTm9kZXMsIHJlbW92ZWROb2RlcztcbiAgICAgICAgICBpZiAoZS50eXBlID09PSAnRE9NTm9kZUluc2VydGVkJykge1xuICAgICAgICAgICAgYWRkZWROb2RlcyA9IFtjaGFuZ2VkTm9kZV07XG4gICAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBhZGRlZE5vZGVzID0gW107XG4gICAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbY2hhbmdlZE5vZGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gY2hhbmdlZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKCdjaGlsZExpc3QnLCB0YXJnZXQpO1xuICAgICAgICAgIHJlY29yZC5hZGRlZE5vZGVzID0gYWRkZWROb2RlcztcbiAgICAgICAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzO1xuICAgICAgICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgcmVjb3JkLm5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyAyLjEsIDMuMlxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNoaWxkTGlzdClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyAyLjIsIDMuM1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgfVxuXG4gICAgICBjbGVhclJlY29yZHMoKTtcbiAgICB9XG4gIH07XG5cbiAgZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcblxuICBpZiAoIWdsb2JhbC5NdXRhdGlvbk9ic2VydmVyKVxuICAgIGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuXG5cbn0pKHRoaXMpO1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbi8qKlxuICogSW1wbGVtZW50cyBgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50YFxuICogQG1vZHVsZSBDdXN0b21FbGVtZW50c1xuKi9cblxuLyoqXG4gKiBQb2x5ZmlsbGVkIGV4dGVuc2lvbnMgdG8gdGhlIGBkb2N1bWVudGAgb2JqZWN0LlxuICogQGNsYXNzIERvY3VtZW50XG4qL1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcblxuLy8gaW1wb3J0c1xuXG5pZiAoIXNjb3BlKSB7XG4gIHNjb3BlID0gd2luZG93LkN1c3RvbUVsZW1lbnRzID0ge2ZsYWdzOnt9fTtcbn1cbnZhciBmbGFncyA9IHNjb3BlLmZsYWdzO1xuXG4vLyBuYXRpdmUgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50P1xuXG52YXIgaGFzTmF0aXZlID0gQm9vbGVhbihkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQpO1xuLy8gRm9yIGNvbnNpc3RlbnQgdGltaW5nLCB1c2UgbmF0aXZlIGN1c3RvbSBlbGVtZW50cyBvbmx5IHdoZW4gbm90IHBvbHlmaWxsaW5nXG4vLyBvdGhlciBrZXkgcmVsYXRlZCB3ZWIgY29tcG9uZW50cyBmZWF0dXJlcy5cbnZhciB1c2VOYXRpdmUgPSAhZmxhZ3MucmVnaXN0ZXIgJiYgaGFzTmF0aXZlICYmICF3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgKCF3aW5kb3cuSFRNTEltcG9ydHMgfHwgSFRNTEltcG9ydHMudXNlTmF0aXZlKTtcblxuaWYgKHVzZU5hdGl2ZSkge1xuXG4gIC8vIHN0dWJcbiAgdmFyIG5vcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgLy8gZXhwb3J0c1xuICBzY29wZS5yZWdpc3RyeSA9IHt9O1xuICBzY29wZS51cGdyYWRlRWxlbWVudCA9IG5vcDtcblxuICBzY29wZS53YXRjaFNoYWRvdyA9IG5vcDtcbiAgc2NvcGUudXBncmFkZSA9IG5vcDtcbiAgc2NvcGUudXBncmFkZUFsbCA9IG5vcDtcbiAgc2NvcGUudXBncmFkZVN1YnRyZWUgPSBub3A7XG4gIHNjb3BlLm9ic2VydmVEb2N1bWVudCA9IG5vcDtcbiAgc2NvcGUudXBncmFkZURvY3VtZW50ID0gbm9wO1xuICBzY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlID0gbm9wO1xuICBzY29wZS50YWtlUmVjb3JkcyA9IG5vcDtcbiAgc2NvcGUucmVzZXJ2ZWRUYWdMaXN0ID0gW107XG5cbn0gZWxzZSB7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGN1c3RvbSB0YWcgbmFtZSB3aXRoIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogV2hlbiBhIHJlZ2lzdGVyZWQgZWxlbWVudCBpcyBjcmVhdGVkLCBhIGByZWFkeUNhbGxiYWNrYCBtZXRob2QgaXMgY2FsbGVkXG4gICAqIGluIHRoZSBzY29wZSBvZiB0aGUgZWxlbWVudC4gVGhlIGByZWFkeUNhbGxiYWNrYCBtZXRob2QgY2FuIGJlIHNwZWNpZmllZCBvblxuICAgKiBlaXRoZXIgYG9wdGlvbnMucHJvdG90eXBlYCBvciBgb3B0aW9ucy5saWZlY3ljbGVgIHdpdGggdGhlIGxhdHRlciB0YWtpbmdcbiAgICogcHJlY2VkZW5jZS5cbiAgICpcbiAgICogQG1ldGhvZCByZWdpc3RlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgdGFnIG5hbWUgdG8gcmVnaXN0ZXIuIE11c3QgaW5jbHVkZSBhIGRhc2ggKCctJyksXG4gICAqICAgIGZvciBleGFtcGxlICd4LWNvbXBvbmVudCcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5leHRlbmRzXVxuICAgKiAgICAgIChfb2ZmIHNwZWNfKSBUYWcgbmFtZSBvZiBhbiBlbGVtZW50IHRvIGV4dGVuZCAob3IgYmxhbmsgZm9yIGEgbmV3XG4gICAqICAgICAgZWxlbWVudCkuIFRoaXMgcGFyYW1ldGVyIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjaWZpY2F0aW9uLCBidXQgaW5zdGVhZFxuICAgKiAgICAgIGlzIGEgaGludCBmb3IgdGhlIHBvbHlmaWxsIGJlY2F1c2UgdGhlIGV4dGVuZGVlIGlzIGRpZmZpY3VsdCB0byBpbmZlci5cbiAgICogICAgICBSZW1lbWJlciB0aGF0IHRoZSBpbnB1dCBwcm90b3R5cGUgbXVzdCBjaGFpbiB0byB0aGUgZXh0ZW5kZWQgZWxlbWVudCdzXG4gICAqICAgICAgcHJvdG90eXBlIChvciBIVE1MRWxlbWVudC5wcm90b3R5cGUpIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mXG4gICAqICAgICAgYGV4dGVuZHNgLlxuICAgKiAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm90b3R5cGUgVGhlIHByb3RvdHlwZSB0byB1c2UgZm9yIHRoZSBuZXdcbiAgICogICAgICBlbGVtZW50LiBUaGUgcHJvdG90eXBlIG11c3QgaW5oZXJpdCBmcm9tIEhUTUxFbGVtZW50LlxuICAgKiAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGlmZWN5Y2xlXVxuICAgKiAgICAgIENhbGxiYWNrcyB0aGF0IGZpcmUgYXQgaW1wb3J0YW50IHBoYXNlcyBpbiB0aGUgbGlmZSBvZiB0aGUgY3VzdG9tXG4gICAqICAgICAgZWxlbWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgICBGYW5jeUJ1dHRvbiA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudChcImZhbmN5LWJ1dHRvblwiLCB7XG4gICAqICAgICAgICBleHRlbmRzOiAnYnV0dG9uJyxcbiAgICogICAgICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShIVE1MQnV0dG9uRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICogICAgICAgICAgcmVhZHlDYWxsYmFjazoge1xuICAgKiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYSBmYW5jeS1idXR0b24gd2FzIGNyZWF0ZWRcIixcbiAgICogICAgICAgICAgICB9XG4gICAqICAgICAgICAgIH1cbiAgICogICAgICAgIH0pXG4gICAqICAgICAgfSk7XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBDb25zdHJ1Y3RvciBmb3IgdGhlIG5ld2x5IHJlZ2lzdGVyZWQgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAvL2NvbnNvbGUud2FybignZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFwiJyArIG5hbWUgKyAnXCIsICcsIG9wdGlvbnMsICcpJyk7XG4gICAgLy8gY29uc3RydWN0IGEgZGVmaW50aW9uIG91dCBvZiBvcHRpb25zXG4gICAgLy8gVE9ETyhzam1pbGVzKTogcHJvYmFibHkgc2hvdWxkIGNsb25lIG9wdGlvbnMgaW5zdGVhZCBvZiBtdXRhdGluZyBpdFxuICAgIHZhciBkZWZpbml0aW9uID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIC8vIFRPRE8oc2ptaWxlcyk6IHJlcGxhY2Ugd2l0aCBtb3JlIGFwcHJvcHJpYXRlIGVycm9yIChFcmljQiBjYW4gcHJvYmFibHlcbiAgICAgIC8vIG9mZmVyIGd1aWRhbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQ6IGZpcnN0IGFyZ3VtZW50IGBuYW1lYCBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgIH1cbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPCAwKSB7XG4gICAgICAvLyBUT0RPKHNqbWlsZXMpOiByZXBsYWNlIHdpdGggbW9yZSBhcHByb3ByaWF0ZSBlcnJvciAoRXJpY0IgY2FuIHByb2JhYmx5XG4gICAgICAvLyBvZmZlciBndWlkYW5jZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50OiBmaXJzdCBhcmd1bWVudCAoXFwnbmFtZVxcJykgbXVzdCBjb250YWluIGEgZGFzaCAoXFwnLVxcJykuIEFyZ3VtZW50IHByb3ZpZGVkIHdhcyBcXCcnICsgU3RyaW5nKG5hbWUpICsgJ1xcJy4nKTtcbiAgICB9XG4gICAgLy8gcHJldmVudCByZWdpc3RlcmluZyByZXNlcnZlZCBuYW1lc1xuICAgIGlmIChpc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFxcJ3JlZ2lzdGVyRWxlbWVudFxcJyBvbiBcXCdEb2N1bWVudFxcJzogUmVnaXN0cmF0aW9uIGZhaWxlZCBmb3IgdHlwZSBcXCcnICsgU3RyaW5nKG5hbWUpICsgJ1xcJy4gVGhlIHR5cGUgbmFtZSBpcyBpbnZhbGlkLicpO1xuICAgIH1cbiAgICAvLyBlbGVtZW50cyBtYXkgb25seSBiZSByZWdpc3RlcmVkIG9uY2VcbiAgICBpZiAoZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24obmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlRGVmaW5pdGlvbkVycm9yOiBhIHR5cGUgd2l0aCBuYW1lIFxcJycgKyBTdHJpbmcobmFtZSkgKyAnXFwnIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICAgIH1cbiAgICAvLyBtdXN0IGhhdmUgYSBwcm90b3R5cGUsIGRlZmF1bHQgdG8gYW4gZXh0ZW5zaW9uIG9mIEhUTUxFbGVtZW50XG4gICAgLy8gVE9ETyhzam1pbGVzKTogcHJvYmFibHkgc2hvdWxkIHRocm93IGlmIG5vIHByb3RvdHlwZSwgY2hlY2sgc3BlY1xuICAgIGlmICghZGVmaW5pdGlvbi5wcm90b3R5cGUpIHtcbiAgICAgIC8vIFRPRE8oc2ptaWxlcyk6IHJlcGxhY2Ugd2l0aCBtb3JlIGFwcHJvcHJpYXRlIGVycm9yIChFcmljQiBjYW4gcHJvYmFibHlcbiAgICAgIC8vIG9mZmVyIGd1aWRhbmNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIG1pc3NpbmcgcmVxdWlyZWQgcHJvdG90eXBlIHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIC8vIHJlY29yZCBuYW1lXG4gICAgZGVmaW5pdGlvbi5fX25hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZW5zdXJlIGEgbGlmZWN5Y2xlIG9iamVjdCBzbyB3ZSBkb24ndCBoYXZlIHRvIG51bGwgdGVzdCBpdFxuICAgIGRlZmluaXRpb24ubGlmZWN5Y2xlID0gZGVmaW5pdGlvbi5saWZlY3ljbGUgfHwge307XG4gICAgLy8gYnVpbGQgYSBsaXN0IG9mIGFuY2VzdHJhbCBjdXN0b20gZWxlbWVudHMgKGZvciBuYXRpdmUgYmFzZSBkZXRlY3Rpb24pXG4gICAgLy8gVE9ETyhzam1pbGVzKTogd2UgdXNlZCB0byBuZWVkIHRvIHN0b3JlIHRoaXMsIGJ1dCBjdXJyZW50IGNvZGUgb25seVxuICAgIC8vIHVzZXMgaXQgaW4gJ3Jlc29sdmVUYWdOYW1lJzogaXQgc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWRcbiAgICBkZWZpbml0aW9uLmFuY2VzdHJ5ID0gYW5jZXN0cnkoZGVmaW5pdGlvbi5leHRlbmRzKTtcbiAgICAvLyBleHRlbnNpb25zIG9mIG5hdGl2ZSBzcGVjaWFsaXphdGlvbnMgb2YgSFRNTEVsZW1lbnQgcmVxdWlyZSBsb2NhbE5hbWVcbiAgICAvLyB0byByZW1haW4gbmF0aXZlLCBhbmQgdXNlIHNlY29uZGFyeSAnaXMnIHNwZWNpZmllciBmb3IgZXh0ZW5zaW9uIHR5cGVcbiAgICByZXNvbHZlVGFnTmFtZShkZWZpbml0aW9uKTtcbiAgICAvLyBzb21lIHBsYXRmb3JtcyByZXF1aXJlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIHVzZXItc3VwcGxpZWQgcHJvdG90eXBlXG4gICAgLy8gY2hhaW5cbiAgICByZXNvbHZlUHJvdG90eXBlQ2hhaW4oZGVmaW5pdGlvbik7XG4gICAgLy8gb3ZlcnJpZGVzIHRvIGltcGxlbWVudCBhdHRyaWJ1dGVDaGFuZ2VkIGNhbGxiYWNrXG4gICAgb3ZlcnJpZGVBdHRyaWJ1dGVBcGkoZGVmaW5pdGlvbi5wcm90b3R5cGUpO1xuICAgIC8vIDcuMS41OiBSZWdpc3RlciB0aGUgREVGSU5JVElPTiB3aXRoIERPQ1VNRU5UXG4gICAgcmVnaXN0ZXJEZWZpbml0aW9uKGRlZmluaXRpb24uX19uYW1lLCBkZWZpbml0aW9uKTtcbiAgICAvLyA3LjEuNy4gUnVuIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9yIGdlbmVyYXRpb24gYWxnb3JpdGhtIHdpdGggUFJPVE9UWVBFXG4gICAgLy8gNy4xLjguIFJldHVybiB0aGUgb3V0cHV0IG9mIHRoZSBwcmV2aW91cyBzdGVwLlxuICAgIGRlZmluaXRpb24uY3RvciA9IGdlbmVyYXRlQ29uc3RydWN0b3IoZGVmaW5pdGlvbik7XG4gICAgZGVmaW5pdGlvbi5jdG9yLnByb3RvdHlwZSA9IGRlZmluaXRpb24ucHJvdG90eXBlO1xuICAgIC8vIGZvcmNlIG91ciAuY29uc3RydWN0b3IgdG8gYmUgb3VyIGFjdHVhbCBjb25zdHJ1Y3RvclxuICAgIGRlZmluaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZGVmaW5pdGlvbi5jdG9yO1xuICAgIC8vIGlmIGluaXRpYWwgcGFyc2luZyBpcyBjb21wbGV0ZVxuICAgIGlmIChzY29wZS5yZWFkeSkge1xuICAgICAgLy8gdXBncmFkZSBhbnkgcHJlLWV4aXN0aW5nIG5vZGVzIG9mIHRoaXMgdHlwZVxuICAgICAgc2NvcGUudXBncmFkZURvY3VtZW50VHJlZShkb2N1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uLmN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jlc2VydmVkVGFnKG5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkVGFnTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5hbWUgPT09IHJlc2VydmVkVGFnTGlzdFtpXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcmVzZXJ2ZWRUYWdMaXN0ID0gW1xuICAgICdhbm5vdGF0aW9uLXhtbCcsICdjb2xvci1wcm9maWxlJywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2Utc3JjJyxcbiAgICAnZm9udC1mYWNlLXVyaScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ21pc3NpbmctZ2x5cGgnXG4gIF07XG5cbiAgZnVuY3Rpb24gYW5jZXN0cnkoZXh0bmRzKSB7XG4gICAgdmFyIGV4dGVuZGVlID0gZ2V0UmVnaXN0ZXJlZERlZmluaXRpb24oZXh0bmRzKTtcbiAgICBpZiAoZXh0ZW5kZWUpIHtcbiAgICAgIHJldHVybiBhbmNlc3RyeShleHRlbmRlZS5leHRlbmRzKS5jb25jYXQoW2V4dGVuZGVlXSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVUYWdOYW1lKGRlZmluaXRpb24pIHtcbiAgICAvLyBpZiB3ZSBhcmUgZXhwbGljaXRseSBleHRlbmRpbmcgc29tZXRoaW5nLCB0aGF0IHRoaW5nIGlzIG91clxuICAgIC8vIGJhc2VUYWcsIHVubGVzcyBpdCByZXByZXNlbnRzIGEgY3VzdG9tIGNvbXBvbmVudFxuICAgIHZhciBiYXNlVGFnID0gZGVmaW5pdGlvbi5leHRlbmRzO1xuICAgIC8vIGlmIG91ciBhbmNlc3RyeSBpbmNsdWRlcyBjdXN0b20gY29tcG9uZW50cywgd2Ugb25seSBoYXZlIGFcbiAgICAvLyBiYXNlVGFnIGlmIG9uZSBvZiB0aGVtIGRvZXNcbiAgICBmb3IgKHZhciBpPTAsIGE7IChhPWRlZmluaXRpb24uYW5jZXN0cnlbaV0pOyBpKyspIHtcbiAgICAgIGJhc2VUYWcgPSBhLmlzICYmIGEudGFnO1xuICAgIH1cbiAgICAvLyBvdXIgdGFnIGlzIG91ciBiYXNlVGFnLCBpZiBpdCBleGlzdHMsIGFuZCBvdGhlcndpc2UganVzdCBvdXIgbmFtZVxuICAgIGRlZmluaXRpb24udGFnID0gYmFzZVRhZyB8fCBkZWZpbml0aW9uLl9fbmFtZTtcbiAgICBpZiAoYmFzZVRhZykge1xuICAgICAgLy8gaWYgdGhlcmUgaXMgYSBiYXNlIHRhZywgdXNlIHNlY29uZGFyeSAnaXMnIHNwZWNpZmllclxuICAgICAgZGVmaW5pdGlvbi5pcyA9IGRlZmluaXRpb24uX19uYW1lO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVQcm90b3R5cGVDaGFpbihkZWZpbml0aW9uKSB7XG4gICAgLy8gaWYgd2UgZG9uJ3Qgc3VwcG9ydCBfX3Byb3RvX18gd2UgbmVlZCB0byBsb2NhdGUgdGhlIG5hdGl2ZSBsZXZlbFxuICAgIC8vIHByb3RvdHlwZSBmb3IgcHJlY2lzZSBtaXhpbmcgaW5cbiAgICBpZiAoIU9iamVjdC5fX3Byb3RvX18pIHtcbiAgICAgIC8vIGRlZmF1bHQgcHJvdG90eXBlXG4gICAgICB2YXIgbmF0aXZlUHJvdG90eXBlID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuICAgICAgLy8gd29yayBvdXQgcHJvdG90eXBlIHdoZW4gdXNpbmcgdHlwZS1leHRlbnNpb25cbiAgICAgIGlmIChkZWZpbml0aW9uLmlzKSB7XG4gICAgICAgIHZhciBpbnN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWZpbml0aW9uLnRhZyk7XG4gICAgICAgIHZhciBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0KTtcbiAgICAgICAgLy8gb25seSBzZXQgbmF0aXZlUHJvdG90eXBlIGlmIGl0IHdpbGwgYWN0dWFsbHkgYXBwZWFyIGluIHRoZSBkZWZpbml0aW9uJ3MgY2hhaW5cbiAgICAgICAgaWYgKGV4cGVjdGVkUHJvdG90eXBlID09PSBkZWZpbml0aW9uLnByb3RvdHlwZSkge1xuICAgICAgICAgIG5hdGl2ZVByb3RvdHlwZSA9IGV4cGVjdGVkUHJvdG90eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBlbnN1cmUgX19wcm90b19fIHJlZmVyZW5jZSBpcyBpbnN0YWxsZWQgYXQgZWFjaCBwb2ludCBvbiB0aGUgcHJvdG90eXBlXG4gICAgICAvLyBjaGFpbi5cbiAgICAgIC8vIE5PVEU6IE9uIHBsYXRmb3JtcyB3aXRob3V0IF9fcHJvdG9fXywgYSBtaXhpbiBzdHJhdGVneSBpcyB1c2VkIGluc3RlYWRcbiAgICAgIC8vIG9mIHByb3RvdHlwZSBzd2l6emxpbmcuIEluIHRoaXMgY2FzZSwgdGhpcyBnZW5lcmF0ZWQgX19wcm90b19fIHByb3ZpZGVzXG4gICAgICAvLyBsaW1pdGVkIHN1cHBvcnQgZm9yIHByb3RvdHlwZSB0cmF2ZXJzYWwuXG4gICAgICB2YXIgcHJvdG8gPSBkZWZpbml0aW9uLnByb3RvdHlwZSwgYW5jZXN0b3I7XG4gICAgICB3aGlsZSAocHJvdG8gJiYgKHByb3RvICE9PSBuYXRpdmVQcm90b3R5cGUpKSB7XG4gICAgICAgIGFuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICAgICAgcHJvdG8uX19wcm90b19fID0gYW5jZXN0b3I7XG4gICAgICAgIHByb3RvID0gYW5jZXN0b3I7XG4gICAgICB9XG4gICAgICAvLyBjYWNoZSB0aGlzIGluIGNhc2Ugb2YgbWl4aW5cbiAgICAgIGRlZmluaXRpb24ubmF0aXZlID0gbmF0aXZlUHJvdG90eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNFQ1RJT04gNFxuXG4gIGZ1bmN0aW9uIGluc3RhbnRpYXRlKGRlZmluaXRpb24pIHtcbiAgICAvLyA0LmEuMS4gQ3JlYXRlIGEgbmV3IG9iamVjdCB0aGF0IGltcGxlbWVudHMgUFJPVE9UWVBFXG4gICAgLy8gNC5hLjIuIExldCBFTEVNRU5UIGJ5IHRoaXMgbmV3IG9iamVjdFxuICAgIC8vXG4gICAgLy8gdGhlIGN1c3RvbSBlbGVtZW50IGluc3RhbnRpYXRpb24gYWxnb3JpdGhtIG11c3QgYWxzbyBlbnN1cmUgdGhhdCB0aGVcbiAgICAvLyBvdXRwdXQgaXMgYSB2YWxpZCBET00gZWxlbWVudCB3aXRoIHRoZSBwcm9wZXIgd3JhcHBlciBpbiBwbGFjZS5cbiAgICAvL1xuICAgIHJldHVybiB1cGdyYWRlKGRvbUNyZWF0ZUVsZW1lbnQoZGVmaW5pdGlvbi50YWcpLCBkZWZpbml0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZ3JhZGUoZWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIC8vIHNvbWUgZGVmaW5pdGlvbnMgc3BlY2lmeSBhbiAnaXMnIGF0dHJpYnV0ZVxuICAgIGlmIChkZWZpbml0aW9uLmlzKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaXMnLCBkZWZpbml0aW9uLmlzKTtcbiAgICB9XG4gICAgLy8gbWFrZSAnZWxlbWVudCcgaW1wbGVtZW50IGRlZmluaXRpb24ucHJvdG90eXBlXG4gICAgaW1wbGVtZW50KGVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIC8vIGZsYWcgYXMgdXBncmFkZWRcbiAgICBlbGVtZW50Ll9fdXBncmFkZWRfXyA9IHRydWU7XG4gICAgLy8gbGlmZWN5Y2xlIG1hbmFnZW1lbnRcbiAgICBjcmVhdGVkKGVsZW1lbnQpO1xuICAgIC8vIGF0dGFjaGVkQ2FsbGJhY2sgZmlyZXMgaW4gdHJlZSBvcmRlciwgY2FsbCBiZWZvcmUgcmVjdXJzaW5nXG4gICAgc2NvcGUuaW5zZXJ0ZWROb2RlKGVsZW1lbnQpO1xuICAgIC8vIHRoZXJlIHNob3VsZCBuZXZlciBiZSBhIHNoYWRvdyByb290IG9uIGVsZW1lbnQgYXQgdGhpcyBwb2ludFxuICAgIHNjb3BlLnVwZ3JhZGVTdWJ0cmVlKGVsZW1lbnQpO1xuICAgIC8vIE9VVFBVVFxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaW1wbGVtZW50KGVsZW1lbnQsIGRlZmluaXRpb24pIHtcbiAgICAvLyBwcm90b3R5cGUgc3dpenpsaW5nIGlzIGJlc3RcbiAgICBpZiAoT2JqZWN0Ll9fcHJvdG9fXykge1xuICAgICAgZWxlbWVudC5fX3Byb3RvX18gPSBkZWZpbml0aW9uLnByb3RvdHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2hlcmUgYWJvdmUgd2UgY2FuIHJlLWFjcXVpcmUgaW5Qcm90b3R5cGUgdmlhXG4gICAgICAvLyBnZXRQcm90b3R5cGVPZihFbGVtZW50KSwgd2UgY2Fubm90IGRvIHNvIHdoZW5cbiAgICAgIC8vIHdlIHVzZSBtaXhpbiwgc28gd2UgaW5zdGFsbCBhIG1hZ2ljIHJlZmVyZW5jZVxuICAgICAgY3VzdG9tTWl4aW4oZWxlbWVudCwgZGVmaW5pdGlvbi5wcm90b3R5cGUsIGRlZmluaXRpb24ubmF0aXZlKTtcbiAgICAgIGVsZW1lbnQuX19wcm90b19fID0gZGVmaW5pdGlvbi5wcm90b3R5cGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3VzdG9tTWl4aW4oaW5UYXJnZXQsIGluU3JjLCBpbk5hdGl2ZSkge1xuICAgIC8vIFRPRE8oc2ptaWxlcyk6ICd1c2VkJyBhbGxvd3MgdXMgdG8gb25seSBjb3B5IHRoZSAneW91bmdlc3QnIHZlcnNpb24gb2ZcbiAgICAvLyBhbnkgcHJvcGVydHkuIFRoaXMgc2V0IHNob3VsZCBiZSBwcmVjYWxjdWxhdGVkLiBXZSBhbHNvIG5lZWQgdG9cbiAgICAvLyBjb25zaWRlciB0aGlzIGZvciBzdXBwb3J0aW5nICdzdXBlcicuXG4gICAgdmFyIHVzZWQgPSB7fTtcbiAgICAvLyBzdGFydCB3aXRoIGluU3JjXG4gICAgdmFyIHAgPSBpblNyYztcbiAgICAvLyBUaGUgZGVmYXVsdCBpcyBIVE1MRWxlbWVudC5wcm90b3R5cGUsIHNvIHdlIGFkZCBhIHRlc3QgdG8gYXZvaWQgbWl4aW5nIGluXG4gICAgLy8gbmF0aXZlIHByb3RvdHlwZXNcbiAgICB3aGlsZSAocCAhPT0gaW5OYXRpdmUgJiYgcCAhPT0gSFRNTEVsZW1lbnQucHJvdG90eXBlKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHApO1xuICAgICAgZm9yICh2YXIgaT0wLCBrOyBrPWtleXNbaV07IGkrKykge1xuICAgICAgICBpZiAoIXVzZWRba10pIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5UYXJnZXQsIGssXG4gICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocCwgaykpO1xuICAgICAgICAgIHVzZWRba10gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZWQoZWxlbWVudCkge1xuICAgIC8vIGludm9rZSBjcmVhdGVkQ2FsbGJhY2tcbiAgICBpZiAoZWxlbWVudC5jcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIGVsZW1lbnQuY3JlYXRlZENhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXR0cmlidXRlIHdhdGNoaW5nXG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGVBdHRyaWJ1dGVBcGkocHJvdG90eXBlKSB7XG4gICAgLy8gb3ZlcnJpZGVzIHRvIGltcGxlbWVudCBjYWxsYmFja3NcbiAgICAvLyBUT0RPKHNqbWlsZXMpOiBzaG91bGQgc3VwcG9ydCBhY2Nlc3MgdmlhIC5hdHRyaWJ1dGVzIE5hbWVkTm9kZU1hcFxuICAgIC8vIFRPRE8oc2ptaWxlcyk6IHByZXNlcnZlcyB1c2VyIGRlZmluZWQgb3ZlcnJpZGVzLCBpZiBhbnlcbiAgICBpZiAocHJvdG90eXBlLnNldEF0dHJpYnV0ZS5fcG9seWZpbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2V0QXR0cmlidXRlID0gcHJvdG90eXBlLnNldEF0dHJpYnV0ZTtcbiAgICBwcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIGNoYW5nZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlLCBzZXRBdHRyaWJ1dGUpO1xuICAgIH1cbiAgICB2YXIgcmVtb3ZlQXR0cmlidXRlID0gcHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZTtcbiAgICBwcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgY2hhbmdlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSwgbnVsbCwgcmVtb3ZlQXR0cmlidXRlKTtcbiAgICB9XG4gICAgcHJvdG90eXBlLnNldEF0dHJpYnV0ZS5fcG9seWZpbGxlZCA9IHRydWU7XG4gIH1cblxuICAvLyBodHRwczovL2R2Y3MudzMub3JnL2hnL3dlYmNvbXBvbmVudHMvcmF3LWZpbGUvdGlwL3NwZWMvY3VzdG9tL1xuICAvLyBpbmRleC5odG1sI2Rmbi1hdHRyaWJ1dGUtY2hhbmdlZC1jYWxsYmFja1xuICBmdW5jdGlvbiBjaGFuZ2VBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG9wZXJhdGlvbikge1xuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgb3BlcmF0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrXG4gICAgICAgICYmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsZW1lbnQgcmVnaXN0cnkgKG1hcHMgdGFnIG5hbWVzIHRvIGRlZmluaXRpb25zKVxuXG4gIHZhciByZWdpc3RyeSA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldFJlZ2lzdGVyZWREZWZpbml0aW9uKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIHJlZ2lzdHJ5W25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJEZWZpbml0aW9uKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICByZWdpc3RyeVtuYW1lXSA9IGRlZmluaXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUNvbnN0cnVjdG9yKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaW5zdGFudGlhdGUoZGVmaW5pdGlvbik7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnLCB0eXBlRXh0ZW5zaW9uKSB7XG4gICAgLy8gTk9URTogd2UgZG8gbm90IHN1cHBvcnQgbm9uLUhUTUwgZWxlbWVudHMsXG4gICAgLy8ganVzdCBjYWxsIGNyZWF0ZUVsZW1lbnROUyBmb3Igbm9uIEhUTUwgRWxlbWVudHNcbiAgICBpZiAobmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnLCB0eXBlRXh0ZW5zaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRvbUNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIHR5cGVFeHRlbnNpb24pIHtcbiAgICAvLyBUT0RPKHNqbWlsZXMpOiBpZ25vcmUgJ3RhZycgd2hlbiB1c2luZyAndHlwZUV4dGVuc2lvbicsIHdlIGNvdWxkXG4gICAgLy8gZXJyb3IgY2hlY2sgaXQsIG9yIHBlcmhhcHMgdGhlcmUgc2hvdWxkIG9ubHkgZXZlciBiZSBvbmUgYXJndW1lbnRcbiAgICB2YXIgZGVmaW5pdGlvbiA9IGdldFJlZ2lzdGVyZWREZWZpbml0aW9uKHR5cGVFeHRlbnNpb24gfHwgdGFnKTtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgaWYgKHRhZyA9PSBkZWZpbml0aW9uLnRhZyAmJiB0eXBlRXh0ZW5zaW9uID09IGRlZmluaXRpb24uaXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZWZpbml0aW9uLmN0b3IoKTtcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBlbXB0eSBzdHJpbmcgZm9yIHR5cGUgZXh0ZW5zaW9uLlxuICAgICAgaWYgKCF0eXBlRXh0ZW5zaW9uICYmICFkZWZpbml0aW9uLmlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgZGVmaW5pdGlvbi5jdG9yKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVFeHRlbnNpb24pIHtcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lzJywgdHlwZUV4dGVuc2lvbik7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBkb21DcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgLy8gQ3VzdG9tIHRhZ3Mgc2hvdWxkIGJlIEhUTUxFbGVtZW50cyBldmVuIGlmIG5vdCB1cGdyYWRlZC5cbiAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+PSAwKSB7XG4gICAgICBpbXBsZW1lbnQoZWxlbWVudCwgSFRNTEVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZ3JhZGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuX191cGdyYWRlZF9fICYmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkpIHtcbiAgICAgIHZhciBpcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpcycpO1xuICAgICAgdmFyIGRlZmluaXRpb24gPSBnZXRSZWdpc3RlcmVkRGVmaW5pdGlvbihpcyB8fCBlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoaXMgJiYgZGVmaW5pdGlvbi50YWcgPT0gZWxlbWVudC5sb2NhbE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdXBncmFkZShlbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXMgJiYgIWRlZmluaXRpb24uZXh0ZW5kcykge1xuICAgICAgICAgIHJldHVybiB1cGdyYWRlKGVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVOb2RlKGRlZXApIHtcbiAgICAvLyBjYWxsIG9yaWdpbmFsIGNsb25lXG4gICAgdmFyIG4gPSBkb21DbG9uZU5vZGUuY2FsbCh0aGlzLCBkZWVwKTtcbiAgICAvLyB1cGdyYWRlIHRoZSBlbGVtZW50IGFuZCBzdWJ0cmVlXG4gICAgc2NvcGUudXBncmFkZUFsbChuKTtcbiAgICAvLyByZXR1cm4gdGhlIGNsb25lXG4gICAgcmV0dXJuIG47XG4gIH1cbiAgLy8gY2FwdHVyZSBuYXRpdmUgY3JlYXRlRWxlbWVudCBiZWZvcmUgd2Ugb3ZlcnJpZGUgaXRcblxuICB2YXIgZG9tQ3JlYXRlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChkb2N1bWVudCk7XG4gIHZhciBkb21DcmVhdGVFbGVtZW50TlMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMuYmluZChkb2N1bWVudCk7XG5cbiAgLy8gY2FwdHVyZSBuYXRpdmUgY2xvbmVOb2RlIGJlZm9yZSB3ZSBvdmVycmlkZSBpdFxuXG4gIHZhciBkb21DbG9uZU5vZGUgPSBOb2RlLnByb3RvdHlwZS5jbG9uZU5vZGU7XG5cbiAgLy8gZXhwb3J0c1xuXG4gIGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCA9IHJlZ2lzdGVyO1xuICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDsgLy8gb3ZlcnJpZGVcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TID0gY3JlYXRlRWxlbWVudE5TOyAvLyBvdmVycmlkZVxuICBOb2RlLnByb3RvdHlwZS5jbG9uZU5vZGUgPSBjbG9uZU5vZGU7IC8vIG92ZXJyaWRlXG5cbiAgc2NvcGUucmVnaXN0cnkgPSByZWdpc3RyeTtcblxuICAvKipcbiAgICogVXBncmFkZSBhbiBlbGVtZW50IHRvIGEgY3VzdG9tIGVsZW1lbnQuIFVwZ3JhZGluZyBhbiBlbGVtZW50XG4gICAqIGNhdXNlcyB0aGUgY3VzdG9tIHByb3RvdHlwZSB0byBiZSBhcHBsaWVkLCBhbiBgaXNgIGF0dHJpYnV0ZVxuICAgKiB0byBiZSBhdHRhY2hlZCAoYXMgbmVlZGVkKSwgYW5kIGludm9jYXRpb24gb2YgdGhlIGByZWFkeUNhbGxiYWNrYC5cbiAgICogYHVwZ3JhZGVgIGRvZXMgbm90aGluZyBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHVwZ3JhZGVkLCBvclxuICAgKiBpZiBpdCBtYXRjaGVzIG5vIHJlZ2lzdGVyZWQgY3VzdG9tIHRhZyBuYW1lLlxuICAgKlxuICAgKiBAbWV0aG9kIHVncHJhZGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHVwZ3JhZGUuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSB1cGdyYWRlZCBlbGVtZW50LlxuICAgKi9cbiAgc2NvcGUudXBncmFkZSA9IHVwZ3JhZGVFbGVtZW50O1xufVxuXG4vLyBDcmVhdGUgYSBjdXN0b20gJ2luc3RhbmNlb2YnLiBUaGlzIGlzIG5lY2Vzc2FyeSB3aGVuIEN1c3RvbUVsZW1lbnRzXG4vLyBhcmUgaW1wbGVtZW50ZWQgdmlhIGEgbWl4aW4gc3RyYXRlZ3ksIGFzIGZvciBleGFtcGxlIG9uIElFMTAuXG52YXIgaXNJbnN0YW5jZTtcbmlmICghT2JqZWN0Ll9fcHJvdG9fXyAmJiAhdXNlTmF0aXZlKSB7XG4gIGlzSW5zdGFuY2UgPSBmdW5jdGlvbihvYmosIGN0b3IpIHtcbiAgICB2YXIgcCA9IG9iajtcbiAgICB3aGlsZSAocCkge1xuICAgICAgLy8gTk9URTogdGhpcyBpcyBub3QgdGVjaG5pY2FsbHkgY29ycmVjdCBzaW5jZSB3ZSdyZSBub3QgY2hlY2tpbmcgaWZcbiAgICAgIC8vIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBhIGNvbnN0cnVjdG9yOyBob3dldmVyLCB0aGlzIHNob3VsZFxuICAgICAgLy8gYmUgZ29vZCBlbm91Z2ggZm9yIHRoZSBtaXhpbiBzdHJhdGVneS5cbiAgICAgIGlmIChwID09PSBjdG9yLnByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHAgPSBwLl9fcHJvdG9fXztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59IGVsc2Uge1xuICBpc0luc3RhbmNlID0gZnVuY3Rpb24ob2JqLCBiYXNlKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIGJhc2U7XG4gIH1cbn1cblxuLy8gZXhwb3J0c1xuc2NvcGUuaW5zdGFuY2VvZiA9IGlzSW5zdGFuY2U7XG5zY29wZS5yZXNlcnZlZFRhZ0xpc3QgPSByZXNlcnZlZFRhZ0xpc3Q7XG5cbi8vIGJjXG5kb2N1bWVudC5yZWdpc3RlciA9IGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudDtcblxuc2NvcGUuaGFzTmF0aXZlID0gaGFzTmF0aXZlO1xuc2NvcGUudXNlTmF0aXZlID0gdXNlTmF0aXZlO1xuXG59KSh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpO1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbihmdW5jdGlvbihzY29wZSl7XG5cbnZhciBsb2dGbGFncyA9IHdpbmRvdy5sb2dGbGFncyB8fCB7fTtcbnZhciBJTVBPUlRfTElOS19UWVBFID0gd2luZG93LkhUTUxJbXBvcnRzID8gSFRNTEltcG9ydHMuSU1QT1JUX0xJTktfVFlQRSA6ICdub25lJztcblxuLy8gd2FsayB0aGUgc3VidHJlZSByb290ZWQgYXQgbm9kZSwgYXBwbHlpbmcgJ2ZpbmQoZWxlbWVudCwgZGF0YSknIGZ1bmN0aW9uXG4vLyB0byBlYWNoIGVsZW1lbnRcbi8vIGlmICdmaW5kJyByZXR1cm5zIHRydWUgZm9yICdlbGVtZW50JywgZG8gbm90IHNlYXJjaCBlbGVtZW50J3Mgc3VidHJlZVxuZnVuY3Rpb24gZmluZEFsbChub2RlLCBmaW5kLCBkYXRhKSB7XG4gIHZhciBlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgaWYgKCFlKSB7XG4gICAgZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZSAmJiBlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgZSA9IGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIHdoaWxlIChlKSB7XG4gICAgaWYgKGZpbmQoZSwgZGF0YSkgIT09IHRydWUpIHtcbiAgICAgIGZpbmRBbGwoZSwgZmluZCwgZGF0YSk7XG4gICAgfVxuICAgIGUgPSBlLm5leHRFbGVtZW50U2libGluZztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gd2FsayBhbGwgc2hhZG93Um9vdHMgb24gYSBnaXZlbiBub2RlLlxuZnVuY3Rpb24gZm9yUm9vdHMobm9kZSwgY2IpIHtcbiAgdmFyIHJvb3QgPSBub2RlLnNoYWRvd1Jvb3Q7XG4gIHdoaWxlKHJvb3QpIHtcbiAgICBmb3JTdWJ0cmVlKHJvb3QsIGNiKTtcbiAgICByb290ID0gcm9vdC5vbGRlclNoYWRvd1Jvb3Q7XG4gIH1cbn1cblxuLy8gd2FsayB0aGUgc3VidHJlZSByb290ZWQgYXQgbm9kZSwgaW5jbHVkaW5nIGRlc2NlbnQgaW50byBzaGFkb3ctcm9vdHMsXG4vLyBhcHBseWluZyAnY2InIHRvIGVhY2ggZWxlbWVudFxuZnVuY3Rpb24gZm9yU3VidHJlZShub2RlLCBjYikge1xuICAvL2xvZ0ZsYWdzLmRvbSAmJiBub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBjb25zb2xlLmdyb3VwKCdzdWJUcmVlOiAnLCBub2RlKTtcbiAgZmluZEFsbChub2RlLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGNiKGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yUm9vdHMoZSwgY2IpO1xuICB9KTtcbiAgZm9yUm9vdHMobm9kZSwgY2IpO1xuICAvL2xvZ0ZsYWdzLmRvbSAmJiBub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBjb25zb2xlLmdyb3VwRW5kKCk7XG59XG5cbi8vIG1hbmFnZSBsaWZlY3ljbGUgb24gYWRkZWQgbm9kZVxuZnVuY3Rpb24gYWRkZWQobm9kZSkge1xuICBpZiAodXBncmFkZShub2RlKSkge1xuICAgIGluc2VydGVkTm9kZShub2RlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbnNlcnRlZChub2RlKTtcbn1cblxuLy8gbWFuYWdlIGxpZmVjeWNsZSBvbiBhZGRlZCBub2RlJ3Mgc3VidHJlZSBvbmx5XG5mdW5jdGlvbiBhZGRlZFN1YnRyZWUobm9kZSkge1xuICBmb3JTdWJ0cmVlKG5vZGUsIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoYWRkZWQoZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIG1hbmFnZSBsaWZlY3ljbGUgb24gYWRkZWQgbm9kZSBhbmQgaXQncyBzdWJ0cmVlXG5mdW5jdGlvbiBhZGRlZE5vZGUobm9kZSkge1xuICByZXR1cm4gYWRkZWQobm9kZSkgfHwgYWRkZWRTdWJ0cmVlKG5vZGUpO1xufVxuXG4vLyB1cGdyYWRlIGN1c3RvbSBlbGVtZW50cyBhdCBub2RlLCBpZiBhcHBsaWNhYmxlXG5mdW5jdGlvbiB1cGdyYWRlKG5vZGUpIHtcbiAgaWYgKCFub2RlLl9fdXBncmFkZWRfXyAmJiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHZhciB0eXBlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgbm9kZS5sb2NhbE5hbWU7XG4gICAgdmFyIGRlZmluaXRpb24gPSBzY29wZS5yZWdpc3RyeVt0eXBlXTtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgbG9nRmxhZ3MuZG9tICYmIGNvbnNvbGUuZ3JvdXAoJ3VwZ3JhZGU6Jywgbm9kZS5sb2NhbE5hbWUpO1xuICAgICAgc2NvcGUudXBncmFkZShub2RlKTtcbiAgICAgIGxvZ0ZsYWdzLmRvbSAmJiBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0ZWROb2RlKG5vZGUpIHtcbiAgaW5zZXJ0ZWQobm9kZSk7XG4gIGlmIChpbkRvY3VtZW50KG5vZGUpKSB7XG4gICAgZm9yU3VidHJlZShub2RlLCBmdW5jdGlvbihlKSB7XG4gICAgICBpbnNlcnRlZChlKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBUT0RPKHNvcnZlbGwpOiBvbiBwbGF0Zm9ybXMgd2l0aG91dCBNdXRhdGlvbk9ic2VydmVyLCBtdXRhdGlvbnMgbWF5IG5vdCBiZVxuLy8gcmVsaWFibGUgYW5kIHRoZXJlZm9yZSBhdHRhY2hlZC9kZXRhY2hlZCBhcmUgbm90IHJlbGlhYmxlLlxuLy8gVG8gbWFrZSB0aGVzZSBjYWxsYmFja3MgbGVzcyBsaWtlbHkgdG8gZmFpbCwgd2UgZGVmZXIgYWxsIGluc2VydHMgYW5kIHJlbW92ZXNcbi8vIHRvIGdpdmUgYSBjaGFuY2UgZm9yIGVsZW1lbnRzIHRvIGJlIGluc2VydGVkIGludG8gZG9tLlxuLy8gVGhpcyBlbnN1cmVzIGF0dGFjaGVkQ2FsbGJhY2sgZmlyZXMgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGNyZWF0ZWQgYW5kXG4vLyBpbW1lZGlhdGVseSBhZGRlZCB0byBkb20uXG52YXIgaGFzUG9seWZpbGxNdXRhdGlvbnMgPSAoIXdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8XG4gICAgKHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyID09PSB3aW5kb3cuSnNNdXRhdGlvbk9ic2VydmVyKSk7XG5zY29wZS5oYXNQb2x5ZmlsbE11dGF0aW9ucyA9IGhhc1BvbHlmaWxsTXV0YXRpb25zO1xuXG52YXIgaXNQZW5kaW5nTXV0YXRpb25zID0gZmFsc2U7XG52YXIgcGVuZGluZ011dGF0aW9ucyA9IFtdO1xuZnVuY3Rpb24gZGVmZXJNdXRhdGlvbihmbikge1xuICBwZW5kaW5nTXV0YXRpb25zLnB1c2goZm4pO1xuICBpZiAoIWlzUGVuZGluZ011dGF0aW9ucykge1xuICAgIGlzUGVuZGluZ011dGF0aW9ucyA9IHRydWU7XG4gICAgdmFyIGFzeW5jID0gKHdpbmRvdy5QbGF0Zm9ybSAmJiB3aW5kb3cuUGxhdGZvcm0uZW5kT2ZNaWNyb3Rhc2spIHx8XG4gICAgICAgIHNldFRpbWVvdXQ7XG4gICAgYXN5bmModGFrZU11dGF0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGFrZU11dGF0aW9ucygpIHtcbiAgaXNQZW5kaW5nTXV0YXRpb25zID0gZmFsc2U7XG4gIHZhciAkcCA9IHBlbmRpbmdNdXRhdGlvbnM7XG4gIGZvciAodmFyIGk9MCwgbD0kcC5sZW5ndGgsIHA7IChpPGwpICYmIChwPSRwW2ldKTsgaSsrKSB7XG4gICAgcCgpO1xuICB9XG4gIHBlbmRpbmdNdXRhdGlvbnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0ZWQoZWxlbWVudCkge1xuICBpZiAoaGFzUG9seWZpbGxNdXRhdGlvbnMpIHtcbiAgICBkZWZlck11dGF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgX2luc2VydGVkKGVsZW1lbnQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIF9pbnNlcnRlZChlbGVtZW50KTtcbiAgfVxufVxuXG4vLyBUT0RPKHNqbWlsZXMpOiBpZiB0aGVyZSBhcmUgZGVzY2VudHMgaW50byB0cmVlcyB0aGF0IGNhbiBuZXZlciBoYXZlIGluRG9jdW1lbnQoKikgdHJ1ZSwgZml4IHRoaXNcbmZ1bmN0aW9uIF9pbnNlcnRlZChlbGVtZW50KSB7XG4gIC8vIFRPRE8oc2ptaWxlcyk6IGl0J3MgcG9zc2libGUgd2Ugd2VyZSBpbnNlcnRlZCBhbmQgcmVtb3ZlZCBpbiB0aGUgc3BhY2VcbiAgLy8gb2Ygb25lIG1pY3JvdGFzaywgaW4gd2hpY2ggY2FzZSB3ZSB3b24ndCBiZSAnaW5Eb2N1bWVudCcgaGVyZVxuICAvLyBCdXQgdGhlcmUgYXJlIG90aGVyIGNhc2VzIHdoZXJlIHdlIGFyZSB0ZXN0aW5nIGZvciBpbnNlcnRlZCB3aXRob3V0XG4gIC8vIHNwZWNpZmljIGtub3dsZWRnZSBvZiBtdXRhdGlvbnMsIGFuZCBtdXN0IHRlc3QgJ2luRG9jdW1lbnQnIHRvIGRldGVybWluZVxuICAvLyB3aGV0aGVyIHRvIGNhbGwgaW5zZXJ0ZWRcbiAgLy8gSWYgd2UgY2FuIGZhY3RvciB0aGVzZSBjYXNlcyBpbnRvIHNlcGFyYXRlIGNvZGUgcGF0aHMgd2UgY2FuIGhhdmVcbiAgLy8gYmV0dGVyIGRpYWdub3N0aWNzLlxuICAvLyBUT0RPKHNqbWlsZXMpOiB3aGVuIGxvZ2dpbmcsIGRvIHdvcmsgb24gYWxsIGN1c3RvbSBlbGVtZW50cyBzbyB3ZSBjYW5cbiAgLy8gdHJhY2sgYmVoYXZpb3IgZXZlbiB3aGVuIGNhbGxiYWNrcyBub3QgZGVmaW5lZFxuICAvL2NvbnNvbGUubG9nKCdpbnNlcnRlZDogJywgZWxlbWVudC5sb2NhbE5hbWUpO1xuICBpZiAoZWxlbWVudC5hdHRhY2hlZENhbGxiYWNrIHx8IGVsZW1lbnQuZGV0YWNoZWRDYWxsYmFjayB8fCAoZWxlbWVudC5fX3VwZ3JhZGVkX18gJiYgbG9nRmxhZ3MuZG9tKSkge1xuICAgIGxvZ0ZsYWdzLmRvbSAmJiBjb25zb2xlLmdyb3VwKCdpbnNlcnRlZDonLCBlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgaWYgKGluRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQuX19pbnNlcnRlZCA9IChlbGVtZW50Ll9faW5zZXJ0ZWQgfHwgMCkgKyAxO1xuICAgICAgLy8gaWYgd2UgYXJlIGluIGEgJ3JlbW92ZWQnIHN0YXRlLCBibHVudGx5IGFkanVzdCB0byBhbiAnaW5zZXJ0ZWQnIHN0YXRlXG4gICAgICBpZiAoZWxlbWVudC5fX2luc2VydGVkIDwgMSkge1xuICAgICAgICBlbGVtZW50Ll9faW5zZXJ0ZWQgPSAxO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgYXJlICdvdmVyIGluc2VydGVkJywgc3F1ZWxjaCB0aGUgY2FsbGJhY2tcbiAgICAgIGlmIChlbGVtZW50Ll9faW5zZXJ0ZWQgPiAxKSB7XG4gICAgICAgIGxvZ0ZsYWdzLmRvbSAmJiBjb25zb2xlLndhcm4oJ2luc2VydGVkOicsIGVsZW1lbnQubG9jYWxOYW1lLFxuICAgICAgICAgICdpbnNlcnQvcmVtb3ZlIGNvdW50OicsIGVsZW1lbnQuX19pbnNlcnRlZClcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5hdHRhY2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGxvZ0ZsYWdzLmRvbSAmJiBjb25zb2xlLmxvZygnaW5zZXJ0ZWQ6JywgZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgICAgICBlbGVtZW50LmF0dGFjaGVkQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nRmxhZ3MuZG9tICYmIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVkTm9kZShub2RlKSB7XG4gIHJlbW92ZWQobm9kZSk7XG4gIGZvclN1YnRyZWUobm9kZSwgZnVuY3Rpb24oZSkge1xuICAgIHJlbW92ZWQoZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVkKGVsZW1lbnQpIHtcbiAgaWYgKGhhc1BvbHlmaWxsTXV0YXRpb25zKSB7XG4gICAgZGVmZXJNdXRhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIF9yZW1vdmVkKGVsZW1lbnQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIF9yZW1vdmVkKGVsZW1lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9yZW1vdmVkKGVsZW1lbnQpIHtcbiAgLy8gVE9ETyhzam1pbGVzKTogdGVtcG9yYXJ5OiBkbyB3b3JrIG9uIGFsbCBjdXN0b20gZWxlbWVudHMgc28gd2UgY2FuIHRyYWNrXG4gIC8vIGJlaGF2aW9yIGV2ZW4gd2hlbiBjYWxsYmFja3Mgbm90IGRlZmluZWRcbiAgaWYgKGVsZW1lbnQuYXR0YWNoZWRDYWxsYmFjayB8fCBlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2sgfHwgKGVsZW1lbnQuX191cGdyYWRlZF9fICYmIGxvZ0ZsYWdzLmRvbSkpIHtcbiAgICBsb2dGbGFncy5kb20gJiYgY29uc29sZS5ncm91cCgncmVtb3ZlZDonLCBlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgaWYgKCFpbkRvY3VtZW50KGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50Ll9faW5zZXJ0ZWQgPSAoZWxlbWVudC5fX2luc2VydGVkIHx8IDApIC0gMTtcbiAgICAgIC8vIGlmIHdlIGFyZSBpbiBhICdpbnNlcnRlZCcgc3RhdGUsIGJsdW50bHkgYWRqdXN0IHRvIGFuICdyZW1vdmVkJyBzdGF0ZVxuICAgICAgaWYgKGVsZW1lbnQuX19pbnNlcnRlZCA+IDApIHtcbiAgICAgICAgZWxlbWVudC5fX2luc2VydGVkID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGFyZSAnb3ZlciByZW1vdmVkJywgc3F1ZWxjaCB0aGUgY2FsbGJhY2tcbiAgICAgIGlmIChlbGVtZW50Ll9faW5zZXJ0ZWQgPCAwKSB7XG4gICAgICAgIGxvZ0ZsYWdzLmRvbSAmJiBjb25zb2xlLndhcm4oJ3JlbW92ZWQ6JywgZWxlbWVudC5sb2NhbE5hbWUsXG4gICAgICAgICAgICAnaW5zZXJ0L3JlbW92ZSBjb3VudDonLCBlbGVtZW50Ll9faW5zZXJ0ZWQpXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoZWRDYWxsYmFjaykge1xuICAgICAgICBlbGVtZW50LmRldGFjaGVkQ2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nRmxhZ3MuZG9tICYmIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfVxufVxuXG4vLyBTRCBwb2x5ZmlsbCBpbnRydXN0aW9uIGR1ZSBtYWlubHkgdG8gdGhlIGZhY3QgdGhhdCAnZG9jdW1lbnQnXG4vLyBpcyBub3QgZW50aXJlbHkgd3JhcHBlZFxuZnVuY3Rpb24gd3JhcElmTmVlZGVkKG5vZGUpIHtcbiAgcmV0dXJuIHdpbmRvdy5TaGFkb3dET01Qb2x5ZmlsbCA/IFNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZChub2RlKVxuICAgICAgOiBub2RlO1xufVxuXG5mdW5jdGlvbiBpbkRvY3VtZW50KGVsZW1lbnQpIHtcbiAgdmFyIHAgPSBlbGVtZW50O1xuICB2YXIgZG9jID0gd3JhcElmTmVlZGVkKGRvY3VtZW50KTtcbiAgd2hpbGUgKHApIHtcbiAgICBpZiAocCA9PSBkb2MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwID0gcC5wYXJlbnROb2RlIHx8IHAuaG9zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXRjaFNoYWRvdyhub2RlKSB7XG4gIGlmIChub2RlLnNoYWRvd1Jvb3QgJiYgIW5vZGUuc2hhZG93Um9vdC5fX3dhdGNoZWQpIHtcbiAgICBsb2dGbGFncy5kb20gJiYgY29uc29sZS5sb2coJ3dhdGNoaW5nIHNoYWRvdy1yb290IGZvcjogJywgbm9kZS5sb2NhbE5hbWUpO1xuICAgIC8vIHdhdGNoIGFsbCB1bndhdGNoZWQgcm9vdHMuLi5cbiAgICB2YXIgcm9vdCA9IG5vZGUuc2hhZG93Um9vdDtcbiAgICB3aGlsZSAocm9vdCkge1xuICAgICAgd2F0Y2hSb290KHJvb3QpO1xuICAgICAgcm9vdCA9IHJvb3Qub2xkZXJTaGFkb3dSb290O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXRjaFJvb3Qocm9vdCkge1xuICBpZiAoIXJvb3QuX193YXRjaGVkKSB7XG4gICAgb2JzZXJ2ZShyb290KTtcbiAgICByb290Ll9fd2F0Y2hlZCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlcihtdXRhdGlvbnMpIHtcbiAgLy9cbiAgaWYgKGxvZ0ZsYWdzLmRvbSkge1xuICAgIHZhciBteCA9IG11dGF0aW9uc1swXTtcbiAgICBpZiAobXggJiYgbXgudHlwZSA9PT0gJ2NoaWxkTGlzdCcgJiYgbXguYWRkZWROb2Rlcykge1xuICAgICAgICBpZiAobXguYWRkZWROb2Rlcykge1xuICAgICAgICAgIHZhciBkID0gbXguYWRkZWROb2Rlc1swXTtcbiAgICAgICAgICB3aGlsZSAoZCAmJiBkICE9PSBkb2N1bWVudCAmJiAhZC5ob3N0KSB7XG4gICAgICAgICAgICBkID0gZC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdSA9IGQgJiYgKGQuVVJMIHx8IGQuX1VSTCB8fCAoZC5ob3N0ICYmIGQuaG9zdC5sb2NhbE5hbWUpKSB8fCAnJztcbiAgICAgICAgICB1ID0gdS5zcGxpdCgnLz8nKS5zaGlmdCgpLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS5ncm91cCgnbXV0YXRpb25zICglZCkgWyVzXScsIG11dGF0aW9ucy5sZW5ndGgsIHUgfHwgJycpO1xuICB9XG4gIC8vXG4gIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG14KSB7XG4gICAgLy9sb2dGbGFncy5kb20gJiYgY29uc29sZS5ncm91cCgnbXV0YXRpb24nKTtcbiAgICBpZiAobXgudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgIGZvckVhY2gobXguYWRkZWROb2RlcywgZnVuY3Rpb24obikge1xuICAgICAgICAvL2xvZ0ZsYWdzLmRvbSAmJiBjb25zb2xlLmxvZyhuLmxvY2FsTmFtZSk7XG4gICAgICAgIGlmICghbi5sb2NhbE5hbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9kZXMgYWRkZWQgbWF5IG5lZWQgbGlmZWN5Y2xlIG1hbmFnZW1lbnRcbiAgICAgICAgYWRkZWROb2RlKG4pO1xuICAgICAgfSk7XG4gICAgICAvLyByZW1vdmVkIG5vZGVzIG1heSBuZWVkIGxpZmVjeWNsZSBtYW5hZ2VtZW50XG4gICAgICBmb3JFYWNoKG14LnJlbW92ZWROb2RlcywgZnVuY3Rpb24obikge1xuICAgICAgICAvL2xvZ0ZsYWdzLmRvbSAmJiBjb25zb2xlLmxvZyhuLmxvY2FsTmFtZSk7XG4gICAgICAgIGlmICghbi5sb2NhbE5hbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlZE5vZGUobik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy9sb2dGbGFncy5kb20gJiYgY29uc29sZS5ncm91cEVuZCgpO1xuICB9KTtcbiAgbG9nRmxhZ3MuZG9tICYmIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbn07XG5cbnZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZXIpO1xuXG5mdW5jdGlvbiB0YWtlUmVjb3JkcygpIHtcbiAgLy8gVE9ETyhzam1pbGVzKTogYXNrIFJhZiB3aHkgd2UgaGF2ZSB0byBjYWxsIGhhbmRsZXIgb3Vyc2VsdmVzXG4gIGhhbmRsZXIob2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gIHRha2VNdXRhdGlvbnMoKTtcbn1cblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xuXG5mdW5jdGlvbiBvYnNlcnZlKGluUm9vdCkge1xuICBvYnNlcnZlci5vYnNlcnZlKGluUm9vdCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xufVxuXG5mdW5jdGlvbiBvYnNlcnZlRG9jdW1lbnQoZG9jKSB7XG4gIG9ic2VydmUoZG9jKTtcbn1cblxuZnVuY3Rpb24gdXBncmFkZURvY3VtZW50KGRvYykge1xuICBsb2dGbGFncy5kb20gJiYgY29uc29sZS5ncm91cCgndXBncmFkZURvY3VtZW50OiAnLCAoZG9jLmJhc2VVUkkpLnNwbGl0KCcvJykucG9wKCkpO1xuICBhZGRlZE5vZGUoZG9jKTtcbiAgbG9nRmxhZ3MuZG9tICYmIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbn1cblxuZnVuY3Rpb24gdXBncmFkZURvY3VtZW50VHJlZShkb2MpIHtcbiAgZG9jID0gd3JhcElmTmVlZGVkKGRvYyk7XG4gIC8vY29uc29sZS5sb2coJ3VwZ3JhZGVEb2N1bWVudFRyZWU6ICcsIChkb2MuYmFzZVVSSSkuc3BsaXQoJy8nKS5wb3AoKSk7XG4gIC8vIHVwZ3JhZGUgY29udGFpbmVkIGltcG9ydGVkIGRvY3VtZW50c1xuICB2YXIgaW1wb3J0cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW3JlbD0nICsgSU1QT1JUX0xJTktfVFlQRSArICddJyk7XG4gIGZvciAodmFyIGk9MCwgbD1pbXBvcnRzLmxlbmd0aCwgbjsgKGk8bCkgJiYgKG49aW1wb3J0c1tpXSk7IGkrKykge1xuICAgIGlmIChuLmltcG9ydCAmJiBuLmltcG9ydC5fX3BhcnNlZCkge1xuICAgICAgdXBncmFkZURvY3VtZW50VHJlZShuLmltcG9ydCk7XG4gICAgfVxuICB9XG4gIHVwZ3JhZGVEb2N1bWVudChkb2MpO1xufVxuXG4vLyBleHBvcnRzXG5zY29wZS5JTVBPUlRfTElOS19UWVBFID0gSU1QT1JUX0xJTktfVFlQRTtcbnNjb3BlLndhdGNoU2hhZG93ID0gd2F0Y2hTaGFkb3c7XG5zY29wZS51cGdyYWRlRG9jdW1lbnRUcmVlID0gdXBncmFkZURvY3VtZW50VHJlZTtcbnNjb3BlLnVwZ3JhZGVBbGwgPSBhZGRlZE5vZGU7XG5zY29wZS51cGdyYWRlU3VidHJlZSA9IGFkZGVkU3VidHJlZTtcbnNjb3BlLmluc2VydGVkTm9kZSA9IGluc2VydGVkTm9kZTtcblxuc2NvcGUub2JzZXJ2ZURvY3VtZW50ID0gb2JzZXJ2ZURvY3VtZW50O1xuc2NvcGUudXBncmFkZURvY3VtZW50ID0gdXBncmFkZURvY3VtZW50O1xuXG5zY29wZS50YWtlUmVjb3JkcyA9IHRha2VSZWNvcmRzO1xuXG59KSh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpO1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbihmdW5jdGlvbihzY29wZSkge1xuXG4vLyBpbXBvcnRcblxudmFyIElNUE9SVF9MSU5LX1RZUEUgPSBzY29wZS5JTVBPUlRfTElOS19UWVBFO1xuXG4vLyBoaWdobGFuZGVyIG9iamVjdCBmb3IgcGFyc2luZyBhIGRvY3VtZW50IHRyZWVcblxudmFyIHBhcnNlciA9IHtcbiAgc2VsZWN0b3JzOiBbXG4gICAgJ2xpbmtbcmVsPScgKyBJTVBPUlRfTElOS19UWVBFICsgJ10nXG4gIF0sXG4gIG1hcDoge1xuICAgIGxpbms6ICdwYXJzZUxpbmsnXG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbihpbkRvY3VtZW50KSB7XG4gICAgaWYgKCFpbkRvY3VtZW50Ll9fcGFyc2VkKSB7XG4gICAgICAvLyBvbmx5IHBhcnNlIG9uY2VcbiAgICAgIGluRG9jdW1lbnQuX19wYXJzZWQgPSB0cnVlO1xuICAgICAgLy8gYWxsIHBhcnNhYmxlIGVsZW1lbnRzIGluIGluRG9jdW1lbnQgKGRlcHRoLWZpcnN0IHByZS1vcmRlciB0cmF2ZXJzYWwpXG4gICAgICB2YXIgZWx0cyA9IGluRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwYXJzZXIuc2VsZWN0b3JzKTtcbiAgICAgIC8vIGZvciBlYWNoIHBhcnNhYmxlIG5vZGUgdHlwZSwgY2FsbCB0aGUgbWFwcGVkIHBhcnNpbmcgbWV0aG9kXG4gICAgICBmb3JFYWNoKGVsdHMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcGFyc2VyW3BhcnNlci5tYXBbZS5sb2NhbE5hbWVdXShlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gdXBncmFkZSBhbGwgdXBncmFkZWFibGUgc3RhdGljIGVsZW1lbnRzLCBhbnl0aGluZyBkeW5hbWljYWxseVxuICAgICAgLy8gY3JlYXRlZCBzaG91bGQgYmUgY2F1Z2h0IGJ5IG9ic2VydmVyXG4gICAgICBDdXN0b21FbGVtZW50cy51cGdyYWRlRG9jdW1lbnQoaW5Eb2N1bWVudCk7XG4gICAgICAvLyBvYnNlcnZlIGRvY3VtZW50IGZvciBkb20gY2hhbmdlc1xuICAgICAgQ3VzdG9tRWxlbWVudHMub2JzZXJ2ZURvY3VtZW50KGluRG9jdW1lbnQpO1xuICAgIH1cbiAgfSxcbiAgcGFyc2VMaW5rOiBmdW5jdGlvbihsaW5rRWx0KSB7XG4gICAgLy8gaW1wb3J0c1xuICAgIGlmIChpc0RvY3VtZW50TGluayhsaW5rRWx0KSkge1xuICAgICAgdGhpcy5wYXJzZUltcG9ydChsaW5rRWx0KTtcbiAgICB9XG4gIH0sXG4gIHBhcnNlSW1wb3J0OiBmdW5jdGlvbihsaW5rRWx0KSB7XG4gICAgaWYgKGxpbmtFbHQuaW1wb3J0KSB7XG4gICAgICBwYXJzZXIucGFyc2UobGlua0VsdC5pbXBvcnQpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNEb2N1bWVudExpbmsoaW5FbHQpIHtcbiAgcmV0dXJuIChpbkVsdC5sb2NhbE5hbWUgPT09ICdsaW5rJ1xuICAgICAgJiYgaW5FbHQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gSU1QT1JUX0xJTktfVFlQRSk7XG59XG5cbnZhciBmb3JFYWNoID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKTtcblxuLy8gZXhwb3J0c1xuXG5zY29wZS5wYXJzZXIgPSBwYXJzZXI7XG5zY29wZS5JTVBPUlRfTElOS19UWVBFID0gSU1QT1JUX0xJTktfVFlQRTtcblxufSkod2luZG93LkN1c3RvbUVsZW1lbnRzKTtcbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbihmdW5jdGlvbihzY29wZSl7XG5cbi8vIGJvb3RzdHJhcCBwYXJzaW5nXG5mdW5jdGlvbiBib290c3RyYXAoKSB7XG4gIC8vIHBhcnNlIGRvY3VtZW50XG4gIEN1c3RvbUVsZW1lbnRzLnBhcnNlci5wYXJzZShkb2N1bWVudCk7XG4gIC8vIG9uZSBtb3JlIHBhc3MgYmVmb3JlIHJlZ2lzdGVyIGlzICdsaXZlJ1xuICBDdXN0b21FbGVtZW50cy51cGdyYWRlRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAvLyBpbnN0YWxsIHVwZ3JhZGUgaG9vayBpZiBIVE1MSW1wb3J0cyBhcmUgYXZhaWxhYmxlXG4gIGlmICh3aW5kb3cuSFRNTEltcG9ydHMpIHtcbiAgICBIVE1MSW1wb3J0cy5fX2ltcG9ydHNQYXJzaW5nSG9vayA9IGZ1bmN0aW9uKGVsdCkge1xuICAgICAgQ3VzdG9tRWxlbWVudHMucGFyc2VyLnBhcnNlKGVsdC5pbXBvcnQpO1xuICAgIH1cbiAgfVxuICAvLyBzZXQgaW50ZXJuYWwgJ3JlYWR5JyBmbGFnLCBub3cgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50IHdpbGwgdHJpZ2dlciBcbiAgLy8gc3luY2hyb25vdXMgdXBncmFkZXNcbiAgQ3VzdG9tRWxlbWVudHMucmVhZHkgPSB0cnVlO1xuICAvLyBhc3luYyB0byBlbnN1cmUgKm5hdGl2ZSogY3VzdG9tIGVsZW1lbnRzIHVwZ3JhZGUgcHJpb3IgdG8gdGhpc1xuICAvLyBET01Db250ZW50TG9hZGVkIGNhbiBmaXJlIGJlZm9yZSBlbGVtZW50cyB1cGdyYWRlIChlLmcuIHdoZW4gdGhlcmUnc1xuICAvLyBhbiBleHRlcm5hbCBzY3JpcHQpXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgLy8gY2FwdHVyZSBibHVudCBwcm9maWxpbmcgZGF0YVxuICAgIEN1c3RvbUVsZW1lbnRzLnJlYWR5VGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKHdpbmRvdy5IVE1MSW1wb3J0cykge1xuICAgICAgQ3VzdG9tRWxlbWVudHMuZWxhcHNlZCA9IEN1c3RvbUVsZW1lbnRzLnJlYWR5VGltZSAtIEhUTUxJbXBvcnRzLnJlYWR5VGltZTtcbiAgICB9XG4gICAgLy8gbm90aWZ5IHRoZSBzeXN0ZW0gdGhhdCB3ZSBhcmUgYm9vdHN0cmFwcGVkXG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgnV2ViQ29tcG9uZW50c1JlYWR5Jywge2J1YmJsZXM6IHRydWV9KVxuICAgICk7XG4gIH0pO1xufVxuXG4vLyBDdXN0b21FdmVudCBzaGltIGZvciBJRVxuaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgd2luZG93LkN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oaW5UeXBlLCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBlLmluaXRDdXN0b21FdmVudChpblR5cGUsIEJvb2xlYW4ocGFyYW1zLmJ1YmJsZXMpLCBCb29sZWFuKHBhcmFtcy5jYW5jZWxhYmxlKSwgcGFyYW1zLmRldGFpbCk7XG4gICAgcmV0dXJuIGU7XG4gIH07XG4gIHdpbmRvdy5DdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xufVxuXG4vLyBXaGVuIGxvYWRpbmcgYXQgcmVhZHlTdGF0ZSBjb21wbGV0ZSB0aW1lIChvciB2aWEgZmxhZyksIGJvb3QgY3VzdG9tIGVsZW1lbnRzXG4vLyBpbW1lZGlhdGVseS5cbi8vIElmIHJlbGV2YW50LCBIVE1MSW1wb3J0cyBtdXN0IGFscmVhZHkgYmUgbG9hZGVkLlxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgc2NvcGUuZmxhZ3MuZWFnZXIpIHtcbiAgYm9vdHN0cmFwKCk7XG4vLyBXaGVuIGxvYWRpbmcgYXQgcmVhZHlTdGF0ZSBpbnRlcmFjdGl2ZSB0aW1lLCBib290c3RyYXAgb25seSBpZiBIVE1MSW1wb3J0c1xuLy8gYXJlIG5vdCBwZW5kaW5nLiBBbHNvIGF2b2lkIElFIGFzIHRoZSBzZW1hbnRpY3Mgb2YgdGhpcyBzdGF0ZSBhcmUgdW5yZWxpYWJsZS5cbn0gZWxzZSBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyAmJiAhd2luZG93LmF0dGFjaEV2ZW50ICYmXG4gICAgKCF3aW5kb3cuSFRNTEltcG9ydHMgfHwgd2luZG93LkhUTUxJbXBvcnRzLnJlYWR5KSkge1xuICBib290c3RyYXAoKTtcbi8vIFdoZW4gbG9hZGluZyBhdCBvdGhlciByZWFkeVN0YXRlcywgd2FpdCBmb3IgdGhlIGFwcHJvcHJpYXRlIERPTSBldmVudCB0byBcbi8vIGJvb3RzdHJhcC5cbn0gZWxzZSB7XG4gIHZhciBsb2FkRXZlbnQgPSB3aW5kb3cuSFRNTEltcG9ydHMgJiYgIUhUTUxJbXBvcnRzLnJlYWR5ID9cbiAgICAgICdIVE1MSW1wb3J0c0xvYWRlZCcgOiAnRE9NQ29udGVudExvYWRlZCc7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGxvYWRFdmVudCwgYm9vdHN0cmFwKTtcbn1cblxufSkod2luZG93LkN1c3RvbUVsZW1lbnRzKTtcblxuKGZ1bmN0aW9uICgpIHtcblxuLyoqKiBWYXJpYWJsZXMgKioqL1xuXG4gIHZhciB3aW4gPSB3aW5kb3csXG4gICAgZG9jID0gZG9jdW1lbnQsXG4gICAgYXR0clByb3RvID0ge1xuICAgICAgc2V0QXR0cmlidXRlOiBFbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUsXG4gICAgICByZW1vdmVBdHRyaWJ1dGU6IEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZVxuICAgIH0sXG4gICAgaGFzU2hhZG93ID0gRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU2hhZG93Um9vdCxcbiAgICBjb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgbm9vcCA9IGZ1bmN0aW9uKCl7fSxcbiAgICB0cnVlb3AgPSBmdW5jdGlvbigpeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICByZWdleENhbWVsVG9EYXNoID0gLyhbYS16XSkoW0EtWl0pL2csXG4gICAgcmVnZXhQc2V1ZG9QYXJlbnMgPSAvXFwofFxcKS9nLFxuICAgIHJlZ2V4UHNldWRvQ2FwdHVyZSA9IC86KFxcdyspXFx1Mjc2QSguKz8oPz1cXHUyNzZCKSl8OihcXHcrKS9nLFxuICAgIHJlZ2V4RGlnaXRzID0gLyhcXGQrKS9nLFxuICAgIGtleXBzZXVkbyA9IHtcbiAgICAgIGFjdGlvbjogZnVuY3Rpb24gKHBzZXVkbywgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBzZXVkby52YWx1ZS5tYXRjaChyZWdleERpZ2l0cykuaW5kZXhPZihTdHJpbmcoZXZlbnQua2V5Q29kZSkpID4gLTEgPT0gKHBzZXVkby5uYW1lID09ICdrZXlwYXNzJykgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qXG4gICAgICAtIFRoZSBwcmVmaXggb2JqZWN0IGdlbmVyYXRlZCBoZXJlIGlzIGFkZGVkIHRvIHRoZSB4dGFnIG9iamVjdCBhcyB4dGFnLnByZWZpeCBsYXRlciBpbiB0aGUgY29kZVxuICAgICAgLSBQcmVmaXggcHJvdmlkZXMgYSB2YXJpZXR5IG9mIHByZWZpeCB2YXJpYXRpb25zIGZvciB0aGUgYnJvd3NlciBpbiB3aGljaCB5b3VyIGNvZGUgaXMgcnVubmluZ1xuICAgICAgLSBUaGUgNCB2YXJpYXRpb25zIG9mIHByZWZpeCBhcmUgYXMgZm9sbG93czpcbiAgICAgICAgKiBwcmVmaXguZG9tOiB0aGUgY29ycmVjdCBwcmVmaXggY2FzZSBhbmQgZm9ybSB3aGVuIHVzZWQgb24gRE9NIGVsZW1lbnRzL3N0eWxlIHByb3BlcnRpZXNcbiAgICAgICAgKiBwcmVmaXgubG93ZXJjYXNlOiBhIGxvd2VyY2FzZSB2ZXJzaW9uIG9mIHRoZSBwcmVmaXggZm9yIHVzZSBpbiB2YXJpb3VzIHVzZXItY29kZSBzaXR1YXRpb25zXG4gICAgICAgICogcHJlZml4LmNzczogdGhlIGxvd2VyY2FzZSwgZGFzaGVkIHZlcnNpb24gb2YgdGhlIHByZWZpeFxuICAgICAgICAqIHByZWZpeC5qczogYWRkcmVzc2VzIHByZWZpeGVkIEFQSXMgcHJlc2VudCBpbiBnbG9iYWwgYW5kIG5vbi1FbGVtZW50IGNvbnRleHRzXG4gICAgKi9cbiAgICBwcmVmaXggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0eWxlcyA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKGRvYy5kb2N1bWVudEVsZW1lbnQsICcnKSxcbiAgICAgICAgICBwcmUgPSAoQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAgICAgICAuY2FsbChzdHlsZXMpXG4gICAgICAgICAgICAuam9pbignJylcbiAgICAgICAgICAgIC5tYXRjaCgvLShtb3p8d2Via2l0fG1zKS0vKSB8fCAoc3R5bGVzLk9MaW5rID09PSAnJyAmJiBbJycsICdvJ10pXG4gICAgICAgICAgKVsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogcHJlID09ICdtcycgPyAnTVMnIDogcHJlLFxuICAgICAgICBsb3dlcmNhc2U6IHByZSxcbiAgICAgICAgY3NzOiAnLScgKyBwcmUgKyAnLScsXG4gICAgICAgIGpzOiBwcmUgPT0gJ21zJyA/IHByZSA6IHByZVswXS50b1VwcGVyQ2FzZSgpICsgcHJlLnN1YnN0cigxKVxuICAgICAgfTtcbiAgICB9KSgpLFxuICAgIG1hdGNoU2VsZWN0b3IgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGVbcHJlZml4Lmxvd2VyY2FzZSArICdNYXRjaGVzU2VsZWN0b3InXSxcbiAgICBtdXRhdGlvbiA9IHdpbi5NdXRhdGlvbk9ic2VydmVyIHx8IHdpbltwcmVmaXguanMgKyAnTXV0YXRpb25PYnNlcnZlciddO1xuXG4vKioqIEZ1bmN0aW9ucyAqKiovXG5cbi8vIFV0aWxpdGllc1xuXG4gIC8qXG4gICAgVGhpcyBpcyBhbiBlbmhhbmNlZCB0eXBlb2YgY2hlY2sgZm9yIGFsbCB0eXBlcyBvZiBvYmplY3RzLiBXaGVyZSB0eXBlb2Ygd291bGQgbm9ybWFseSByZXR1cm5cbiAgICAnb2JqZWN0JyBmb3IgbWFueSBjb21tb24gRE9NIG9iamVjdHMgKGxpa2UgTm9kZUxpc3RzIGFuZCBIVE1MQ29sbGVjdGlvbnMpLlxuICAgIC0gRm9yIGV4YW1wbGU6IHR5cGVPZihkb2N1bWVudC5jaGlsZHJlbikgd2lsbCBjb3JyZWN0bHkgcmV0dXJuICdodG1sY29sbGVjdGlvbidcbiAgKi9cbiAgdmFyIHR5cGVDYWNoZSA9IHt9LFxuICAgICAgdHlwZVN0cmluZyA9IHR5cGVDYWNoZS50b1N0cmluZyxcbiAgICAgIHR5cGVSZWdleHAgPSAvXFxzKFthLXpBLVpdKykvO1xuICBmdW5jdGlvbiB0eXBlT2Yob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlU3RyaW5nLmNhbGwob2JqKTtcbiAgICByZXR1cm4gdHlwZUNhY2hlW3R5cGVdIHx8ICh0eXBlQ2FjaGVbdHlwZV0gPSB0eXBlLm1hdGNoKHR5cGVSZWdleHApWzFdLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmUoaXRlbSwgdHlwZSl7XG4gICAgdmFyIGZuID0gY2xvbmVbdHlwZSB8fCB0eXBlT2YoaXRlbSldO1xuICAgIHJldHVybiBmbiA/IGZuKGl0ZW0pIDogaXRlbTtcbiAgfVxuICAgIGNsb25lLm9iamVjdCA9IGZ1bmN0aW9uKHNyYyl7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSBvYmpba2V5XSA9IGNsb25lKHNyY1trZXldKTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBjbG9uZS5hcnJheSA9IGZ1bmN0aW9uKHNyYyl7XG4gICAgICB2YXIgaSA9IHNyYy5sZW5ndGgsIGFycmF5ID0gbmV3IEFycmF5KGkpO1xuICAgICAgd2hpbGUgKGktLSkgYXJyYXlbaV0gPSBjbG9uZShzcmNbaV0pO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG5cbiAgLypcbiAgICBUaGUgdG9BcnJheSgpIG1ldGhvZCBhbGxvd3MgZm9yIGNvbnZlcnNpb24gb2YgYW55IG9iamVjdCB0byBhIHRydWUgYXJyYXkuIEZvciB0eXBlcyB0aGF0XG4gICAgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhbiBhcnJheSwgdGhlIG1ldGhvZCByZXR1cm5zIGEgMSBpdGVtIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBhc3NlZC1pbiBvYmplY3QuXG4gICovXG4gIHZhciB1bnNsaWNlYWJsZSA9IFsndW5kZWZpbmVkJywgJ251bGwnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnc3RyaW5nJywgJ2Z1bmN0aW9uJ107XG4gIGZ1bmN0aW9uIHRvQXJyYXkob2JqKXtcbiAgICByZXR1cm4gdW5zbGljZWFibGUuaW5kZXhPZih0eXBlT2Yob2JqKSkgPT0gLTEgP1xuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCkgOlxuICAgIFtvYmpdO1xuICB9XG5cbi8vIERPTVxuXG4gIHZhciBzdHIgPSAnJztcbiAgZnVuY3Rpb24gcXVlcnkoZWxlbWVudCwgc2VsZWN0b3Ipe1xuICAgIHJldHVybiAoc2VsZWN0b3IgfHwgc3RyKS5sZW5ndGggPyB0b0FycmF5KGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpIDogW107XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU11dGF0aW9ucyhlbGVtZW50LCBtdXRhdGlvbnMpIHtcbiAgICB2YXIgZGlmZiA9IHsgYWRkZWQ6IFtdLCByZW1vdmVkOiBbXSB9O1xuICAgIG11dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJlY29yZCl7XG4gICAgICByZWNvcmQuX211dGF0aW9uID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIHogaW4gZGlmZikge1xuICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnQuX3JlY29yZHNbKHogPT0gJ2FkZGVkJykgPyAnaW5zZXJ0ZWQnIDogJ3JlbW92ZWQnXSxcbiAgICAgICAgICBub2RlcyA9IHJlY29yZFt6ICsgJ05vZGVzJ10sIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggJiYgZGlmZlt6XS5pbmRleE9mKG5vZGVzW2ldKSA9PSAtMTsgaSsrKXtcbiAgICAgICAgICBkaWZmW3pdLnB1c2gobm9kZXNbaV0pO1xuICAgICAgICAgIHR5cGUuZm9yRWFjaChmdW5jdGlvbihmbil7XG4gICAgICAgICAgICBmbihub2Rlc1tpXSwgcmVjb3JkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbi8vIFBzZXVkb3NcblxuICBmdW5jdGlvbiBwYXJzZVBzZXVkbyhmbil7Zm4oKTt9XG5cbi8vIE1peGluc1xuXG4gIGZ1bmN0aW9uIG1lcmdlT25lKHNvdXJjZSwga2V5LCBjdXJyZW50KXtcbiAgICB2YXIgdHlwZSA9IHR5cGVPZihjdXJyZW50KTtcbiAgICBpZiAodHlwZSA9PSAnb2JqZWN0JyAmJiB0eXBlT2Yoc291cmNlW2tleV0pID09ICdvYmplY3QnKSB4dGFnLm1lcmdlKHNvdXJjZVtrZXldLCBjdXJyZW50KTtcbiAgICBlbHNlIHNvdXJjZVtrZXldID0gY2xvbmUoY3VycmVudCwgdHlwZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBNaXhpbih0YWcsIGtleSwgcHNldWRvLCB2YWx1ZSwgb3JpZ2luYWwpe1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tleV07XG4gICAgaWYgKCEoa2V5IGluIG9yaWdpbmFsKSkge1xuICAgICAgb3JpZ2luYWxba2V5ICsgKHBzZXVkby5tYXRjaCgnOm1peGlucycpID8gJycgOiAnOm1peGlucycpXSA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb3JpZ2luYWxba2V5XSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoIWZuLl9fbWl4aW5zX18pIGZuLl9fbWl4aW5zX18gPSBbXTtcbiAgICAgIGZuLl9fbWl4aW5zX18ucHVzaCh4dGFnLmFwcGx5UHNldWRvcyhwc2V1ZG8sIHZhbHVlLCB0YWcucHNldWRvcykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmlxdWVNaXhpbkNvdW50ID0gMDtcbiAgZnVuY3Rpb24gbWVyZ2VNaXhpbih0YWcsIG1peGluLCBvcmlnaW5hbCwgbWl4KSB7XG4gICAgaWYgKG1peCkge1xuICAgICAgdmFyIHVuaXF1ZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIHogaW4gb3JpZ2luYWwpIHVuaXF1ZXNbei5zcGxpdCgnOicpWzBdXSA9IHo7XG4gICAgICBmb3IgKHogaW4gbWl4aW4pIHtcbiAgICAgICAgd3JhcE1peGluKHRhZywgdW5pcXVlc1t6LnNwbGl0KCc6JylbMF1dIHx8IHosIHosIG1peGluW3pdLCBvcmlnaW5hbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgenogaW4gbWl4aW4pe1xuICAgICAgICBvcmlnaW5hbFt6eiArICc6X19taXhpbl9fKCcgKyAodW5pcXVlTWl4aW5Db3VudCsrKSArICcpJ10gPSB4dGFnLmFwcGx5UHNldWRvcyh6eiwgbWl4aW5benpdLCB0YWcucHNldWRvcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlNaXhpbnModGFnKSB7XG4gICAgdGFnLm1peGlucy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgbWl4aW4gPSB4dGFnLm1peGluc1tuYW1lXTtcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gbWl4aW4pIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBtaXhpblt0eXBlXSxcbiAgICAgICAgICAgIG9yaWdpbmFsID0gdGFnW3R5cGVdO1xuICAgICAgICBpZiAoIW9yaWdpbmFsKSB0YWdbdHlwZV0gPSBpdGVtO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpe1xuICAgICAgICAgICAgY2FzZSAnYWNjZXNzb3JzJzogY2FzZSAncHJvdG90eXBlJzpcbiAgICAgICAgICAgICAgZm9yICh2YXIgeiBpbiBpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW5hbFt6XSkgb3JpZ2luYWxbel0gPSBpdGVtW3pdO1xuICAgICAgICAgICAgICAgIGVsc2UgbWVyZ2VNaXhpbih0YWcsIGl0ZW1bel0sIG9yaWdpbmFsW3pdLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IG1lcmdlTWl4aW4odGFnLCBpdGVtLCBvcmlnaW5hbCwgdHlwZSAhPSAnZXZlbnRzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuXG4vLyBFdmVudHNcblxuICBmdW5jdGlvbiBkZWxlZ2F0ZUFjdGlvbihwc2V1ZG8sIGV2ZW50KSB7XG4gICAgdmFyIG1hdGNoLCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgaWYgKCF0YXJnZXQudGFnTmFtZSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHh0YWcubWF0Y2hTZWxlY3Rvcih0YXJnZXQsIHBzZXVkby52YWx1ZSkpIG1hdGNoID0gdGFyZ2V0O1xuICAgIGVsc2UgaWYgKHh0YWcubWF0Y2hTZWxlY3Rvcih0YXJnZXQsIHBzZXVkby52YWx1ZSArICcgKicpKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICB3aGlsZSAoIW1hdGNoKSB7XG4gICAgICAgIGlmICh4dGFnLm1hdGNoU2VsZWN0b3IocGFyZW50LCBwc2V1ZG8udmFsdWUpKSBtYXRjaCA9IHBhcmVudDtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaCA/IHBzZXVkby5saXN0ZW5lciA9IHBzZXVkby5saXN0ZW5lci5iaW5kKG1hdGNoKSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaEZpbHRlcihldmVudCkge1xuICAgIGlmIChldmVudC50eXBlLm1hdGNoKCd0b3VjaCcpKXtcbiAgICAgIGV2ZW50LnRhcmdldC5fX3RvdWNoZWRfXyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LnRhcmdldC5fX3RvdWNoZWRfXyAmJiBldmVudC50eXBlLm1hdGNoKCdtb3VzZScpKXtcbiAgICAgIGRlbGV0ZSBldmVudC50YXJnZXQuX190b3VjaGVkX187XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVQcm9wZXJ0eShrZXksIGV2ZW50LCBiYXNlLCBkZXNjKXtcbiAgICBpZiAoZGVzYykgZXZlbnRba2V5XSA9IGJhc2Vba2V5XTtcbiAgICBlbHNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwga2V5LCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogYmFzZVtrZXldXG4gICAgfSk7XG4gIH1cblxuICB2YXIgc2tpcFByb3BzID0ge307XG4gIGZvciAodmFyIHogaW4gZG9jLmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpKSBza2lwUHJvcHNbel0gPSAxO1xuICBmdW5jdGlvbiBpbmhlcml0RXZlbnQoZXZlbnQsIGJhc2Upe1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihldmVudCwgJ3RhcmdldCcpO1xuICAgIGZvciAodmFyIHogaW4gYmFzZSkge1xuICAgICAgaWYgKCFza2lwUHJvcHNbel0pIHdyaXRlUHJvcGVydHkoeiwgZXZlbnQsIGJhc2UsIGRlc2MpO1xuICAgIH1cbiAgICBldmVudC5iYXNlRXZlbnQgPSBiYXNlO1xuICB9XG5cbi8vIEFjY2Vzc29yc1xuXG4gIGZ1bmN0aW9uIG1vZEF0dHIoZWxlbWVudCwgYXR0ciwgbmFtZSwgdmFsdWUsIG1ldGhvZCl7XG4gICAgYXR0clByb3RvW21ldGhvZF0uY2FsbChlbGVtZW50LCBuYW1lLCBhdHRyICYmIGF0dHIuYm9vbGVhbiA/ICcnIDogdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3luY0F0dHIoZWxlbWVudCwgYXR0ciwgbmFtZSwgdmFsdWUsIG1ldGhvZCl7XG4gICAgaWYgKGF0dHIgJiYgKGF0dHIucHJvcGVydHkgfHwgYXR0ci5zZWxlY3RvcikpIHtcbiAgICAgIHZhciBub2RlcyA9IGF0dHIucHJvcGVydHkgPyBbZWxlbWVudC54dGFnW2F0dHIucHJvcGVydHldXSA6IGF0dHIuc2VsZWN0b3IgPyB4dGFnLnF1ZXJ5KGVsZW1lbnQsIGF0dHIuc2VsZWN0b3IpIDogW10sXG4gICAgICAgICAgaW5kZXggPSBub2Rlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgbm9kZXNbaW5kZXhdW21ldGhvZF0obmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZpZXcoZWxlbWVudCwgbmFtZSwgdmFsdWUpe1xuICAgIGlmIChlbGVtZW50Ll9fdmlld19fKXtcbiAgICAgIGVsZW1lbnQuX192aWV3X18udXBkYXRlQmluZGluZ1ZhbHVlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRhY2hQcm9wZXJ0aWVzKHRhZywgcHJvcCwgeiwgYWNjZXNzb3IsIGF0dHIsIG5hbWUpe1xuICAgIHZhciBrZXkgPSB6LnNwbGl0KCc6JyksIHR5cGUgPSBrZXlbMF07XG4gICAgaWYgKHR5cGUgPT0gJ2dldCcpIHtcbiAgICAgIGtleVswXSA9IHByb3A7XG4gICAgICB0YWcucHJvdG90eXBlW3Byb3BdLmdldCA9IHh0YWcuYXBwbHlQc2V1ZG9zKGtleS5qb2luKCc6JyksIGFjY2Vzc29yW3pdLCB0YWcucHNldWRvcywgYWNjZXNzb3Jbel0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09ICdzZXQnKSB7XG4gICAgICBrZXlbMF0gPSBwcm9wO1xuICAgICAgdmFyIHNldHRlciA9IHRhZy5wcm90b3R5cGVbcHJvcF0uc2V0ID0geHRhZy5hcHBseVBzZXVkb3Moa2V5LmpvaW4oJzonKSwgYXR0ciA/IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICB2YWx1ZSA9IGF0dHIuYm9vbGVhbiA/ICEhdmFsdWUgOiBhdHRyLnZhbGlkYXRlID8gYXR0ci52YWxpZGF0ZS5jYWxsKHRoaXMsIHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgIHZhciBtZXRob2QgPSBhdHRyLmJvb2xlYW4gPyAodmFsdWUgPyAnc2V0QXR0cmlidXRlJyA6ICdyZW1vdmVBdHRyaWJ1dGUnKSA6ICdzZXRBdHRyaWJ1dGUnO1xuICAgICAgICBtb2RBdHRyKHRoaXMsIGF0dHIsIG5hbWUsIHZhbHVlLCBtZXRob2QpO1xuICAgICAgICBhY2Nlc3Nvclt6XS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgc3luY0F0dHIodGhpcywgYXR0ciwgbmFtZSwgdmFsdWUsIG1ldGhvZCk7XG4gICAgICAgIHVwZGF0ZVZpZXcodGhpcywgcHJvcCwgdmFsdWUpO1xuICAgICAgfSA6IGFjY2Vzc29yW3pdID8gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBhY2Nlc3Nvclt6XS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgdXBkYXRlVmlldyh0aGlzLCBwcm9wLCB2YWx1ZSk7XG4gICAgICB9IDogbnVsbCwgdGFnLnBzZXVkb3MsIGFjY2Vzc29yW3pdKTtcblxuICAgICAgaWYgKGF0dHIpIGF0dHIuc2V0dGVyID0gYWNjZXNzb3Jbel07XG4gICAgfVxuICAgIGVsc2UgdGFnLnByb3RvdHlwZVtwcm9wXVt6XSA9IGFjY2Vzc29yW3pdO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VBY2Nlc3Nvcih0YWcsIHByb3Ape1xuICAgIHRhZy5wcm90b3R5cGVbcHJvcF0gPSB7fTtcbiAgICB2YXIgYWNjZXNzb3IgPSB0YWcuYWNjZXNzb3JzW3Byb3BdLFxuICAgICAgICBhdHRyID0gYWNjZXNzb3IuYXR0cmlidXRlLFxuICAgICAgICBuYW1lO1xuXG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIG5hbWUgPSBhdHRyLm5hbWUgPSAoYXR0ciA/IChhdHRyLm5hbWUgfHwgcHJvcC5yZXBsYWNlKHJlZ2V4Q2FtZWxUb0Rhc2gsICckMS0kMicpKSA6IHByb3ApLnRvTG93ZXJDYXNlKCk7XG4gICAgICBhdHRyLmtleSA9IHByb3A7XG4gICAgICB0YWcuYXR0cmlidXRlc1tuYW1lXSA9IGF0dHI7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgeiBpbiBhY2Nlc3NvcikgYXR0YWNoUHJvcGVydGllcyh0YWcsIHByb3AsIHosIGFjY2Vzc29yLCBhdHRyLCBuYW1lKTtcblxuICAgIGlmIChhdHRyKSB7XG4gICAgICBpZiAoIXRhZy5wcm90b3R5cGVbcHJvcF0uZ2V0KSB7XG4gICAgICAgIHZhciBtZXRob2QgPSAoYXR0ci5ib29sZWFuID8gJ2hhcycgOiAnZ2V0JykgKyAnQXR0cmlidXRlJztcbiAgICAgICAgdGFnLnByb3RvdHlwZVtwcm9wXS5nZXQgPSBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiB0aGlzW21ldGhvZF0obmFtZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIXRhZy5wcm90b3R5cGVbcHJvcF0uc2V0KSB0YWcucHJvdG90eXBlW3Byb3BdLnNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgdmFsdWUgPSBhdHRyLmJvb2xlYW4gPyAhIXZhbHVlIDogYXR0ci52YWxpZGF0ZSA/IGF0dHIudmFsaWRhdGUuY2FsbCh0aGlzLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGF0dHIuYm9vbGVhbiA/ICh2YWx1ZSA/ICdzZXRBdHRyaWJ1dGUnIDogJ3JlbW92ZUF0dHJpYnV0ZScpIDogJ3NldEF0dHJpYnV0ZSc7XG4gICAgICAgIG1vZEF0dHIodGhpcywgYXR0ciwgbmFtZSwgdmFsdWUsIG1ldGhvZCk7XG4gICAgICAgIHN5bmNBdHRyKHRoaXMsIGF0dHIsIG5hbWUsIHZhbHVlLCBtZXRob2QpO1xuICAgICAgICB1cGRhdGVWaWV3KHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIHVud3JhcENvbW1lbnQgPSAvXFwvXFwqIT8oPzpcXEBwcmVzZXJ2ZSk/WyBcXHRdKig/OlxcclxcbnxcXG4pKFtcXHNcXFNdKj8pKD86XFxyXFxufFxcbilcXHMqXFwqXFwvLztcbiAgZnVuY3Rpb24gcGFyc2VNdWx0aWxpbmUoZm4pe1xuICAgIHJldHVybiB1bndyYXBDb21tZW50LmV4ZWMoZm4udG9TdHJpbmcoKSlbMV07XG4gIH1cblxuLyoqKiBYLVRhZyBPYmplY3QgRGVmaW5pdGlvbiAqKiovXG5cbiAgdmFyIHh0YWcgPSB7XG4gICAgdGFnczoge30sXG4gICAgZGVmYXVsdE9wdGlvbnM6IHtcbiAgICAgIHBzZXVkb3M6IFtdLFxuICAgICAgbWl4aW5zOiBbXSxcbiAgICAgIGV2ZW50czoge30sXG4gICAgICBtZXRob2RzOiB7fSxcbiAgICAgIGFjY2Vzc29yczoge30sXG4gICAgICBsaWZlY3ljbGU6IHt9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAncHJvdG90eXBlJzoge1xuICAgICAgICB4dGFnOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX194dGFnX18gPyB0aGlzLl9feHRhZ19fIDogKHRoaXMuX194dGFnX18gPSB7IGRhdGE6IHt9IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX25hbWU7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgX25hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB4dGFnLnRhZ3NbX25hbWVdID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIC8vIHNhdmUgcHJvdG90eXBlIGZvciBhY3R1YWwgb2JqZWN0IGNyZWF0aW9uIGJlbG93XG4gICAgICB2YXIgYmFzZVByb3RvdHlwZSA9IG9wdGlvbnMucHJvdG90eXBlO1xuICAgICAgZGVsZXRlIG9wdGlvbnMucHJvdG90eXBlO1xuICAgICAgdmFyIHRhZyA9IHh0YWcudGFnc1tfbmFtZV0uY29tcGlsZWQgPSBhcHBseU1peGlucyh4dGFnLm1lcmdlKHt9LCB4dGFnLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKSk7XG5cbiAgICAgIGZvciAodmFyIHogaW4gdGFnLmV2ZW50cykgdGFnLmV2ZW50c1t6XSA9IHh0YWcucGFyc2VFdmVudCh6LCB0YWcuZXZlbnRzW3pdKTtcbiAgICAgIGZvciAoeiBpbiB0YWcubGlmZWN5Y2xlKSB0YWcubGlmZWN5Y2xlW3ouc3BsaXQoJzonKVswXV0gPSB4dGFnLmFwcGx5UHNldWRvcyh6LCB0YWcubGlmZWN5Y2xlW3pdLCB0YWcucHNldWRvcywgdGFnLmxpZmVjeWNsZVt6XSk7XG4gICAgICBmb3IgKHogaW4gdGFnLm1ldGhvZHMpIHRhZy5wcm90b3R5cGVbei5zcGxpdCgnOicpWzBdXSA9IHsgdmFsdWU6IHh0YWcuYXBwbHlQc2V1ZG9zKHosIHRhZy5tZXRob2RzW3pdLCB0YWcucHNldWRvcywgdGFnLm1ldGhvZHNbel0pLCBlbnVtZXJhYmxlOiB0cnVlIH07XG4gICAgICBmb3IgKHogaW4gdGFnLmFjY2Vzc29ycykgcGFyc2VBY2Nlc3Nvcih0YWcsIHopO1xuXG4gICAgICB0YWcuc2hhZG93ID0gdGFnLnNoYWRvdyA/IHh0YWcuY3JlYXRlRnJhZ21lbnQodGFnLnNoYWRvdykgOiBudWxsO1xuICAgICAgdGFnLmNvbnRlbnQgPSB0YWcuY29udGVudCA/IHh0YWcuY3JlYXRlRnJhZ21lbnQodGFnLmNvbnRlbnQpIDogbnVsbDtcbiAgICAgIHZhciByZWFkeSA9IHRhZy5saWZlY3ljbGUuY3JlYXRlZCB8fCB0YWcubGlmZWN5Y2xlLnJlYWR5O1xuICAgICAgdGFnLnByb3RvdHlwZS5jcmVhdGVkQ2FsbGJhY2sgPSB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcztcbiAgICAgICAgICBpZiAodGFnLnNoYWRvdyAmJiBoYXNTaGFkb3cpIHRoaXMuY3JlYXRlU2hhZG93Um9vdCgpLmFwcGVuZENoaWxkKHRhZy5zaGFkb3cuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICBpZiAodGFnLmNvbnRlbnQpIHRoaXMuYXBwZW5kQ2hpbGQodGFnLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICB4dGFnLmFkZEV2ZW50cyh0aGlzLCB0YWcuZXZlbnRzKTtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gcmVhZHkgPyByZWFkeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRhZy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHRhZy5hdHRyaWJ1dGVzW25hbWVdLFxuICAgICAgICAgICAgICAgIGhhc0F0dHIgPSB0aGlzLmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChoYXNBdHRyIHx8IGF0dHIuYm9vbGVhbikge1xuICAgICAgICAgICAgICB0aGlzW2F0dHIua2V5XSA9IGF0dHIuYm9vbGVhbiA/IGhhc0F0dHIgOiB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnLnBzZXVkb3MuZm9yRWFjaChmdW5jdGlvbihvYmope1xuICAgICAgICAgICAgb2JqLm9uQWRkLmNhbGwoZWxlbWVudCwgb2JqKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5zZXJ0ZWQgPSB0YWcubGlmZWN5Y2xlLmluc2VydGVkLFxuICAgICAgICAgIHJlbW92ZWQgPSB0YWcubGlmZWN5Y2xlLnJlbW92ZWQ7XG4gICAgICBpZiAoaW5zZXJ0ZWQgfHwgcmVtb3ZlZCkge1xuICAgICAgICB0YWcucHJvdG90eXBlLmF0dGFjaGVkQ2FsbGJhY2sgPSB7IHZhbHVlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIGlmIChyZW1vdmVkKSB0aGlzLnh0YWcuX19wYXJlbnROb2RlX18gPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICAgICAgaWYgKGluc2VydGVkKSByZXR1cm4gaW5zZXJ0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZW51bWVyYWJsZTogdHJ1ZSB9O1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgdGFnLnByb3RvdHlwZS5kZXRhY2hlZENhbGxiYWNrID0geyB2YWx1ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgICBhcmdzLnVuc2hpZnQodGhpcy54dGFnLl9fcGFyZW50Tm9kZV9fKTtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gcmVtb3ZlZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy54dGFnLl9fcGFyZW50Tm9kZV9fO1xuICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sIGVudW1lcmFibGU6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWcubGlmZWN5Y2xlLmF0dHJpYnV0ZUNoYW5nZWQpIHRhZy5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0geyB2YWx1ZTogdGFnLmxpZmVjeWNsZS5hdHRyaWJ1dGVDaGFuZ2VkLCBlbnVtZXJhYmxlOiB0cnVlIH07XG5cbiAgICAgIHRhZy5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0ge1xuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWJlcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpe1xuICAgICAgICAgIHZhciBfbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYXR0ciA9IHRhZy5hdHRyaWJ1dGVzW19uYW1lXTtcbiAgICAgICAgICBpZiAoYXR0cikge1xuICAgICAgICAgICAgdmFsdWUgPSBhdHRyLmJvb2xlYW4gPyAnJyA6IGF0dHIudmFsaWRhdGUgPyBhdHRyLnZhbGlkYXRlLmNhbGwodGhpcywgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZEF0dHIodGhpcywgYXR0ciwgX25hbWUsIHZhbHVlLCAnc2V0QXR0cmlidXRlJyk7XG4gICAgICAgICAgaWYgKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLnNldHRlcikgYXR0ci5zZXR0ZXIuY2FsbCh0aGlzLCBhdHRyLmJvb2xlYW4gPyB0cnVlIDogdmFsdWUpO1xuICAgICAgICAgICAgc3luY0F0dHIodGhpcywgYXR0ciwgX25hbWUsIHZhbHVlLCAnc2V0QXR0cmlidXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0YWcucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IHtcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1iZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5hbWUpe1xuICAgICAgICAgIHZhciBfbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYXR0ciA9IHRhZy5hdHRyaWJ1dGVzW19uYW1lXTtcbiAgICAgICAgICBtb2RBdHRyKHRoaXMsIGF0dHIsIF9uYW1lLCAnJywgJ3JlbW92ZUF0dHJpYnV0ZScpO1xuICAgICAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5zZXR0ZXIpIGF0dHIuc2V0dGVyLmNhbGwodGhpcywgYXR0ci5ib29sZWFuID8gZmFsc2UgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgc3luY0F0dHIodGhpcywgYXR0ciwgX25hbWUsICcnLCAncmVtb3ZlQXR0cmlidXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgZWxlbWVudFByb3RvID0gYmFzZVByb3RvdHlwZSA/XG4gICAgICAgICAgICBiYXNlUHJvdG90eXBlIDpcbiAgICAgICAgICAgIG9wdGlvbnNbJ2V4dGVuZHMnXSA/XG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGRvYy5jcmVhdGVFbGVtZW50KG9wdGlvbnNbJ2V4dGVuZHMnXSkuY29uc3RydWN0b3IpLnByb3RvdHlwZSA6XG4gICAgICAgICAgICB3aW4uSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgICB2YXIgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgJ3Byb3RvdHlwZSc6IE9iamVjdC5jcmVhdGUoZWxlbWVudFByb3RvLCB0YWcucHJvdG90eXBlKVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zWydleHRlbmRzJ10pIHtcbiAgICAgICAgZGVmaW5pdGlvblsnZXh0ZW5kcyddID0gb3B0aW9uc1snZXh0ZW5kcyddO1xuICAgICAgfVxuICAgICAgdmFyIHJlZyA9IGRvYy5yZWdpc3RlckVsZW1lbnQoX25hbWUsIGRlZmluaXRpb24pO1xuICAgICAgcmV0dXJuIHJlZztcbiAgICB9LFxuXG4gICAgLyogRXhwb3NlZCBWYXJpYWJsZXMgKi9cblxuICAgIG1peGluczoge30sXG4gICAgcHJlZml4OiBwcmVmaXgsXG4gICAgY2FwdHVyZUV2ZW50czogWydmb2N1cycsICdibHVyJywgJ3Njcm9sbCcsICd1bmRlcmZsb3cnLCAnb3ZlcmZsb3cnLCAnb3ZlcmZsb3djaGFuZ2VkJywgJ0RPTU1vdXNlU2Nyb2xsJ10sXG4gICAgY3VzdG9tRXZlbnRzOiB7XG4gICAgICBhbmltYXRpb25zdGFydDoge1xuICAgICAgICBhdHRhY2g6IFtwcmVmaXguZG9tICsgJ0FuaW1hdGlvblN0YXJ0J11cbiAgICAgIH0sXG4gICAgICBhbmltYXRpb25lbmQ6IHtcbiAgICAgICAgYXR0YWNoOiBbcHJlZml4LmRvbSArICdBbmltYXRpb25FbmQnXVxuICAgICAgfSxcbiAgICAgIHRyYW5zaXRpb25lbmQ6IHtcbiAgICAgICAgYXR0YWNoOiBbcHJlZml4LmRvbSArICdUcmFuc2l0aW9uRW5kJ11cbiAgICAgIH0sXG4gICAgICBtb3ZlOiB7XG4gICAgICAgIGF0dGFjaDogWydtb3VzZW1vdmUnLCAndG91Y2htb3ZlJ10sXG4gICAgICAgIGNvbmRpdGlvbjogdG91Y2hGaWx0ZXJcbiAgICAgIH0sXG4gICAgICBlbnRlcjoge1xuICAgICAgICBhdHRhY2g6IFsnbW91c2VvdmVyJywgJ3RvdWNoZW50ZXInXSxcbiAgICAgICAgY29uZGl0aW9uOiB0b3VjaEZpbHRlclxuICAgICAgfSxcbiAgICAgIGxlYXZlOiB7XG4gICAgICAgIGF0dGFjaDogWydtb3VzZW91dCcsICd0b3VjaGxlYXZlJ10sXG4gICAgICAgIGNvbmRpdGlvbjogdG91Y2hGaWx0ZXJcbiAgICAgIH0sXG4gICAgICBzY3JvbGx3aGVlbDoge1xuICAgICAgICBhdHRhY2g6IFsnRE9NTW91c2VTY3JvbGwnLCAnbW91c2V3aGVlbCddLFxuICAgICAgICBjb25kaXRpb246IGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICBldmVudC5kZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgPyBldmVudC53aGVlbERlbHRhIC8gNDAgOiBNYXRoLnJvdW5kKGV2ZW50LmRldGFpbCAvIDMuNSAqIC0xKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRhcHN0YXJ0OiB7XG4gICAgICAgIG9ic2VydmU6IHtcbiAgICAgICAgICBtb3VzZWRvd246IGRvYyxcbiAgICAgICAgICB0b3VjaHN0YXJ0OiBkb2NcbiAgICAgICAgfSxcbiAgICAgICAgY29uZGl0aW9uOiB0b3VjaEZpbHRlclxuICAgICAgfSxcbiAgICAgIHRhcGVuZDoge1xuICAgICAgICBvYnNlcnZlOiB7XG4gICAgICAgICAgbW91c2V1cDogZG9jLFxuICAgICAgICAgIHRvdWNoZW5kOiBkb2NcbiAgICAgICAgfSxcbiAgICAgICAgY29uZGl0aW9uOiB0b3VjaEZpbHRlclxuICAgICAgfSxcbiAgICAgIHRhcG1vdmU6IHtcbiAgICAgICAgYXR0YWNoOiBbJ3RhcHN0YXJ0JywgJ2RyYWdlbmQnLCAndG91Y2hjYW5jZWwnXSxcbiAgICAgICAgY29uZGl0aW9uOiBmdW5jdGlvbihldmVudCwgY3VzdG9tKXtcbiAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOiAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlICdkcmFnb3Zlcic6XG4gICAgICAgICAgICAgIHZhciBsYXN0ID0gY3VzdG9tLmxhc3REcmFnIHx8IHt9O1xuICAgICAgICAgICAgICBjdXN0b20ubGFzdERyYWcgPSBldmVudDtcbiAgICAgICAgICAgICAgcmV0dXJuIChsYXN0LnBhZ2VYICE9IGV2ZW50LnBhZ2VYICYmIGxhc3QucGFnZVkgIT0gZXZlbnQucGFnZVkpIHx8IG51bGw7XG4gICAgICAgICAgICBjYXNlICd0YXBzdGFydCc6XG4gICAgICAgICAgICAgIGlmICghY3VzdG9tLm1vdmUpIHtcbiAgICAgICAgICAgICAgICBjdXN0b20uY3VycmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY3VzdG9tLm1vdmUgPSB4dGFnLmFkZEV2ZW50cyh0aGlzLCB7XG4gICAgICAgICAgICAgICAgICBtb3ZlOiBjdXN0b20ubGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICBkcmFnb3ZlcjogY3VzdG9tLmxpc3RlbmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3VzdG9tLnRhcGVuZCA9IHh0YWcuYWRkRXZlbnQoZG9jLCAndGFwZW5kJywgY3VzdG9tLmxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RhcGVuZCc6IGNhc2UgJ2RyYWdlbmQnOiBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgICAgICAgICAgIGlmICghZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tLm1vdmUpIHh0YWcucmVtb3ZlRXZlbnRzKGN1c3RvbS5jdXJyZW50ICwgY3VzdG9tLm1vdmUgfHwge30pO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b20udGFwZW5kKSB4dGFnLnJlbW92ZUV2ZW50KGRvYywgY3VzdG9tLnRhcGVuZCB8fCB7fSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN1c3RvbS5sYXN0RHJhZztcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VzdG9tLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN1c3RvbS50YXBlbmQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN1c3RvbS5tb3ZlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwc2V1ZG9zOiB7XG4gICAgICBfX21peGluX186IHt9LFxuICAgICAgLypcblxuXG4gICAgICAqL1xuICAgICAgbWl4aW5zOiB7XG4gICAgICAgIG9uQ29tcGlsZWQ6IGZ1bmN0aW9uKGZuLCBwc2V1ZG8pe1xuICAgICAgICAgIHZhciBtaXhpbnMgPSBwc2V1ZG8uc291cmNlLl9fbWl4aW5zX187XG4gICAgICAgICAgaWYgKG1peGlucykgc3dpdGNoIChwc2V1ZG8udmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6IHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICBtaXhpbnMuZm9yRWFjaChmdW5jdGlvbihtKXtcbiAgICAgICAgICAgICAgICBtLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgbnVsbDogY2FzZSAnJzogY2FzZSAnYWZ0ZXInOiByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgIHJldHVybnMgPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgICAgbWl4aW5zLmZvckVhY2goZnVuY3Rpb24obSl7XG4gICAgICAgICAgICAgICAgbS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5zO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBrZXlwYXNzOiBrZXlwc2V1ZG8sXG4gICAgICBrZXlmYWlsOiBrZXlwc2V1ZG8sXG4gICAgICBkZWxlZ2F0ZTogeyBhY3Rpb246IGRlbGVnYXRlQWN0aW9uIH0sXG4gICAgICB3aXRoaW46IHtcbiAgICAgICAgYWN0aW9uOiBkZWxlZ2F0ZUFjdGlvbixcbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKHBzZXVkbyl7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHBzZXVkby5zb3VyY2UuY29uZGl0aW9uO1xuICAgICAgICAgIGlmIChjb25kaXRpb24pIHBzZXVkby5zb3VyY2UuY29uZGl0aW9uID0gZnVuY3Rpb24oZXZlbnQsIGN1c3RvbSl7XG4gICAgICAgICAgICByZXR1cm4geHRhZy5xdWVyeSh0aGlzLCBwc2V1ZG8udmFsdWUpLmZpbHRlcihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgPT0gZXZlbnQudGFyZ2V0IHx8IG5vZGUuY29udGFpbnMgPyBub2RlLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgOiBudWxsO1xuICAgICAgICAgICAgfSlbMF0gPyBjb25kaXRpb24uY2FsbCh0aGlzLCBldmVudCwgY3VzdG9tKSA6IG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByZXZlbnRhYmxlOiB7XG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKHBzZXVkbywgZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogVVRJTElUSUVTICovXG5cbiAgICBjbG9uZTogY2xvbmUsXG4gICAgdHlwZU9mOiB0eXBlT2YsXG4gICAgdG9BcnJheTogdG9BcnJheSxcblxuICAgIHdyYXA6IGZ1bmN0aW9uIChvcmlnaW5hbCwgZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIG91dHB1dCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKlxuICAgICAgUmVjdXJzaXZlbHkgbWVyZ2VzIG9uZSBvYmplY3Qgd2l0aCBhbm90aGVyLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCxcbiAgICAgIGFsbCBvdGhlciBvYmplY3RzIHBhc3NlZCBpbiBhcyBhcmd1bWVudHMgYXJlIG1lcmdlZCBmcm9tIHJpZ2h0IHRvIGxlZnQsIGNvbmZsaWN0cyBhcmUgb3ZlcndyaXR0ZW5cbiAgICAqL1xuICAgIG1lcmdlOiBmdW5jdGlvbihzb3VyY2UsIGssIHYpe1xuICAgICAgaWYgKHR5cGVPZihrKSA9PSAnc3RyaW5nJykgcmV0dXJuIG1lcmdlT25lKHNvdXJjZSwgaywgdik7XG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspe1xuICAgICAgICB2YXIgb2JqZWN0ID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBtZXJnZU9uZShzb3VyY2UsIGtleSwgb2JqZWN0W2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgIC0tLS0tIFRoaXMgc2hvdWxkIGJlIHNpbXBsaWZpZWQhIC0tLS0tXG4gICAgICBHZW5lcmF0ZXMgYSByYW5kb20gSUQgc3RyaW5nXG4gICAgKi9cbiAgICB1aWQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsMTApO1xuICAgIH0sXG5cbiAgICAvKiBET00gKi9cblxuICAgIHF1ZXJ5OiBxdWVyeSxcblxuICAgIHNraXBUcmFuc2l0aW9uOiBmdW5jdGlvbihlbGVtZW50LCBmbiwgYmluZCl7XG4gICAgICB2YXIgcHJvcCA9IHByZWZpeC5qcyArICdUcmFuc2l0aW9uUHJvcGVydHknO1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ25vbmUnO1xuICAgICAgdmFyIGNhbGxiYWNrID0gZm4gPyBmbi5jYWxsKGJpbmQgfHwgZWxlbWVudCkgOiBudWxsO1xuICAgICAgcmV0dXJuIHh0YWcuc2tpcEZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICcnO1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmNhbGwoYmluZCB8fCBlbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZXF1ZXN0RnJhbWU6IChmdW5jdGlvbigpe1xuICAgICAgdmFyIHJhZiA9IHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5bcHJlZml4Lmxvd2VyY2FzZSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGZuKXsgcmV0dXJuIHdpbi5zZXRUaW1lb3V0KGZuLCAyMCk7IH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm4peyByZXR1cm4gcmFmKGZuKTsgfTtcbiAgICB9KSgpLFxuXG4gICAgY2FuY2VsRnJhbWU6IChmdW5jdGlvbigpe1xuICAgICAgdmFyIGNhbmNlbCA9IHdpbi5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgIHdpbltwcmVmaXgubG93ZXJjYXNlICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHxcbiAgICAgICAgICAgICAgICAgICB3aW4uY2xlYXJUaW1lb3V0O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGlkKXsgcmV0dXJuIGNhbmNlbChpZCk7IH07XG4gICAgfSkoKSxcblxuICAgIHNraXBGcmFtZTogZnVuY3Rpb24oZm4pe1xuICAgICAgdmFyIGlkID0geHRhZy5yZXF1ZXN0RnJhbWUoZnVuY3Rpb24oKXsgaWQgPSB4dGFnLnJlcXVlc3RGcmFtZShmbik7IH0pO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG5cbiAgICBtYXRjaFNlbGVjdG9yOiBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBtYXRjaFNlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIChlbGVtZW50LCBtZXRob2QsIHZhbHVlKSB7XG4gICAgICBlbGVtZW50W21ldGhvZF0gPSB2YWx1ZTtcbiAgICAgIGlmICh3aW5kb3cuQ3VzdG9tRWxlbWVudHMpIEN1c3RvbUVsZW1lbnRzLnVwZ3JhZGVBbGwoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGlubmVySFRNTDogZnVuY3Rpb24oZWwsIGh0bWwpe1xuICAgICAgeHRhZy5zZXQoZWwsICdpbm5lckhUTUwnLCBodG1sKTtcbiAgICB9LFxuXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBrbGFzcykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJykuaW5kZXhPZihrbGFzcy50cmltKCkpPi0xO1xuICAgIH0sXG5cbiAgICBhZGRDbGFzczogZnVuY3Rpb24gKGVsZW1lbnQsIGtsYXNzKSB7XG4gICAgICB2YXIgbGlzdCA9IGVsZW1lbnQuY2xhc3NOYW1lLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAga2xhc3MudHJpbSgpLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoIX5saXN0LmluZGV4T2YobmFtZSkpIGxpc3QucHVzaChuYW1lKTtcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBsaXN0LmpvaW4oJyAnKS50cmltKCk7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChlbGVtZW50LCBrbGFzcykge1xuICAgICAgdmFyIGNsYXNzZXMgPSBrbGFzcy50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuYW1lICYmICF+Y2xhc3Nlcy5pbmRleE9mKG5hbWUpO1xuICAgICAgfSkuam9pbignICcpO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwga2xhc3MpIHtcbiAgICAgIHJldHVybiB4dGFnW3h0YWcuaGFzQ2xhc3MoZWxlbWVudCwga2xhc3MpID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcyddLmNhbGwobnVsbCwgZWxlbWVudCwga2xhc3MpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAgUnVucyBhIHF1ZXJ5IG9uIG9ubHkgdGhlIGNoaWxkcmVuIG9mIGFuIGVsZW1lbnRcbiAgICAqL1xuICAgIHF1ZXJ5Q2hpbGRyZW46IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgdmFyIGlkID0gZWxlbWVudC5pZCxcbiAgICAgICAgZ3VpZCA9IGVsZW1lbnQuaWQgPSBpZCB8fCAneF8nICsgeHRhZy51aWQoKSxcbiAgICAgICAgYXR0ciA9ICcjJyArIGd1aWQgKyAnID4gJyxcbiAgICAgICAgbm9QYXJlbnQgPSBmYWxzZTtcbiAgICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlKXtcbiAgICAgICAgbm9QYXJlbnQgPSB0cnVlO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBzZWxlY3RvciA9IGF0dHIgKyAoc2VsZWN0b3IgKyAnJykucmVwbGFjZSgnLCcsICcsJyArIGF0dHIsICdnJyk7XG4gICAgICB2YXIgcmVzdWx0ID0gZWxlbWVudC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgaWYgKCFpZCkgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBpZiAobm9QYXJlbnQpe1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9BcnJheShyZXN1bHQpO1xuICAgIH0sXG4gICAgLypcbiAgICAgIENyZWF0ZXMgYSBkb2N1bWVudCBmcmFnbWVudCB3aXRoIHRoZSBjb250ZW50IHBhc3NlZCBpbiAtIGNvbnRlbnQgY2FuIGJlXG4gICAgICBhIHN0cmluZyBvZiBIVE1MLCBhbiBlbGVtZW50LCBvciBhbiBhcnJheS9jb2xsZWN0aW9uIG9mIGVsZW1lbnRzXG4gICAgKi9cbiAgICBjcmVhdGVGcmFnbWVudDogZnVuY3Rpb24oY29udGVudCkge1xuICAgICAgdmFyIGZyYWcgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGRpdiA9IGZyYWcuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpKSxcbiAgICAgICAgICBub2RlcyA9IHRvQXJyYXkoY29udGVudC5ub2RlTmFtZSA/IGFyZ3VtZW50cyA6ICEoZGl2LmlubmVySFRNTCA9IHR5cGVvZiBjb250ZW50ID09ICdmdW5jdGlvbicgPyBwYXJzZU11bHRpbGluZShjb250ZW50KSA6IGNvbnRlbnQpIHx8IGRpdi5jaGlsZHJlbiksXG4gICAgICAgICAgbGVuZ3RoID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSBmcmFnLmluc2VydEJlZm9yZShub2Rlc1tpbmRleCsrXSwgZGl2KTtcbiAgICAgICAgZnJhZy5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NIGZvciBtb3JlIHBlcmZvcm1hbnQgbm9kZSBtYW5pcHVsYXRpb24uIFRoZSBlbGVtZW50XG4gICAgICBpcyBwbGFjZWQgYmFjayBpbnRvIHRoZSBET00gYXQgdGhlIHBsYWNlIGl0IHdhcyB0YWtlbiBmcm9tLlxuICAgICovXG4gICAgbWFuaXB1bGF0ZTogZnVuY3Rpb24oZWxlbWVudCwgZm4pe1xuICAgICAgdmFyIG5leHQgPSBlbGVtZW50Lm5leHRTaWJsaW5nLFxuICAgICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICAgIGZyYWcgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICByZXR1cm5lZCA9IGZuLmNhbGwoZnJhZy5hcHBlbmRDaGlsZChlbGVtZW50KSwgZnJhZykgfHwgZWxlbWVudDtcbiAgICAgIGlmIChuZXh0KSBwYXJlbnQuaW5zZXJ0QmVmb3JlKHJldHVybmVkLCBuZXh0KTtcbiAgICAgIGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKHJldHVybmVkKTtcbiAgICB9LFxuXG4gICAgLyogUFNFVURPUyAqL1xuXG4gICAgYXBwbHlQc2V1ZG9zOiBmdW5jdGlvbihrZXksIGZuLCB0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gZm4sXG4gICAgICAgICAgcHNldWRvcyA9IHt9O1xuICAgICAgaWYgKGtleS5tYXRjaCgnOicpKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gW10sXG4gICAgICAgICAgICB2YWx1ZUZsYWcgPSAwO1xuICAgICAgICBrZXkucmVwbGFjZShyZWdleFBzZXVkb1BhcmVucywgZnVuY3Rpb24obWF0Y2gpe1xuICAgICAgICAgIGlmIChtYXRjaCA9PSAnKCcpIHJldHVybiArK3ZhbHVlRmxhZyA9PSAxID8gJ1xcdTI3NkEnIDogJygnO1xuICAgICAgICAgIHJldHVybiAhLS12YWx1ZUZsYWcgPyAnXFx1Mjc2QicgOiAnKSc7XG4gICAgICAgIH0pLnJlcGxhY2UocmVnZXhQc2V1ZG9DYXB0dXJlLCBmdW5jdGlvbih6LCBuYW1lLCB2YWx1ZSwgc29sbyl7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKFtuYW1lIHx8IHNvbG8sIHZhbHVlXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaSA9IG1hdGNoZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwYXJzZVBzZXVkbyhmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBuYW1lID0gbWF0Y2hlc1tpXVswXSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaGVzW2ldWzFdO1xuICAgICAgICAgIGlmICgheHRhZy5wc2V1ZG9zW25hbWVdKSB0aHJvdyBcInBzZXVkbyBub3QgZm91bmQ6IFwiICsgbmFtZSArIFwiIFwiICsgdmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSAodmFsdWUgPT09ICcnIHx8IHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJykgPyBudWxsIDogdmFsdWU7XG4gICAgICAgICAgdmFyIHBzZXVkbyA9IHBzZXVkb3NbaV0gPSBPYmplY3QuY3JlYXRlKHh0YWcucHNldWRvc1tuYW1lXSk7XG4gICAgICAgICAgcHNldWRvLmtleSA9IGtleTtcbiAgICAgICAgICBwc2V1ZG8ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgcHNldWRvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgcHNldWRvWydhcmd1bWVudHMnXSA9ICh2YWx1ZSB8fCAnJykuc3BsaXQoJywnKTtcbiAgICAgICAgICBwc2V1ZG8uYWN0aW9uID0gcHNldWRvLmFjdGlvbiB8fCB0cnVlb3A7XG4gICAgICAgICAgcHNldWRvLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBwc2V1ZG8ubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgICBsaXN0ZW5lciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gcHNldWRvLmFjdGlvbi5hcHBseSh0aGlzLCBbcHNldWRvXS5jb25jYXQodG9BcnJheShhcmd1bWVudHMpKSk7XG4gICAgICAgICAgICBpZiAob3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gZmFsc2UpIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSBwc2V1ZG8ubGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHBzZXVkby5saXN0ZW5lciA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh0YXJnZXQgJiYgcHNldWRvLm9uQWRkKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lKSBwc2V1ZG8ub25BZGQuY2FsbCh0YXJnZXQsIHBzZXVkbyk7XG4gICAgICAgICAgICBlbHNlIHRhcmdldC5wdXNoKHBzZXVkbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHogaW4gcHNldWRvcykge1xuICAgICAgICBpZiAocHNldWRvc1t6XS5vbkNvbXBpbGVkKSBsaXN0ZW5lciA9IHBzZXVkb3Nbel0ub25Db21waWxlZChsaXN0ZW5lciwgcHNldWRvc1t6XSkgfHwgbGlzdGVuZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgfSxcblxuICAgIHJlbW92ZVBzZXVkb3M6IGZ1bmN0aW9uKHRhcmdldCwgcHNldWRvcyl7XG4gICAgICBwc2V1ZG9zLmZvckVhY2goZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgaWYgKG9iai5vblJlbW92ZSkgb2JqLm9uUmVtb3ZlLmNhbGwodGFyZ2V0LCBvYmopO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAvKioqIEV2ZW50cyAqKiovXG5cbiAgICBwYXJzZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBmbikge1xuICAgICAgdmFyIHBzZXVkb3MgPSB0eXBlLnNwbGl0KCc6JyksXG4gICAgICAgICAga2V5ID0gcHNldWRvcy5zaGlmdCgpLFxuICAgICAgICAgIGN1c3RvbSA9IHh0YWcuY3VzdG9tRXZlbnRzW2tleV0sXG4gICAgICAgICAgZXZlbnQgPSB4dGFnLm1lcmdlKHtcbiAgICAgICAgICAgIHR5cGU6IGtleSxcbiAgICAgICAgICAgIHN0YWNrOiBub29wLFxuICAgICAgICAgICAgY29uZGl0aW9uOiB0cnVlb3AsXG4gICAgICAgICAgICBhdHRhY2g6IFtdLFxuICAgICAgICAgICAgX2F0dGFjaDogW10sXG4gICAgICAgICAgICBwc2V1ZG9zOiAnJyxcbiAgICAgICAgICAgIF9wc2V1ZG9zOiBbXSxcbiAgICAgICAgICAgIG9uQWRkOiBub29wLFxuICAgICAgICAgICAgb25SZW1vdmU6IG5vb3BcbiAgICAgICAgICB9LCBjdXN0b20gfHwge30pO1xuICAgICAgZXZlbnQuYXR0YWNoID0gdG9BcnJheShldmVudC5iYXNlIHx8IGV2ZW50LmF0dGFjaCk7XG4gICAgICBldmVudC5jaGFpbiA9IGtleSArIChldmVudC5wc2V1ZG9zLmxlbmd0aCA/ICc6JyArIGV2ZW50LnBzZXVkb3MgOiAnJykgKyAocHNldWRvcy5sZW5ndGggPyAnOicgKyBwc2V1ZG9zLmpvaW4oJzonKSA6ICcnKTtcbiAgICAgIHZhciBjb25kaXRpb24gPSBldmVudC5jb25kaXRpb247XG4gICAgICBldmVudC5jb25kaXRpb24gPSBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIHQgPSBlLnRvdWNoZXMsIHR0ID0gZS50YXJnZXRUb3VjaGVzO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgdmFyIHN0YWNrID0geHRhZy5hcHBseVBzZXVkb3MoZXZlbnQuY2hhaW4sIGZuLCBldmVudC5fcHNldWRvcywgZXZlbnQpO1xuICAgICAgZXZlbnQuc3RhY2sgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0IHx8IHRoaXM7XG4gICAgICAgIHZhciB0ID0gZS50b3VjaGVzLCB0dCA9IGUudGFyZ2V0VG91Y2hlcztcbiAgICAgICAgdmFyIGRldGFpbCA9IGUuZGV0YWlsIHx8IHt9O1xuICAgICAgICBpZiAoIWRldGFpbC5fX3N0YWNrX18pIHJldHVybiBzdGFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBlbHNlIGlmIChkZXRhaWwuX19zdGFja19fID09IHN0YWNrKSB7XG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBldmVudC5saXN0ZW5lciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIG91dHB1dCA9IGV2ZW50LmNvbmRpdGlvbi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChbZXZlbnRdKSk7XG4gICAgICAgIGlmICghb3V0cHV0KSByZXR1cm4gb3V0cHV0O1xuICAgICAgICAvLyBUaGUgc2Vjb25kIGNvbmRpdGlvbiBpbiB0aGlzIElGIGlzIHRvIGFkZHJlc3MgdGhlIGZvbGxvd2luZyBCbGluayByZWdyZXNzaW9uOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzY3NTM3XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIHdoZW4gYWZmZWN0ZWQgYnJvd3NlciBidWlsZHMgd2l0aCB0aGlzIHJlZ3Jlc3Npb24gZmFsbCBiZWxvdyA1JSBtYXJrZXRzaGFyZVxuICAgICAgICBpZiAoZS50eXBlICE9IGtleSAmJiAoZS5iYXNlRXZlbnQgJiYgZS50eXBlICE9IGUuYmFzZUV2ZW50LnR5cGUpKSB7XG4gICAgICAgICAgeHRhZy5maXJlRXZlbnQoZS50YXJnZXQsIGtleSwge1xuICAgICAgICAgICAgYmFzZUV2ZW50OiBlLFxuICAgICAgICAgICAgZGV0YWlsOiBvdXRwdXQgIT09IHRydWUgJiYgKG91dHB1dC5fX3N0YWNrX18gPSBzdGFjaykgPyBvdXRwdXQgOiB7IF9fc3RhY2tfXzogc3RhY2sgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgcmV0dXJuIGV2ZW50LnN0YWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIGV2ZW50LmF0dGFjaC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZXZlbnQuX2F0dGFjaC5wdXNoKHh0YWcucGFyc2VFdmVudChuYW1lLCBldmVudC5saXN0ZW5lcikpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY3VzdG9tICYmIGN1c3RvbS5vYnNlcnZlICYmICFjdXN0b20uX19vYnNlcnZpbmdfXykge1xuICAgICAgICBjdXN0b20ub2JzZXJ2ZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gZXZlbnQuY29uZGl0aW9uLmFwcGx5KHRoaXMsIHRvQXJyYXkoYXJndW1lbnRzKS5jb25jYXQoW2N1c3RvbV0pKTtcbiAgICAgICAgICBpZiAoIW91dHB1dCkgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICB4dGFnLmZpcmVFdmVudChlLnRhcmdldCwga2V5LCB7XG4gICAgICAgICAgICBiYXNlRXZlbnQ6IGUsXG4gICAgICAgICAgICBkZXRhaWw6IG91dHB1dCAhPT0gdHJ1ZSA/IG91dHB1dCA6IHt9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIHogaW4gY3VzdG9tLm9ic2VydmUpIHh0YWcuYWRkRXZlbnQoY3VzdG9tLm9ic2VydmVbel0gfHwgZG9jdW1lbnQsIHosIGN1c3RvbS5vYnNlcnZlciwgdHJ1ZSk7XG4gICAgICAgIGN1c3RvbS5fX29ic2VydmluZ19fID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuXG4gICAgYWRkRXZlbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlLCBmbiwgY2FwdHVyZSkge1xuICAgICAgdmFyIGV2ZW50ID0gdHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyB4dGFnLnBhcnNlRXZlbnQodHlwZSwgZm4pIDogZm47XG4gICAgICBldmVudC5fcHNldWRvcy5mb3JFYWNoKGZ1bmN0aW9uKG9iail7XG4gICAgICAgIG9iai5vbkFkZC5jYWxsKGVsZW1lbnQsIG9iaik7XG4gICAgICB9KTtcbiAgICAgIGV2ZW50Ll9hdHRhY2guZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgeHRhZy5hZGRFdmVudChlbGVtZW50LCBvYmoudHlwZSwgb2JqKTtcbiAgICAgIH0pO1xuICAgICAgZXZlbnQub25BZGQuY2FsbChlbGVtZW50LCBldmVudCwgZXZlbnQubGlzdGVuZXIpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGV2ZW50LnN0YWNrLCBjYXB0dXJlIHx8IHh0YWcuY2FwdHVyZUV2ZW50cy5pbmRleE9mKGV2ZW50LnR5cGUpID4gLTEpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH0sXG5cbiAgICBhZGRFdmVudHM6IGZ1bmN0aW9uIChlbGVtZW50LCBvYmopIHtcbiAgICAgIHZhciBldmVudHMgPSB7fTtcbiAgICAgIGZvciAodmFyIHogaW4gb2JqKSB7XG4gICAgICAgIGV2ZW50c1t6XSA9IHh0YWcuYWRkRXZlbnQoZWxlbWVudCwgeiwgb2JqW3pdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudHM7XG4gICAgfSxcblxuICAgIHJlbW92ZUV2ZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSwgZXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnQgfHwgdHlwZTtcbiAgICAgIGV2ZW50Lm9uUmVtb3ZlLmNhbGwoZWxlbWVudCwgZXZlbnQsIGV2ZW50Lmxpc3RlbmVyKTtcbiAgICAgIHh0YWcucmVtb3ZlUHNldWRvcyhlbGVtZW50LCBldmVudC5fcHNldWRvcyk7XG4gICAgICBldmVudC5fYXR0YWNoLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHh0YWcucmVtb3ZlRXZlbnQoZWxlbWVudCwgb2JqKTtcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGV2ZW50LnN0YWNrKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRXZlbnRzOiBmdW5jdGlvbihlbGVtZW50LCBvYmope1xuICAgICAgZm9yICh2YXIgeiBpbiBvYmopIHh0YWcucmVtb3ZlRXZlbnQoZWxlbWVudCwgb2JqW3pdKTtcbiAgICB9LFxuXG4gICAgZmlyZUV2ZW50OiBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBvcHRpb25zKXtcbiAgICAgIHZhciBldmVudCA9IGRvYy5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KHR5cGUsXG4gICAgICAgIG9wdGlvbnMuYnViYmxlcyAhPT0gZmFsc2UsXG4gICAgICAgIG9wdGlvbnMuY2FuY2VsYWJsZSAhPT0gZmFsc2UsXG4gICAgICAgIG9wdGlvbnMuZGV0YWlsXG4gICAgICApO1xuICAgICAgaWYgKG9wdGlvbnMuYmFzZUV2ZW50KSBpbmhlcml0RXZlbnQoZXZlbnQsIG9wdGlvbnMuYmFzZUV2ZW50KTtcbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICBMaXN0ZW5zIGZvciBpbnNlcnRpb24gb3IgcmVtb3ZhbCBvZiBub2RlcyBmcm9tIGEgZ2l2ZW4gZWxlbWVudCB1c2luZ1xuICAgICAgTXV0YXRpb24gT2JzZXJ2ZXJzLCBvciBNdXRhdGlvbiBFdmVudHMgYXMgYSBmYWxsYmFja1xuICAgICovXG4gICAgYWRkT2JzZXJ2ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGZuKXtcbiAgICAgIGlmICghZWxlbWVudC5fcmVjb3Jkcykge1xuICAgICAgICBlbGVtZW50Ll9yZWNvcmRzID0geyBpbnNlcnRlZDogW10sIHJlbW92ZWQ6IFtdIH07XG4gICAgICAgIGlmIChtdXRhdGlvbil7XG4gICAgICAgICAgZWxlbWVudC5fb2JzZXJ2ZXIgPSBuZXcgbXV0YXRpb24oZnVuY3Rpb24obXV0YXRpb25zKSB7XG4gICAgICAgICAgICBwYXJzZU11dGF0aW9ucyhlbGVtZW50LCBtdXRhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsZW1lbnQuX29ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6ICF0cnVlLFxuICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFsnSW5zZXJ0ZWQnLCAnUmVtb3ZlZCddLmZvckVhY2goZnVuY3Rpb24odHlwZSl7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlJyArIHR5cGUsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgIGV2ZW50Ll9tdXRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBlbGVtZW50Ll9yZWNvcmRzW3R5cGUudG9Mb3dlckNhc2UoKV0uZm9yRWFjaChmdW5jdGlvbihmbil7XG4gICAgICAgICAgICAgIGZuKGV2ZW50LnRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Ll9yZWNvcmRzW3R5cGVdLmluZGV4T2YoZm4pID09IC0xKSBlbGVtZW50Ll9yZWNvcmRzW3R5cGVdLnB1c2goZm4pO1xuICAgIH0sXG5cbiAgICByZW1vdmVPYnNlcnZlcjogZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgZm4pe1xuICAgICAgdmFyIG9iaiA9IGVsZW1lbnQuX3JlY29yZHM7XG4gICAgICBpZiAob2JqICYmIGZuKXtcbiAgICAgICAgb2JqW3R5cGVdLnNwbGljZShvYmpbdHlwZV0uaW5kZXhPZihmbiksIDEpO1xuICAgICAgfVxuICAgICAgZWxzZXtcbiAgICAgICAgb2JqW3R5cGVdID0gW107XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbi8qKiogVW5pdmVyc2FsIFRvdWNoICoqKi9cblxudmFyIHRvdWNoaW5nID0gZmFsc2UsXG4gICAgdG91Y2hUYXJnZXQgPSBudWxsO1xuXG5kb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oZSl7XG4gIHRvdWNoaW5nID0gdHJ1ZTtcbiAgdG91Y2hUYXJnZXQgPSBlLnRhcmdldDtcbn0sIHRydWUpO1xuXG5kb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKCl7XG4gIHRvdWNoaW5nID0gZmFsc2U7XG4gIHRvdWNoVGFyZ2V0ID0gbnVsbDtcbn0sIHRydWUpO1xuXG5kb2MuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIGZ1bmN0aW9uKCl7XG4gIHRvdWNoaW5nID0gZmFsc2U7XG4gIHRvdWNoVGFyZ2V0ID0gbnVsbDtcbn0sIHRydWUpO1xuXG52YXIgVUlFdmVudFByb3RvID0ge1xuICB0b3VjaGVzOiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9fdG91Y2hlc19fIHx8XG4gICAgICAgICh0aGlzLmlkZW50aWZpZXIgPSAwKSB8fFxuICAgICAgICAodGhpcy5fX3RvdWNoZXNfXyA9IHRvdWNoaW5nID8gW3RoaXNdIDogW10pO1xuICAgIH1cbiAgfSxcbiAgdGFyZ2V0VG91Y2hlczoge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fX3RhcmdldFRvdWNoZXNfXyB8fCAodGhpcy5fX3RhcmdldFRvdWNoZXNfXyA9XG4gICAgICAgICh0b3VjaGluZyAmJiB0aGlzLmN1cnJlbnRUYXJnZXQgJiZcbiAgICAgICAgKHRoaXMuY3VycmVudFRhcmdldCA9PSB0b3VjaFRhcmdldCB8fFxuICAgICAgICAodGhpcy5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zICYmIHRoaXMuY3VycmVudFRhcmdldC5jb250YWlucyh0b3VjaFRhcmdldCkpKSkgPyAodGhpcy5pZGVudGlmaWVyID0gMCkgfHwgW3RoaXNdIDogW10pO1xuICAgIH1cbiAgfSxcbiAgY2hhbmdlZFRvdWNoZXM6IHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX19jaGFuZ2VkVG91Y2hlc19fIHx8ICh0aGlzLmlkZW50aWZpZXIgPSAwKSB8fCAodGhpcy5fX2NoYW5nZWRUb3VjaGVzX18gPSBbdGhpc10pO1xuICAgIH1cbiAgfVxufTtcblxuZm9yICh6IGluIFVJRXZlbnRQcm90byl7XG4gIFVJRXZlbnQucHJvdG90eXBlW3pdID0gVUlFdmVudFByb3RvW3pdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVUlFdmVudC5wcm90b3R5cGUsIHosIFVJRXZlbnRQcm90b1t6XSk7XG59XG5cblxuLyoqKiBDdXN0b20gRXZlbnQgRGVmaW5pdGlvbnMgKioqL1xuXG4gIGZ1bmN0aW9uIGFkZFRhcChlbCwgdGFwLCBlKXtcbiAgICBpZiAoIWVsLl9fdGFwX18pIHtcbiAgICAgIGVsLl9fdGFwX18gPSB7IGNsaWNrOiBlLnR5cGUgPT0gJ21vdXNlZG93bicgfTtcbiAgICAgIGlmIChlbC5fX3RhcF9fLmNsaWNrKSBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRhcC5vYnNlcnZlcik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWwuX190YXBfXy5zY3JvbGwgPSB0YXAub2JzZXJ2ZXIuYmluZChlbCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBlbC5fX3RhcF9fLnNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRhcC5vYnNlcnZlcik7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGFwLm9ic2VydmVyKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0YXAub2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWVsLl9fdGFwX18uY2xpY2spIHtcbiAgICAgIGVsLl9fdGFwX18ueCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgIGVsLl9fdGFwX18ueSA9IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVUYXAoZWwsIHRhcCl7XG4gICAgaWYgKGVsLl9fdGFwX18pIHtcbiAgICAgIGlmIChlbC5fX3RhcF9fLmNsaWNrKSBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRhcC5vYnNlcnZlcik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGVsLl9fdGFwX18uc2Nyb2xsLCB0cnVlKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGFwLm9ic2VydmVyKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0YXAub2JzZXJ2ZXIpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRhcC5vYnNlcnZlcik7XG4gICAgICB9XG4gICAgICBkZWxldGUgZWwuX190YXBfXztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1RhcFBvc2l0aW9uKGVsLCB0YXAsIGUpe1xuICAgIHZhciB0b3VjaCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXG4gICAgICAgIHRvbCA9IHRhcC5nZXN0dXJlLnRvbGVyYW5jZTtcbiAgICBpZiAoXG4gICAgICB0b3VjaC5wYWdlWCA8IGVsLl9fdGFwX18ueCArIHRvbCAmJlxuICAgICAgdG91Y2gucGFnZVggPiBlbC5fX3RhcF9fLnggLSB0b2wgJiZcbiAgICAgIHRvdWNoLnBhZ2VZIDwgZWwuX190YXBfXy55ICsgdG9sICYmXG4gICAgICB0b3VjaC5wYWdlWSA+IGVsLl9fdGFwX18ueSAtIHRvbFxuICAgICkgcmV0dXJuIHRydWU7XG4gIH1cblxuICB4dGFnLmN1c3RvbUV2ZW50cy50YXAgPSB7XG4gICAgb2JzZXJ2ZToge1xuICAgICAgbW91c2Vkb3duOiBkb2N1bWVudCxcbiAgICAgIHRvdWNoc3RhcnQ6IGRvY3VtZW50XG4gICAgfSxcbiAgICBnZXN0dXJlOiB7XG4gICAgICB0b2xlcmFuY2U6IDhcbiAgICB9LFxuICAgIGNvbmRpdGlvbjogZnVuY3Rpb24oZSwgdGFwKXtcbiAgICAgIHZhciBlbCA9IGUudGFyZ2V0O1xuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICAgICAgaWYgKGVsLl9fdGFwX18gJiYgZWwuX190YXBfXy5jbGljaykgcmVtb3ZlVGFwKGVsLCB0YXApO1xuICAgICAgICAgIGFkZFRhcChlbCwgdGFwLCBlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgICAgaWYgKCFlbC5fX3RhcF9fKSBhZGRUYXAoZWwsIHRhcCwgZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzY3JvbGwnOlxuICAgICAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgICAgICAgcmVtb3ZlVGFwKHRoaXMsIHRhcCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgICBjYXNlICd0b3VjaGVuZCc6XG4gICAgICAgICAgaWYgKHRoaXMuX190YXBfXyAmJiAhY2hlY2tUYXBQb3NpdGlvbih0aGlzLCB0YXAsIGUpKSB7XG4gICAgICAgICAgICByZW1vdmVUYXAodGhpcywgdGFwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGUudHlwZSA9PSAndG91Y2hlbmQnIHx8IG51bGw7XG4gICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICByZW1vdmVUYXAodGhpcywgdGFwKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2luLnh0YWcgPSB4dGFnO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZSh4dGFnKTtcblxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignV2ViQ29tcG9uZW50c1JlYWR5JywgZnVuY3Rpb24oKXtcbiAgICB4dGFnLmZpcmVFdmVudChkb2MuYm9keSwgJ0RPTUNvbXBvbmVudHNMb2FkZWQnKTtcbiAgfSk7XG5cbn0pKCk7IiwiLyogTlByb2dyZXNzLCAoYykgMjAxMywgMjAxNCBSaWNvIFN0YS4gQ3J1eiAtIGh0dHA6Ly9yaWNvc3RhY3J1ei5jb20vbnByb2dyZXNzXG4gKiBAbGljZW5zZSBNSVQgKi9cblxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk5Qcm9ncmVzcyA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgdmFyIE5Qcm9ncmVzcyA9IHt9O1xuXG4gIE5Qcm9ncmVzcy52ZXJzaW9uID0gJzAuMS42JztcblxuICB2YXIgU2V0dGluZ3MgPSBOUHJvZ3Jlc3Muc2V0dGluZ3MgPSB7XG4gICAgbWluaW11bTogMC4wOCxcbiAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICBwb3NpdGlvblVzaW5nOiAnJyxcbiAgICBzcGVlZDogMjAwLFxuICAgIHRyaWNrbGU6IHRydWUsXG4gICAgdHJpY2tsZVJhdGU6IDAuMDIsXG4gICAgdHJpY2tsZVNwZWVkOiA4MDAsXG4gICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgYmFyU2VsZWN0b3I6ICdbcm9sZT1cImJhclwiXScsXG4gICAgc3Bpbm5lclNlbGVjdG9yOiAnW3JvbGU9XCJzcGlubmVyXCJdJyxcbiAgICBwYXJlbnQ6ICdib2R5JyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJiYXJcIiByb2xlPVwiYmFyXCI+PGRpdiBjbGFzcz1cInBlZ1wiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzcGlubmVyXCIgcm9sZT1cInNwaW5uZXJcIj48ZGl2IGNsYXNzPVwic3Bpbm5lci1pY29uXCI+PC9kaXY+PC9kaXY+J1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuY29uZmlndXJlKHtcbiAgICogICAgICAgbWluaW11bTogMC4xXG4gICAqICAgICB9KTtcbiAgICovXG4gIE5Qcm9ncmVzcy5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIFNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGFzdCBudW1iZXIuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zdGF0dXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9ncmVzcyBiYXIgc3RhdHVzLCB3aGVyZSBgbmAgaXMgYSBudW1iZXIgZnJvbSBgMC4wYCB0byBgMS4wYC5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMC40KTtcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMS4wKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLnNldCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgc3RhcnRlZCA9IE5Qcm9ncmVzcy5pc1N0YXJ0ZWQoKTtcblxuICAgIG4gPSBjbGFtcChuLCBTZXR0aW5ncy5taW5pbXVtLCAxKTtcbiAgICBOUHJvZ3Jlc3Muc3RhdHVzID0gKG4gPT09IDEgPyBudWxsIDogbik7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSBOUHJvZ3Jlc3MucmVuZGVyKCFzdGFydGVkKSxcbiAgICAgICAgYmFyICAgICAgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLmJhclNlbGVjdG9yKSxcbiAgICAgICAgc3BlZWQgICAgPSBTZXR0aW5ncy5zcGVlZCxcbiAgICAgICAgZWFzZSAgICAgPSBTZXR0aW5ncy5lYXNpbmc7XG5cbiAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgcXVldWUoZnVuY3Rpb24obmV4dCkge1xuICAgICAgLy8gU2V0IHBvc2l0aW9uVXNpbmcgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzZXRcbiAgICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAnJykgU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9IE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUygpO1xuXG4gICAgICAvLyBBZGQgdHJhbnNpdGlvblxuICAgICAgY3NzKGJhciwgYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpKTtcblxuICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJywgXG4gICAgICAgICAgb3BhY2l0eTogMSBcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2dyZXNzLm9mZnNldFdpZHRoOyAvKiBSZXBhaW50ICovXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjc3MocHJvZ3Jlc3MsIHsgXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsICcgKyBzcGVlZCArICdtcyBsaW5lYXInLCBcbiAgICAgICAgICAgIG9wYWNpdHk6IDAgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9LCBzcGVlZCk7XG4gICAgICAgIH0sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQobmV4dCwgc3BlZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgTlByb2dyZXNzLmlzU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlb2YgTlByb2dyZXNzLnN0YXR1cyA9PT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDAlLCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGdvIGJhY2t3YXJkcy5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgKlxuICAgKi9cbiAgTlByb2dyZXNzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFOUHJvZ3Jlc3Muc3RhdHVzKSBOUHJvZ3Jlc3Muc2V0KDApO1xuXG4gICAgdmFyIHdvcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBOUHJvZ3Jlc3MudHJpY2tsZSgpO1xuICAgICAgICB3b3JrKCk7XG4gICAgICB9LCBTZXR0aW5ncy50cmlja2xlU3BlZWQpO1xuICAgIH07XG5cbiAgICBpZiAoU2V0dGluZ3MudHJpY2tsZSkgd29yaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlICpzb3J0IG9mKiB0aGUgc2FtZSBhcyBzZXR0aW5nIHRoZSBzdGF0dXMgdG8gMTAwJSwgd2l0aCB0aGVcbiAgICogZGlmZmVyZW5jZSBiZWluZyBgZG9uZSgpYCBtYWtlcyBzb21lIHBsYWNlYm8gZWZmZWN0IG9mIHNvbWUgcmVhbGlzdGljIG1vdGlvbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAqXG4gICAqIElmIGB0cnVlYCBpcyBwYXNzZWQsIGl0IHdpbGwgc2hvdyB0aGUgcHJvZ3Jlc3MgYmFyIGV2ZW4gaWYgaXRzIGhpZGRlbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKHRydWUpO1xuICAgKi9cblxuICBOUHJvZ3Jlc3MuZG9uZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSAmJiAhTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gTlByb2dyZXNzLmluYygwLjMgKyAwLjUgKiBNYXRoLnJhbmRvbSgpKS5zZXQoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgYnkgYSByYW5kb20gYW1vdW50LlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaW5jID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIG4gPSBOUHJvZ3Jlc3Muc3RhdHVzO1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhbW91bnQgPSAoMSAtIG4pICogY2xhbXAoTWF0aC5yYW5kb20oKSAqIG4sIDAuMSwgMC45NSk7XG4gICAgICB9XG5cbiAgICAgIG4gPSBjbGFtcChuICsgYW1vdW50LCAwLCAwLjk5NCk7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnNldChuKTtcbiAgICB9XG4gIH07XG5cbiAgTlByb2dyZXNzLnRyaWNrbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTlByb2dyZXNzLmluYyhNYXRoLnJhbmRvbSgpICogU2V0dGluZ3MudHJpY2tsZVJhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYWxsIHN1cHBsaWVkIGpRdWVyeSBwcm9taXNlcyBhbmRcbiAgICogaW5jcmVhc2VzIHRoZSBwcm9ncmVzcyBhcyB0aGUgcHJvbWlzZXMgcmVzb2x2ZS5cbiAgICogXG4gICAqIEBwYXJhbSAkcHJvbWlzZSBqUVVlcnkgUHJvbWlzZVxuICAgKi9cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbml0aWFsID0gMCwgY3VycmVudCA9IDA7XG4gICAgXG4gICAgTlByb2dyZXNzLnByb21pc2UgPSBmdW5jdGlvbigkcHJvbWlzZSkge1xuICAgICAgaWYgKCEkcHJvbWlzZSB8fCAkcHJvbWlzZS5zdGF0ZSgpID09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGN1cnJlbnQgPT0gMCkge1xuICAgICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaW5pdGlhbCsrO1xuICAgICAgY3VycmVudCsrO1xuICAgICAgXG4gICAgICAkcHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnQtLTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gMCkge1xuICAgICAgICAgICAgaW5pdGlhbCA9IDA7XG4gICAgICAgICAgICBOUHJvZ3Jlc3MuZG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTlByb2dyZXNzLnNldCgoaW5pdGlhbCAtIGN1cnJlbnQpIC8gaW5pdGlhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJlbmRlcnMgdGhlIHByb2dyZXNzIGJhciBtYXJrdXAgYmFzZWQgb24gdGhlIGB0ZW1wbGF0ZWBcbiAgICogc2V0dGluZy5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbmRlciA9IGZ1bmN0aW9uKGZyb21TdGFydCkge1xuICAgIGlmIChOUHJvZ3Jlc3MuaXNSZW5kZXJlZCgpKSByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICBcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcm9ncmVzcy5pZCA9ICducHJvZ3Jlc3MnO1xuICAgIHByb2dyZXNzLmlubmVySFRNTCA9IFNldHRpbmdzLnRlbXBsYXRlO1xuXG4gICAgdmFyIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHBlcmMgICAgID0gZnJvbVN0YXJ0ID8gJy0xMDAnIDogdG9CYXJQZXJjKE5Qcm9ncmVzcy5zdGF0dXMgfHwgMCksXG4gICAgICAgIHBhcmVudCAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLFxuICAgICAgICBzcGlubmVyO1xuICAgIFxuICAgIGNzcyhiYXIsIHtcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMCBsaW5lYXInLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIHBlcmMgKyAnJSwwLDApJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFTZXR0aW5ncy5zaG93U3Bpbm5lcikge1xuICAgICAgc3Bpbm5lciA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3Muc3Bpbm5lclNlbGVjdG9yKTtcbiAgICAgIHNwaW5uZXIgJiYgcmVtb3ZlRWxlbWVudChzcGlubmVyKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICE9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGFkZENsYXNzKHBhcmVudCwgJ25wcm9ncmVzcy1jdXN0b20tcGFyZW50Jyk7XG4gICAgfVxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQuIE9wcG9zaXRlIG9mIHJlbmRlcigpLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnBhcmVudCksICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpXG4gICAgdmFyIHByb2dyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuICAgIHByb2dyZXNzICYmIHJlbW92ZUVsZW1lbnQocHJvZ3Jlc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHByb2dyZXNzIGJhciBpcyByZW5kZXJlZC5cbiAgICovXG5cbiAgTlByb2dyZXNzLmlzUmVuZGVyZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISFkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbnByb2dyZXNzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGljaCBwb3NpdGlvbmluZyBDU1MgcnVsZSB0byB1c2UuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNuaWZmIG9uIGRvY3VtZW50LmJvZHkuc3R5bGVcbiAgICB2YXIgYm9keVN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcblxuICAgIC8vIFNuaWZmIHByZWZpeGVzXG4gICAgdmFyIHZlbmRvclByZWZpeCA9ICgnV2Via2l0VHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ1dlYmtpdCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAoJ01velRyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdNb3onIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdtc1RyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdtcycgOlxuICAgICAgICAgICAgICAgICAgICAgICAoJ09UcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnTycgOiAnJztcblxuICAgIGlmICh2ZW5kb3JQcmVmaXggKyAnUGVyc3BlY3RpdmUnIGluIGJvZHlTdHlsZSkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXJzIHdpdGggM0Qgc3VwcG9ydCwgZS5nLiBXZWJraXQsIElFMTBcbiAgICAgIHJldHVybiAndHJhbnNsYXRlM2QnO1xuICAgIH0gZWxzZSBpZiAodmVuZG9yUHJlZml4ICsgJ1RyYW5zZm9ybScgaW4gYm9keVN0eWxlKSB7XG4gICAgICAvLyBCcm93c2VycyB3aXRob3V0IDNEIHN1cHBvcnQsIGUuZy4gSUU5XG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJyb3dzZXJzIHdpdGhvdXQgdHJhbnNsYXRlKCkgc3VwcG9ydCwgZS5nLiBJRTctOFxuICAgICAgcmV0dXJuICdtYXJnaW4nO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGVscGVyc1xuICAgKi9cblxuICBmdW5jdGlvbiBjbGFtcChuLCBtaW4sIG1heCkge1xuICAgIGlmIChuIDwgbWluKSByZXR1cm4gbWluO1xuICAgIGlmIChuID4gbWF4KSByZXR1cm4gbWF4O1xuICAgIHJldHVybiBuO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgY29udmVydHMgYSBwZXJjZW50YWdlIChgMC4uMWApIHRvIGEgYmFyIHRyYW5zbGF0ZVhcbiAgICogcGVyY2VudGFnZSAoYC0xMDAlLi4wJWApLlxuICAgKi9cblxuICBmdW5jdGlvbiB0b0JhclBlcmMobikge1xuICAgIHJldHVybiAoLTEgKyBuKSAqIDEwMDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgcmV0dXJucyB0aGUgY29ycmVjdCBDU1MgZm9yIGNoYW5naW5nIHRoZSBiYXInc1xuICAgKiBwb3NpdGlvbiBnaXZlbiBhbiBuIHBlcmNlbnRhZ2UsIGFuZCBzcGVlZCBhbmQgZWFzZSBmcm9tIFNldHRpbmdzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJhclBvc2l0aW9uQ1NTKG4sIHNwZWVkLCBlYXNlKSB7XG4gICAgdmFyIGJhckNTUztcblxuICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAndHJhbnNsYXRlM2QnKSB7XG4gICAgICBiYXJDU1MgPSB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcrdG9CYXJQZXJjKG4pKyclLDAsMCknIH07XG4gICAgfSBlbHNlIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAndHJhbnNsYXRlJykge1xuICAgICAgYmFyQ1NTID0geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyt0b0JhclBlcmMobikrJyUsMCknIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhckNTUyA9IHsgJ21hcmdpbi1sZWZ0JzogdG9CYXJQZXJjKG4pKyclJyB9O1xuICAgIH1cblxuICAgIGJhckNTUy50cmFuc2l0aW9uID0gJ2FsbCAnK3NwZWVkKydtcyAnK2Vhc2U7XG5cbiAgICByZXR1cm4gYmFyQ1NTO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgUXVldWVzIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAqL1xuXG4gIHZhciBxdWV1ZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgcGVuZGluZyA9IFtdO1xuICAgIFxuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgZm4gPSBwZW5kaW5nLnNoaWZ0KCk7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgZm4obmV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgICBwZW5kaW5nLnB1c2goZm4pO1xuICAgICAgaWYgKHBlbmRpbmcubGVuZ3RoID09IDEpIG5leHQoKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEFwcGxpZXMgY3NzIHByb3BlcnRpZXMgdG8gYW4gZWxlbWVudCwgc2ltaWxhciB0byB0aGUgalF1ZXJ5IFxuICAgKiBjc3MgbWV0aG9kLlxuICAgKlxuICAgKiBXaGlsZSB0aGlzIGhlbHBlciBkb2VzIGFzc2lzdCB3aXRoIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eSBuYW1lcywgaXQgXG4gICAqIGRvZXMgbm90IHBlcmZvcm0gYW55IG1hbmlwdWxhdGlvbiBvZiB2YWx1ZXMgcHJpb3IgdG8gc2V0dGluZyBzdHlsZXMuXG4gICAqL1xuXG4gIHZhciBjc3MgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNzc1ByZWZpeGVzID0gWyAnV2Via2l0JywgJ08nLCAnTW96JywgJ21zJyBdLFxuICAgICAgICBjc3NQcm9wcyAgICA9IHt9O1xuXG4gICAgZnVuY3Rpb24gY2FtZWxDYXNlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9eLW1zLS8sICdtcy0nKS5yZXBsYWNlKC8tKFtcXGRhLXpdKS9naSwgZnVuY3Rpb24obWF0Y2gsIGxldHRlcikge1xuICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWZW5kb3JQcm9wKG5hbWUpIHtcbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICBpZiAobmFtZSBpbiBzdHlsZSkgcmV0dXJuIG5hbWU7XG5cbiAgICAgIHZhciBpID0gY3NzUHJlZml4ZXMubGVuZ3RoLFxuICAgICAgICAgIGNhcE5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcbiAgICAgICAgICB2ZW5kb3JOYW1lO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2ZW5kb3JOYW1lID0gY3NzUHJlZml4ZXNbaV0gKyBjYXBOYW1lO1xuICAgICAgICBpZiAodmVuZG9yTmFtZSBpbiBzdHlsZSkgcmV0dXJuIHZlbmRvck5hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0eWxlUHJvcChuYW1lKSB7XG4gICAgICBuYW1lID0gY2FtZWxDYXNlKG5hbWUpO1xuICAgICAgcmV0dXJuIGNzc1Byb3BzW25hbWVdIHx8IChjc3NQcm9wc1tuYW1lXSA9IGdldFZlbmRvclByb3AobmFtZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5Q3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm9wID0gZ2V0U3R5bGVQcm9wKHByb3ApO1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBwcm9wLCBcbiAgICAgICAgICB2YWx1ZTtcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDIpIHtcbiAgICAgICAgZm9yIChwcm9wIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnRpZXNbcHJvcF07XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgYXBwbHlDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBseUNzcyhlbGVtZW50LCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgRGV0ZXJtaW5lcyBpZiBhbiBlbGVtZW50IG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzIGNvbnRhaW5zIGEgY2xhc3MgbmFtZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBsaXN0ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgPyBlbGVtZW50IDogY2xhc3NMaXN0KGVsZW1lbnQpO1xuICAgIHJldHVybiBsaXN0LmluZGV4T2YoJyAnICsgbmFtZSArICcgJykgPj0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEFkZHMgYSBjbGFzcyB0byBhbiBlbGVtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIG9sZExpc3QgPSBjbGFzc0xpc3QoZWxlbWVudCksXG4gICAgICAgIG5ld0xpc3QgPSBvbGRMaXN0ICsgbmFtZTtcblxuICAgIGlmIChoYXNDbGFzcyhvbGRMaXN0LCBuYW1lKSkgcmV0dXJuOyBcblxuICAgIC8vIFRyaW0gdGhlIG9wZW5pbmcgc3BhY2UuXG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBuZXdMaXN0LnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFJlbW92ZXMgYSBjbGFzcyBmcm9tIGFuIGVsZW1lbnQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgb2xkTGlzdCA9IGNsYXNzTGlzdChlbGVtZW50KSxcbiAgICAgICAgbmV3TGlzdDtcblxuICAgIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgbmFtZSkpIHJldHVybjtcblxuICAgIC8vIFJlcGxhY2UgdGhlIGNsYXNzIG5hbWUuXG4gICAgbmV3TGlzdCA9IG9sZExpc3QucmVwbGFjZSgnICcgKyBuYW1lICsgJyAnLCAnICcpO1xuXG4gICAgLy8gVHJpbSB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBzcGFjZXMuXG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBuZXdMaXN0LnN1YnN0cmluZygxLCBuZXdMaXN0Lmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgR2V0cyBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIHRoZSBjbGFzcyBuYW1lcyBvbiB0aGUgZWxlbWVudC4gXG4gICAqIFRoZSBsaXN0IGlzIHdyYXBwZWQgd2l0aCBhIHNpbmdsZSBzcGFjZSBvbiBlYWNoIGVuZCB0byBmYWNpbGl0YXRlIGZpbmRpbmcgXG4gICAqIG1hdGNoZXMgd2l0aGluIHRoZSBsaXN0LlxuICAgKi9cblxuICBmdW5jdGlvbiBjbGFzc0xpc3QoZWxlbWVudCkge1xuICAgIHJldHVybiAoJyAnICsgKGVsZW1lbnQuY2xhc3NOYW1lIHx8ICcnKSArICcgJykucmVwbGFjZSgvXFxzKy9naSwgJyAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBET00uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBOUHJvZ3Jlc3M7XG59KTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKTtcbiIsIi8vIExvYWQgbW9kdWxlc1xuXG52YXIgU3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBQYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcblxuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG52YXIgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc3RyaW5naWZ5OiBTdHJpbmdpZnksXG4gICAgcGFyc2U6IFBhcnNlXG59O1xuIiwiLy8gTG9hZCBtb2R1bGVzXG5cbnZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG52YXIgaW50ZXJuYWxzID0ge1xuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGRlcHRoOiA1LFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwXG59O1xuXG5cbmludGVybmFscy5wYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcblxuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIHZhciBwb3MgPSBwYXJ0LmluZGV4T2YoJ109JykgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBwYXJ0LmluZGV4T2YoJ109JykgKyAxO1xuXG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBvYmpbVXRpbHMuZGVjb2RlKHBhcnQpXSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleSA9IFV0aWxzLmRlY29kZShwYXJ0LnNsaWNlKDAsIHBvcykpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IFV0aWxzLmRlY29kZShwYXJ0LnNsaWNlKHBvcyArIDEpKTtcblxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IFtdLmNvbmNhdChvYmpba2V5XSkuY29uY2F0KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMucGFyc2VPYmplY3QgPSBmdW5jdGlvbiAoY2hhaW4sIHZhbCwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFjaGFpbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGNoYWluLnNoaWZ0KCk7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgaWYgKHJvb3QgPT09ICdbXScpIHtcbiAgICAgICAgb2JqID0gW107XG4gICAgICAgIG9iaiA9IG9iai5jb25jYXQoaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjbGVhblJvb3QgPSByb290WzBdID09PSAnWycgJiYgcm9vdFtyb290Lmxlbmd0aCAtIDFdID09PSAnXScgPyByb290LnNsaWNlKDEsIHJvb3QubGVuZ3RoIC0gMSkgOiByb290O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgdmFyIGluZGV4U3RyaW5nID0gJycgKyBpbmRleDtcbiAgICAgICAgaWYgKCFpc05hTihpbmRleCkgJiZcbiAgICAgICAgICAgIHJvb3QgIT09IGNsZWFuUm9vdCAmJlxuICAgICAgICAgICAgaW5kZXhTdHJpbmcgPT09IGNsZWFuUm9vdCAmJlxuICAgICAgICAgICAgaW5kZXggPj0gMCAmJlxuICAgICAgICAgICAgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KSB7XG5cbiAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgb2JqW2luZGV4XSA9IGludGVybmFscy5wYXJzZU9iamVjdChjaGFpbiwgdmFsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLnBhcnNlS2V5cyA9IGZ1bmN0aW9uIChrZXksIHZhbCwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRoZSByZWdleCBjaHVua3NcblxuICAgIHZhciBwYXJlbnQgPSAvXihbXlxcW1xcXV0qKS87XG4gICAgdmFyIGNoaWxkID0gLyhcXFtbXlxcW1xcXV0qXFxdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gcGFyZW50LmV4ZWMoa2V5KTtcblxuICAgIC8vIERvbid0IGFsbG93IHRoZW0gdG8gb3ZlcndyaXRlIG9iamVjdCBwcm90b3R5cGUgcHJvcGVydGllc1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoc2VnbWVudFsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFN0YXNoIHRoZSBwYXJlbnQgaWYgaXQgZXhpc3RzXG5cbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGlmIChzZWdtZW50WzFdKSB7XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcblxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XG5cbiAgICAgICAgKytpO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoc2VnbWVudFsxXS5yZXBsYWNlKC9cXFt8XFxdL2csICcnKSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlJ3MgYSByZW1haW5kZXIsIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMucGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fFxuICAgICAgICBzdHIgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IFV0aWxzLmlzUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyKSA/IG9wdGlvbnMuZGVsaW1pdGVyIDogaW50ZXJuYWxzLmRlbGltaXRlcjtcbiAgICBvcHRpb25zLmRlcHRoID0gdHlwZW9mIG9wdGlvbnMuZGVwdGggPT09ICdudW1iZXInID8gb3B0aW9ucy5kZXB0aCA6IGludGVybmFscy5kZXB0aDtcbiAgICBvcHRpb25zLmFycmF5TGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuYXJyYXlMaW1pdCA6IGludGVybmFscy5hcnJheUxpbWl0O1xuICAgIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRpb25zLnBhcmFtZXRlckxpbWl0IDogaW50ZXJuYWxzLnBhcmFtZXRlckxpbWl0O1xuXG4gICAgdmFyIHRlbXBPYmogPSB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IGludGVybmFscy5wYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gaW50ZXJuYWxzLnBhcnNlS2V5cyhrZXksIHRlbXBPYmpba2V5XSwgb3B0aW9ucyk7XG4gICAgICAgIG9iaiA9IFV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVXRpbHMuY29tcGFjdChvYmopO1xufTtcbiIsIi8vIExvYWQgbW9kdWxlc1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHtcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBhcnJheVByZWZpeEdlbmVyYXRvcnM6IHtcbiAgICAgICAgYnJhY2tldHM6IGZ1bmN0aW9uIChwcmVmaXgsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgICAgIH0sXG4gICAgICAgIGluZGljZXM6IGZ1bmN0aW9uIChwcmVmaXgsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcbiAgICAgICAgfSxcbiAgICAgICAgcmVwZWF0OiBmdW5jdGlvbiAocHJlZml4LCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBwcmVmaXgsIGdlbmVyYXRlQXJyYXlQcmVmaXgpIHtcblxuICAgIGlmIChVdGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIG9iaiA9IG9iai50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdib29sZWFuJykge1xuXG4gICAgICAgIHJldHVybiBbZW5jb2RlVVJJQ29tcG9uZW50KHByZWZpeCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgdmFyIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IG9iaktleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChpbnRlcm5hbHMuc3RyaW5naWZ5KG9ialtrZXldLCBnZW5lcmF0ZUFycmF5UHJlZml4KHByZWZpeCwga2V5KSwgZ2VuZXJhdGVBcnJheVByZWZpeCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChpbnRlcm5hbHMuc3RyaW5naWZ5KG9ialtrZXldLCBwcmVmaXggKyAnWycgKyBrZXkgKyAnXScsIGdlbmVyYXRlQXJyYXlQcmVmaXgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGRlbGltaXRlciA9IHR5cGVvZiBvcHRpb25zLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBpbnRlcm5hbHMuZGVsaW1pdGVyIDogb3B0aW9ucy5kZWxpbWl0ZXI7XG5cbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XG4gICAgICAgIG9iaiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdGlvbnMuYXJyYXlGb3JtYXQgaW4gaW50ZXJuYWxzLmFycmF5UHJlZml4R2VuZXJhdG9ycykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdGlvbnMuYXJyYXlGb3JtYXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdpbmRpY2VzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcnJheUZvcm1hdCA9ICdpbmRpY2VzJztcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGludGVybmFscy5hcnJheVByZWZpeEdlbmVyYXRvcnNbYXJyYXlGb3JtYXRdO1xuXG4gICAgdmFyIG9iaktleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IG9iaktleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcbiAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGludGVybmFscy5zdHJpbmdpZnkob2JqW2tleV0sIGtleSwgZ2VuZXJhdGVBcnJheVByZWZpeCkpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzLmpvaW4oZGVsaW1pdGVyKTtcbn07XG4iLCIvLyBMb2FkIG1vZHVsZXNcblxuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG52YXIgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5hcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGFyZ2V0ID0gW3RhcmdldF0uY29uY2F0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG5cbiAgICAgICAgdGFyZ2V0ID0gZXhwb3J0cy5hcnJheVRvT2JqZWN0KHRhcmdldCk7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAodmFyIGsgPSAwLCBrbCA9IGtleXMubGVuZ3RoOyBrIDwga2w7ICsraykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1trXTtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gZXhwb3J0cy5tZXJnZSh0YXJnZXRba2V5XSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5jb21wYWN0ID0gZnVuY3Rpb24gKG9iaiwgcmVmcykge1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XG4gICAgICAgIG9iaiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmVmcyA9IHJlZnMgfHwgW107XG4gICAgdmFyIGxvb2t1cCA9IHJlZnMuaW5kZXhPZihvYmopO1xuICAgIGlmIChsb29rdXAgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiByZWZzW2xvb2t1cF07XG4gICAgfVxuXG4gICAgcmVmcy5wdXNoKG9iaik7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBvYmoubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wYWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAoaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBvYmpba2V5XSA9IGV4cG9ydHMuY29tcGFjdChvYmpba2V5XSwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmXG4gICAgICAgIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJlxuICAgICAgICBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlcicpO1xudmFyIHJlZHVjZSA9IHJlcXVpcmUoJ3JlZHVjZScpO1xuXG4vKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG5cbnZhciByb290ID0gJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIHdpbmRvd1xuICA/IHRoaXNcbiAgOiB3aW5kb3c7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBUT0RPOiBmdXR1cmUgcHJvb2YsIG1vdmUgdG8gY29tcG9lbnQgbGFuZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0hvc3Qob2JqKSB7XG4gIHZhciBzdHIgPSB7fS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IEJsb2JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEZvcm1EYXRhXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5mdW5jdGlvbiBnZXRYSFIoKSB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XG4gICAgJiYgKCdmaWxlOicgIT0gcm9vdC5sb2NhdGlvbi5wcm90b2NvbCB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAobnVsbCAhPSBvYmpba2V5XSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbiAvKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYXJ0cztcbiAgdmFyIHBhaXI7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBhcnRzID0gcGFpci5zcGxpdCgnPScpO1xuICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFydHNbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1sxXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAnYXBwbGljYXRpb24veG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbiByZXF1ZXN0LnNlcmlhbGl6ZSA9IHtcbiAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG4gfTtcblxuIC8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgZmllbGRzID0ge307XG4gIHZhciBpbmRleDtcbiAgdmFyIGxpbmU7XG4gIHZhciBmaWVsZDtcbiAgdmFyIHZhbDtcblxuICBsaW5lcy5wb3AoKTsgLy8gdHJhaWxpbmcgQ1JMRlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0eXBlKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcmFtcyhzdHIpe1xuICByZXR1cm4gcmVkdWNlKHN0ci5zcGxpdCgvICo7ICovKSwgZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKVxuICAgICAgLCBrZXkgPSBwYXJ0cy5zaGlmdCgpXG4gICAgICAsIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZWAgd2l0aCB0aGUgZ2l2ZW4gYHhocmAuXG4gKlxuICogIC0gc2V0IGZsYWdzICgub2ssIC5lcnJvciwgZXRjKVxuICogIC0gcGFyc2UgaGVhZGVyXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcbiAqXG4gKiAgICAgIHJlcXVlc3QgPSBzdXBlcmFnZW50O1xuICpcbiAqICBXZSBjYW4gdXNlIHRoZSBwcm9taXNlLWxpa2UgQVBJLCBvciBwYXNzIGNhbGxiYWNrczpcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJywgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5zZW5kKClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnBvc3QoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIE9yIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbmdsZSBjYWxsIGZvciBzaW1wbGUgY2FzZXM6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2UocmVxLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIHRoaXMudGV4dCA9IHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyBcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHQgXG4gICAgIDogbnVsbDtcbiAgdGhpcy5zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcbiAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgID8gdGhpcy5wYXJzZUJvZHkodGhpcy50ZXh0KVxuICAgIDogbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnNldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xuICAvLyBjb250ZW50LXR5cGVcbiAgdmFyIGN0ID0gdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICB0aGlzLnR5cGUgPSB0eXBlKGN0KTtcblxuICAvLyBwYXJhbXNcbiAgdmFyIG9iaiA9IHBhcmFtcyhjdCk7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHRoaXNba2V5XSA9IG9ialtrZXldO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpe1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgc3RyLmxlbmd0aFxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnNldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgLy8gYmFzaWNzXG4gIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgID8gdGhpcy50b0Vycm9yKClcbiAgICA6IGZhbHNlO1xuXG4gIC8vIHN1Z2FyXG4gIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXMgfHwgMTIyMyA9PSBzdGF0dXM7XG4gIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9O1xuICB0aGlzLl9oZWFkZXIgPSB7fTtcbiAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICB2YXIgZXJyID0gbnVsbDtcbiAgICB2YXIgcmVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICByZXMgPSBuZXcgUmVzcG9uc2Uoc2VsZik7IFxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgfVxuXG4gICAgc2VsZi5jYWxsYmFjayhlcnIsIHJlcyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24oZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFNldCB0aW1lb3V0IHRvIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKG1zKXtcbiAgdGhpcy5fdGltZW91dCA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5fdGltZW91dCA9IDA7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuO1xuICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhoci5hYm9ydCgpO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEF1dGhvcml6YXRpb24gZmllbGQgdmFsdWUgd2l0aCBgdXNlcmAgYW5kIGBwYXNzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3NcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcyl7XG4gIHZhciBzdHIgPSBidG9hKHVzZXIgKyAnOicgKyBwYXNzKTtcbiAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIHN0cik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4qXG4qIEV4YW1wbGVzOlxuKlxuKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4qIEBhcGkgcHVibGljXG4qL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAgZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiXG4gKiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB0aGlzLl9mb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB0aGlzLl9mb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBmaWxlbmFtZWAuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBmaWxlbmFtZSl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHRoaXMuX2Zvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIHRoaXMuX2Zvcm1EYXRhLmFwcGVuZChmaWVsZCwgZmlsZSwgZmlsZW5hbWUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAsIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gcXVlcnlzdHJpbmdcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvc2VhcmNoJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtdWx0aXBsZSBkYXRhIFwid3JpdGVzXCJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvc2VhcmNoJylcbiAqICAgICAgICAgLnNlbmQoeyBzZWFyY2g6ICdxdWVyeScgfSlcbiAqICAgICAgICAgLnNlbmQoeyByYW5nZTogJzEuLjUnIH0pXG4gKiAgICAgICAgIC5zZW5kKHsgb3JkZXI6ICdkZXNjJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAgKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAgKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBvYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldEhlYWRlcignQ29udGVudC1UeXBlJyk7XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKG9iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IHRoaXMuX2RhdGEgKyAnJicgKyBkYXRhXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFvYmopIHJldHVybiB0aGlzO1xuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICBpZiAoMiA9PSBmbi5sZW5ndGgpIHJldHVybiBmbihlcnIsIHJlcyk7XG4gIGlmIChlcnIpIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgZm4ocmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ09yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnRpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcigndGltZW91dCBvZiAnICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhociA9IHRoaXMueGhyID0gZ2V0WEhSKCk7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICB2YXIgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIGlmICgwID09IHhoci5zdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLmFib3J0ZWQpIHJldHVybiBzZWxmLnRpbWVvdXRFcnJvcigpO1xuICAgICAgcmV0dXJuIHNlbGYuY3Jvc3NEb21haW5FcnJvcigpO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIGlmICh4aHIudXBsb2FkKSB7XG4gICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZSl7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgJiYgIXRoaXMuX3RpbWVyKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICAvLyBxdWVyeXN0cmluZ1xuICBpZiAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0KHF1ZXJ5KTtcbiAgICB0aGlzLnVybCArPSB+dGhpcy51cmwuaW5kZXhPZignPycpXG4gICAgICA/ICcmJyArIHF1ZXJ5XG4gICAgICA6ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuXG4gIC8vIENPUlNcbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cbiAgLy8gYm9keVxuICBpZiAoJ0dFVCcgIT0gdGhpcy5tZXRob2QgJiYgJ0hFQUQnICE9IHRoaXMubWV0aG9kICYmICdzdHJpbmcnICE9IHR5cGVvZiBkYXRhICYmICFpc0hvc3QoZGF0YSkpIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICB2YXIgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbdGhpcy5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpXTtcbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgLy8gc2VuZCBzdHVmZlxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTtcbiAgeGhyLnNlbmQoZGF0YSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RgLlxuICovXG5cbnJlcXVlc3QuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogSXNzdWUgYSByZXF1ZXN0OlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgIHJlcXVlc3QoJ0dFVCcsICcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXG4gKiAgICByZXF1ZXN0KCcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXG4gKiAgICByZXF1ZXN0KCcvdXNlcnMnLCBjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdXJsIG9yIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH1cblxuICAvLyB1cmwgZmlyc3RcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVxdWVzdChtZXRob2QsIHVybCk7XG59XG5cbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IGRhdGEgb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gZGF0YSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5kZWwgPSBmdW5jdGlvbih1cmwsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBkYXRhIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiXG4vKipcbiAqIFJlZHVjZSBgYXJyYCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtNaXhlZH0gaW5pdGlhbFxuICpcbiAqIFRPRE86IGNvbWJhdGlibGUgZXJyb3IgaGFuZGxpbmc/XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIGZuLCBpbml0aWFsKXsgIFxuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBjdXJyID0gYXJndW1lbnRzLmxlbmd0aCA9PSAzXG4gICAgPyBpbml0aWFsXG4gICAgOiBhcnJbaWR4KytdO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBjdXJyID0gZm4uY2FsbChudWxsLCBjdXJyLCBhcnJbaWR4XSwgKytpZHgsIGFycik7XG4gIH1cbiAgXG4gIHJldHVybiBjdXJyO1xufTsiLCIvLyBTZXJpYWxpemUgMC4yXG4vLyBTb3VyY2U6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZm9ybS1zZXJpYWxpemUvc291cmNlL2Jyb3dzZS90cnVuay9zZXJpYWxpemUtMC4yLmpzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2VyaWFsaXplKGZvcm0pIHtcbu+7vyAgaWYgKCFmb3JtIHx8IGZvcm0ubm9kZU5hbWUgIT09IFwiRk9STVwiKSB7XG7vu78gIO+7vyAgcmV0dXJuO1xu77u/ICB9XG7vu78gIHZhciBpLCBqLCBxID0gW107XG7vu78gIGZvciAoaSA9IGZvcm0uZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpID0gaSAtIDEpIHtcbu+7vyAg77u/ICBpZiAoZm9ybS5lbGVtZW50c1tpXS5uYW1lID09PSBcIlwiKSB7XG7vu78gIO+7vyAg77u/ICBjb250aW51ZTtcbu+7vyAg77u/ICB9XG7vu78gIO+7vyAgc3dpdGNoIChmb3JtLmVsZW1lbnRzW2ldLm5vZGVOYW1lKSB7XG7vu78gIO+7vyAgY2FzZSAnSU5QVVQnOlxu77u/ICDvu78gIO+7vyAgc3dpdGNoIChmb3JtLmVsZW1lbnRzW2ldLnR5cGUpIHtcbu+7vyAg77u/ICDvu78gIGNhc2UgJ3RleHQnOlxu77u/ICDvu78gIO+7vyAgY2FzZSAnaGlkZGVuJzpcbu+7vyAg77u/ICDvu78gIGNhc2UgJ3Bhc3N3b3JkJzpcbu+7vyAg77u/ICDvu78gIGNhc2UgJ2J1dHRvbic6XG7vu78gIO+7vyAg77u/ICBjYXNlICdyZXNldCc6XG7vu78gIO+7vyAg77u/ICBjYXNlICdzdWJtaXQnOlxu77u/ICDvu78gIO+7vyAg77u/ICBxLnB1c2goZm9ybS5lbGVtZW50c1tpXS5uYW1lICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoZm9ybS5lbGVtZW50c1tpXS52YWx1ZSkpO1xu77u/ICDvu78gIO+7vyAg77u/ICBicmVhaztcbu+7vyAg77u/ICDvu78gIGNhc2UgJ2NoZWNrYm94Jzpcbu+7vyAg77u/ICDvu78gIGNhc2UgJ3JhZGlvJzpcbu+7vyAg77u/ICDvu78gIO+7vyAgaWYgKGZvcm0uZWxlbWVudHNbaV0uY2hlY2tlZCkge1xu77u/ICDvu78gIO+7vyAg77u/ICDvu78gIHEucHVzaChmb3JtLmVsZW1lbnRzW2ldLm5hbWUgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChmb3JtLmVsZW1lbnRzW2ldLnZhbHVlKSk7XG7vu78gIO+7vyAg77u/ICDvu78gIH3vu78gIO+7vyAg77u/ICDvu78gIO+7vyAg77u/ICBcbu+7vyAg77u/ICDvu78gIO+7vyAgYnJlYWs7XG7vu78gIO+7vyAg77u/ICBjYXNlICdmaWxlJzpcbu+7vyAg77u/ICDvu78gIO+7vyAgYnJlYWs7XG7vu78gIO+7vyAg77u/ICB9XG7vu78gIO+7vyAg77u/ICBicmVhazvvu78gIO+7vyAg77u/ICAgXG7vu78gIO+7vyAgY2FzZSAnVEVYVEFSRUEnOlxu77u/ICDvu78gIO+7vyAgcS5wdXNoKGZvcm0uZWxlbWVudHNbaV0ubmFtZSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGZvcm0uZWxlbWVudHNbaV0udmFsdWUpKTtcbu+7vyAg77u/ICDvu78gIGJyZWFrO1xu77u/ICDvu78gIGNhc2UgJ1NFTEVDVCc6XG7vu78gIO+7vyAg77u/ICBzd2l0Y2ggKGZvcm0uZWxlbWVudHNbaV0udHlwZSkge1xu77u/ICDvu78gIO+7vyAgY2FzZSAnc2VsZWN0LW9uZSc6XG7vu78gIO+7vyAg77u/ICDvu78gIHEucHVzaChmb3JtLmVsZW1lbnRzW2ldLm5hbWUgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChmb3JtLmVsZW1lbnRzW2ldLnZhbHVlKSk7XG7vu78gIO+7vyAg77u/ICDvu78gIGJyZWFrO1xu77u/ICDvu78gIO+7vyAgY2FzZSAnc2VsZWN0LW11bHRpcGxlJzpcbu+7vyAg77u/ICDvu78gIO+7vyAgZm9yIChqID0gZm9ybS5lbGVtZW50c1tpXS5vcHRpb25zLmxlbmd0aCAtIDE7IGogPj0gMDsgaiA9IGogLSAxKSB7XG7vu78gIO+7vyAg77u/ICDvu78gIO+7vyAgaWYgKGZvcm0uZWxlbWVudHNbaV0ub3B0aW9uc1tqXS5zZWxlY3RlZCkge1xu77u/ICDvu78gIO+7vyAg77u/ICDvu78gIO+7vyAgcS5wdXNoKGZvcm0uZWxlbWVudHNbaV0ubmFtZSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGZvcm0uZWxlbWVudHNbaV0ub3B0aW9uc1tqXS52YWx1ZSkpO1xu77u/ICDvu78gIO+7vyAg77u/ICDvu78gIH1cbu+7vyAg77u/ICDvu78gIO+7vyAgfVxu77u/ICDvu78gIO+7vyAg77u/ICBicmVhaztcbu+7vyAg77u/ICDvu78gIH1cbu+7vyAg77u/ICDvu78gIGJyZWFrO1xu77u/ICDvu78gIGNhc2UgJ0JVVFRPTic6XG7vu78gIO+7vyAg77u/ICBzd2l0Y2ggKGZvcm0uZWxlbWVudHNbaV0udHlwZSkge1xu77u/ICDvu78gIO+7vyAgY2FzZSAncmVzZXQnOlxu77u/ICDvu78gIO+7vyAgY2FzZSAnc3VibWl0Jzpcbu+7vyAg77u/ICDvu78gIGNhc2UgJ2J1dHRvbic6XG7vu78gIO+7vyAg77u/ICDvu78gIHEucHVzaChmb3JtLmVsZW1lbnRzW2ldLm5hbWUgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChmb3JtLmVsZW1lbnRzW2ldLnZhbHVlKSk7XG7vu78gIO+7vyAg77u/ICDvu78gIGJyZWFrO1xu77u/ICDvu78gIO+7vyAgfVxu77u/ICDvu78gIO+7vyAgYnJlYWs7XG7vu78gIO+7vyAgfVxu77u/ICB9XG7vu78gIHJldHVybiBxLmpvaW4oXCImXCIpO1xufSIsInZhciBDU1JGVG9rZW4sIENsaWNrLCBDb21wb25lbnRVcmwsIEVWRU5UUywgTGluaywgUHJvZ3Jlc3NCYXIsIGJyb3dzZXJDb21wYXRpYmxlRG9jdW1lbnRQYXJzZXIsIGJyb3dzZXJJc250QnVnZ3ksIGJyb3dzZXJTdXBwb3J0c0N1c3RvbUV2ZW50cywgYnJvd3NlclN1cHBvcnRzUHVzaFN0YXRlLCBicm93c2VyU3VwcG9ydHNUdXJib2xpbmtzLCBieXBhc3NPbkxvYWRQb3BzdGF0ZSwgY2FjaGVDdXJyZW50UGFnZSwgY2FjaGVTaXplLCBjaGFuZ2VQYWdlLCBjbG9uZSwgY29uc3RyYWluUGFnZUNhY2hlVG8sIGNyZWF0ZURvY3VtZW50LCBjcm9zc09yaWdpblJlZGlyZWN0LCBjdXJyZW50U3RhdGUsIGVuYWJsZVByb2dyZXNzQmFyLCBlbmFibGVUcmFuc2l0aW9uQ2FjaGUsIGV4ZWN1dGVTY3JpcHRUYWdzLCBleHRyYWN0VGl0bGVBbmRCb2R5LCBmZXRjaCwgZmV0Y2hIaXN0b3J5LCBmZXRjaFJlcGxhY2VtZW50LCBoaXN0b3J5U3RhdGVJc0RlZmluZWQsIGluaXRpYWxpemVUdXJib2xpbmtzLCBpbnN0YWxsRG9jdW1lbnRSZWFkeVBhZ2VFdmVudFRyaWdnZXJzLCBpbnN0YWxsSGlzdG9yeUNoYW5nZUhhbmRsZXIsIGluc3RhbGxKcXVlcnlBamF4U3VjY2Vzc1BhZ2VVcGRhdGVUcmlnZ2VyLCBsb2FkZWRBc3NldHMsIG1hbnVhbGx5VHJpZ2dlckhhc2hDaGFuZ2VGb3JGaXJlZm94LCBwYWdlQ2FjaGUsIHBhZ2VDaGFuZ2VQcmV2ZW50ZWQsIHBhZ2VzQ2FjaGVkLCBwb3BDb29raWUsIHByb2Nlc3NSZXNwb25zZSwgcHJvZ3Jlc3NCYXIsIHJlY2FsbFNjcm9sbFBvc2l0aW9uLCByZWYsIHJlZmVyZXIsIHJlZmxlY3ROZXdVcmwsIHJlZmxlY3RSZWRpcmVjdGVkVXJsLCByZW1lbWJlckN1cnJlbnRTdGF0ZSwgcmVtZW1iZXJDdXJyZW50VXJsLCByZW1lbWJlclJlZmVyZXIsIHJlbW92ZU5vc2NyaXB0VGFncywgcmVxdWVzdE1ldGhvZElzU2FmZSwgcmVzZXRTY3JvbGxQb3NpdGlvbiwgc2V0QXV0b2ZvY3VzRWxlbWVudCwgdHJhbnNpdGlvbkNhY2hlRW5hYmxlZCwgdHJhbnNpdGlvbkNhY2hlRm9yLCB0cmlnZ2VyRXZlbnQsIHZpc2l0LCB4aHIsXG4gIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfSxcbiAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gIHNsaWNlID0gW10uc2xpY2UsXG4gIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG5wYWdlQ2FjaGUgPSB7fTtcblxuY2FjaGVTaXplID0gMTA7XG5cbnRyYW5zaXRpb25DYWNoZUVuYWJsZWQgPSBmYWxzZTtcblxucHJvZ3Jlc3NCYXIgPSBudWxsO1xuXG5jdXJyZW50U3RhdGUgPSBudWxsO1xuXG5sb2FkZWRBc3NldHMgPSBudWxsO1xuXG5yZWZlcmVyID0gbnVsbDtcblxuY3JlYXRlRG9jdW1lbnQgPSBudWxsO1xuXG54aHIgPSBudWxsO1xuXG5FVkVOVFMgPSB7XG4gIEJFRk9SRV9DSEFOR0U6ICdwYWdlOmJlZm9yZS1jaGFuZ2UnLFxuICBGRVRDSDogJ3BhZ2U6ZmV0Y2gnLFxuICBSRUNFSVZFOiAncGFnZTpyZWNlaXZlJyxcbiAgQ0hBTkdFOiAncGFnZTpjaGFuZ2UnLFxuICBVUERBVEU6ICdwYWdlOnVwZGF0ZScsXG4gIExPQUQ6ICdwYWdlOmxvYWQnLFxuICBSRVNUT1JFOiAncGFnZTpyZXN0b3JlJyxcbiAgQkVGT1JFX1VOTE9BRDogJ3BhZ2U6YmVmb3JlLXVubG9hZCcsXG4gIEVYUElSRTogJ3BhZ2U6ZXhwaXJlJ1xufTtcblxuZmV0Y2ggPSBmdW5jdGlvbih1cmwpIHtcbiAgdmFyIGNhY2hlZFBhZ2U7XG4gIHVybCA9IG5ldyBDb21wb25lbnRVcmwodXJsKTtcbiAgcmVtZW1iZXJSZWZlcmVyKCk7XG4gIGNhY2hlQ3VycmVudFBhZ2UoKTtcbiAgaWYgKHByb2dyZXNzQmFyICE9IG51bGwpIHtcbiAgICBwcm9ncmVzc0Jhci5zdGFydCgpO1xuICB9XG4gIGlmICh0cmFuc2l0aW9uQ2FjaGVFbmFibGVkICYmIChjYWNoZWRQYWdlID0gdHJhbnNpdGlvbkNhY2hlRm9yKHVybC5hYnNvbHV0ZSkpKSB7XG4gICAgZmV0Y2hIaXN0b3J5KGNhY2hlZFBhZ2UpO1xuICAgIHJldHVybiBmZXRjaFJlcGxhY2VtZW50KHVybCwgbnVsbCwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmZXRjaFJlcGxhY2VtZW50KHVybCwgcmVzZXRTY3JvbGxQb3NpdGlvbik7XG4gIH1cbn07XG5cbnRyYW5zaXRpb25DYWNoZUZvciA9IGZ1bmN0aW9uKHVybCkge1xuICB2YXIgY2FjaGVkUGFnZTtcbiAgY2FjaGVkUGFnZSA9IHBhZ2VDYWNoZVt1cmxdO1xuICBpZiAoY2FjaGVkUGFnZSAmJiAhY2FjaGVkUGFnZS50cmFuc2l0aW9uQ2FjaGVEaXNhYmxlZCkge1xuICAgIHJldHVybiBjYWNoZWRQYWdlO1xuICB9XG59O1xuXG5lbmFibGVUcmFuc2l0aW9uQ2FjaGUgPSBmdW5jdGlvbihlbmFibGUpIHtcbiAgaWYgKGVuYWJsZSA9PSBudWxsKSB7XG4gICAgZW5hYmxlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbkNhY2hlRW5hYmxlZCA9IGVuYWJsZTtcbn07XG5cbmVuYWJsZVByb2dyZXNzQmFyID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4gIGlmIChlbmFibGUgPT0gbnVsbCkge1xuICAgIGVuYWJsZSA9IHRydWU7XG4gIH1cbiAgaWYgKGVuYWJsZSkge1xuICAgIHJldHVybiBwcm9ncmVzc0JhciAhPSBudWxsID8gcHJvZ3Jlc3NCYXIgOiBwcm9ncmVzc0JhciA9IG5ldyBQcm9ncmVzc0JhcignaHRtbCcpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9ncmVzc0JhciAhPSBudWxsKSB7XG4gICAgICBwcm9ncmVzc0Jhci51bmluc3RhbGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2dyZXNzQmFyID0gbnVsbDtcbiAgfVxufTtcblxuZmV0Y2hSZXBsYWNlbWVudCA9IGZ1bmN0aW9uKHVybCwgb25Mb2FkRnVuY3Rpb24sIHNob3dQcm9ncmVzc0Jhcikge1xuICBpZiAoc2hvd1Byb2dyZXNzQmFyID09IG51bGwpIHtcbiAgICBzaG93UHJvZ3Jlc3NCYXIgPSB0cnVlO1xuICB9XG4gIHRyaWdnZXJFdmVudChFVkVOVFMuRkVUQ0gsIHtcbiAgICB1cmw6IHVybC5hYnNvbHV0ZVxuICB9KTtcbiAgaWYgKHhociAhPSBudWxsKSB7XG4gICAgeGhyLmFib3J0KCk7XG4gIH1cbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICB4aHIub3BlbignR0VUJywgdXJsLndpdGhvdXRIYXNoRm9ySUUxMGNvbXBhdGliaWxpdHkoKSwgdHJ1ZSk7XG4gIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAndGV4dC9odG1sLCBhcHBsaWNhdGlvbi94aHRtbCt4bWwsIGFwcGxpY2F0aW9uL3htbCcpO1xuICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1YSFItUmVmZXJlcicsIHJlZmVyZXIpO1xuICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvYztcbiAgICB0cmlnZ2VyRXZlbnQoRVZFTlRTLlJFQ0VJVkUsIHtcbiAgICAgIHVybDogdXJsLmFic29sdXRlXG4gICAgfSk7XG4gICAgaWYgKGRvYyA9IHByb2Nlc3NSZXNwb25zZSgpKSB7XG4gICAgICByZWZsZWN0TmV3VXJsKHVybCk7XG4gICAgICByZWZsZWN0UmVkaXJlY3RlZFVybCgpO1xuICAgICAgY2hhbmdlUGFnZS5hcHBseShudWxsLCBleHRyYWN0VGl0bGVBbmRCb2R5KGRvYykpO1xuICAgICAgbWFudWFsbHlUcmlnZ2VySGFzaENoYW5nZUZvckZpcmVmb3goKTtcbiAgICAgIGlmICh0eXBlb2Ygb25Mb2FkRnVuY3Rpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvbkxvYWRGdW5jdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyaWdnZXJFdmVudChFVkVOVFMuTE9BRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmID0gY3Jvc3NPcmlnaW5SZWRpcmVjdCgpIHx8IHVybC5hYnNvbHV0ZTtcbiAgICB9XG4gIH07XG4gIGlmIChwcm9ncmVzc0JhciAmJiBzaG93UHJvZ3Jlc3NCYXIpIHtcbiAgICB4aHIub25wcm9ncmVzcyA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBwZXJjZW50O1xuICAgICAgICBwZXJjZW50ID0gZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSA/IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsICogMTAwIDogcHJvZ3Jlc3NCYXIudmFsdWUgKyAoMTAwIC0gcHJvZ3Jlc3NCYXIudmFsdWUpIC8gMTA7XG4gICAgICAgIHJldHVybiBwcm9ncmVzc0Jhci5hZHZhbmNlVG8ocGVyY2VudCk7XG4gICAgICB9O1xuICAgIH0pKHRoaXMpO1xuICB9XG4gIHhoci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geGhyID0gbnVsbDtcbiAgfTtcbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IHVybC5hYnNvbHV0ZTtcbiAgfTtcbiAgcmV0dXJuIHhoci5zZW5kKCk7XG59O1xuXG5mZXRjaEhpc3RvcnkgPSBmdW5jdGlvbihjYWNoZWRQYWdlKSB7XG4gIGlmICh4aHIgIT0gbnVsbCkge1xuICAgIHhoci5hYm9ydCgpO1xuICB9XG4gIGNoYW5nZVBhZ2UoY2FjaGVkUGFnZS50aXRsZSwgY2FjaGVkUGFnZS5ib2R5KTtcbiAgcmVjYWxsU2Nyb2xsUG9zaXRpb24oY2FjaGVkUGFnZSk7XG4gIHJldHVybiB0cmlnZ2VyRXZlbnQoRVZFTlRTLlJFU1RPUkUpO1xufTtcblxuY2FjaGVDdXJyZW50UGFnZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3VycmVudFN0YXRlVXJsO1xuICBjdXJyZW50U3RhdGVVcmwgPSBuZXcgQ29tcG9uZW50VXJsKGN1cnJlbnRTdGF0ZS51cmwpO1xuICBwYWdlQ2FjaGVbY3VycmVudFN0YXRlVXJsLmFic29sdXRlXSA9IHtcbiAgICB1cmw6IGN1cnJlbnRTdGF0ZVVybC5yZWxhdGl2ZSxcbiAgICBib2R5OiBkb2N1bWVudC5ib2R5LFxuICAgIHRpdGxlOiBkb2N1bWVudC50aXRsZSxcbiAgICBwb3NpdGlvblk6IHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICBwb3NpdGlvblg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICBjYWNoZWRBdDogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgdHJhbnNpdGlvbkNhY2hlRGlzYWJsZWQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW5vLXRyYW5zaXRpb24tY2FjaGVdJykgIT0gbnVsbFxuICB9O1xuICByZXR1cm4gY29uc3RyYWluUGFnZUNhY2hlVG8oY2FjaGVTaXplKTtcbn07XG5cbnBhZ2VzQ2FjaGVkID0gZnVuY3Rpb24oc2l6ZSkge1xuICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgc2l6ZSA9IGNhY2hlU2l6ZTtcbiAgfVxuICBpZiAoL15bXFxkXSskLy50ZXN0KHNpemUpKSB7XG4gICAgcmV0dXJuIGNhY2hlU2l6ZSA9IHBhcnNlSW50KHNpemUpO1xuICB9XG59O1xuXG5jb25zdHJhaW5QYWdlQ2FjaGVUbyA9IGZ1bmN0aW9uKGxpbWl0KSB7XG4gIHZhciBjYWNoZVRpbWVzUmVjZW50Rmlyc3QsIGksIGtleSwgbGVuLCBwYWdlQ2FjaGVLZXlzLCByZXN1bHRzO1xuICBwYWdlQ2FjaGVLZXlzID0gT2JqZWN0LmtleXMocGFnZUNhY2hlKTtcbiAgY2FjaGVUaW1lc1JlY2VudEZpcnN0ID0gcGFnZUNhY2hlS2V5cy5tYXAoZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIHBhZ2VDYWNoZVt1cmxdLmNhY2hlZEF0O1xuICB9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGE7XG4gIH0pO1xuICByZXN1bHRzID0gW107XG4gIGZvciAoaSA9IDAsIGxlbiA9IHBhZ2VDYWNoZUtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBrZXkgPSBwYWdlQ2FjaGVLZXlzW2ldO1xuICAgIGlmICghKHBhZ2VDYWNoZVtrZXldLmNhY2hlZEF0IDw9IGNhY2hlVGltZXNSZWNlbnRGaXJzdFtsaW1pdF0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdHJpZ2dlckV2ZW50KEVWRU5UUy5FWFBJUkUsIHBhZ2VDYWNoZVtrZXldKTtcbiAgICByZXN1bHRzLnB1c2goZGVsZXRlIHBhZ2VDYWNoZVtrZXldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbmNoYW5nZVBhZ2UgPSBmdW5jdGlvbih0aXRsZSwgYm9keSwgY3NyZlRva2VuLCBydW5TY3JpcHRzKSB7XG4gIHRyaWdnZXJFdmVudChFVkVOVFMuQkVGT1JFX1VOTE9BRCk7XG4gIGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQoYm9keSwgZG9jdW1lbnQuYm9keSk7XG4gIGlmIChjc3JmVG9rZW4gIT0gbnVsbCkge1xuICAgIENTUkZUb2tlbi51cGRhdGUoY3NyZlRva2VuKTtcbiAgfVxuICBzZXRBdXRvZm9jdXNFbGVtZW50KCk7XG4gIGlmIChydW5TY3JpcHRzKSB7XG4gICAgZXhlY3V0ZVNjcmlwdFRhZ3MoKTtcbiAgfVxuICBjdXJyZW50U3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZTtcbiAgaWYgKHByb2dyZXNzQmFyICE9IG51bGwpIHtcbiAgICBwcm9ncmVzc0Jhci5kb25lKCk7XG4gIH1cbiAgdHJpZ2dlckV2ZW50KEVWRU5UUy5DSEFOR0UpO1xuICByZXR1cm4gdHJpZ2dlckV2ZW50KEVWRU5UUy5VUERBVEUpO1xufTtcblxuZXhlY3V0ZVNjcmlwdFRhZ3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF0dHIsIGNvcHksIGksIGosIGxlbiwgbGVuMSwgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHJlZiwgcmVmMSwgc2NyaXB0LCBzY3JpcHRzO1xuICBzY3JpcHRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQ6bm90KFtkYXRhLXR1cmJvbGlua3MtZXZhbD1cImZhbHNlXCJdKScpKTtcbiAgZm9yIChpID0gMCwgbGVuID0gc2NyaXB0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNjcmlwdCA9IHNjcmlwdHNbaV07XG4gICAgaWYgKCEoKHJlZiA9IHNjcmlwdC50eXBlKSA9PT0gJycgfHwgcmVmID09PSAndGV4dC9qYXZhc2NyaXB0JykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb3B5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgcmVmMSA9IHNjcmlwdC5hdHRyaWJ1dGVzO1xuICAgIGZvciAoaiA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgYXR0ciA9IHJlZjFbal07XG4gICAgICBjb3B5LnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIXNjcmlwdC5oYXNBdHRyaWJ1dGUoJ2FzeW5jJykpIHtcbiAgICAgIGNvcHkuYXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgY29weS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzY3JpcHQuaW5uZXJIVE1MKSk7XG4gICAgcGFyZW50Tm9kZSA9IHNjcmlwdC5wYXJlbnROb2RlLCBuZXh0U2libGluZyA9IHNjcmlwdC5uZXh0U2libGluZztcbiAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY29weSwgbmV4dFNpYmxpbmcpO1xuICB9XG59O1xuXG5yZW1vdmVOb3NjcmlwdFRhZ3MgPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuaW5uZXJIVE1MID0gbm9kZS5pbm5lckhUTUwucmVwbGFjZSgvPG5vc2NyaXB0W1xcU1xcc10qPzxcXC9ub3NjcmlwdD4vaWcsICcnKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5zZXRBdXRvZm9jdXNFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRvZm9jdXNFbGVtZW50LCBsaXN0O1xuICBhdXRvZm9jdXNFbGVtZW50ID0gKGxpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFthdXRvZm9jdXNdLCB0ZXh0YXJlYVthdXRvZm9jdXNdJykpW2xpc3QubGVuZ3RoIC0gMV07XG4gIGlmIChhdXRvZm9jdXNFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGF1dG9mb2N1c0VsZW1lbnQpIHtcbiAgICByZXR1cm4gYXV0b2ZvY3VzRWxlbWVudC5mb2N1cygpO1xuICB9XG59O1xuXG5yZWZsZWN0TmV3VXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIGlmICgodXJsID0gbmV3IENvbXBvbmVudFVybCh1cmwpKS5hYnNvbHV0ZSAhPT0gcmVmZXJlcikge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe1xuICAgICAgdHVyYm9saW5rczogdHJ1ZSxcbiAgICAgIHVybDogdXJsLmFic29sdXRlXG4gICAgfSwgJycsIHVybC5hYnNvbHV0ZSk7XG4gIH1cbn07XG5cbnJlZmxlY3RSZWRpcmVjdGVkVXJsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsb2NhdGlvbiwgcHJlc2VydmVkSGFzaDtcbiAgaWYgKGxvY2F0aW9uID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLVhIUi1SZWRpcmVjdGVkLVRvJykpIHtcbiAgICBsb2NhdGlvbiA9IG5ldyBDb21wb25lbnRVcmwobG9jYXRpb24pO1xuICAgIHByZXNlcnZlZEhhc2ggPSBsb2NhdGlvbi5oYXNOb0hhc2goKSA/IGRvY3VtZW50LmxvY2F0aW9uLmhhc2ggOiAnJztcbiAgICByZXR1cm4gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKGN1cnJlbnRTdGF0ZSwgJycsIGxvY2F0aW9uLmhyZWYgKyBwcmVzZXJ2ZWRIYXNoKTtcbiAgfVxufTtcblxuY3Jvc3NPcmlnaW5SZWRpcmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVkaXJlY3Q7XG4gIGlmICgoKHJlZGlyZWN0ID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdMb2NhdGlvbicpKSAhPSBudWxsKSAmJiAobmV3IENvbXBvbmVudFVybChyZWRpcmVjdCkpLmNyb3NzT3JpZ2luKCkpIHtcbiAgICByZXR1cm4gcmVkaXJlY3Q7XG4gIH1cbn07XG5cbnJlbWVtYmVyUmVmZXJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcmVmZXJlciA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG59O1xuXG5yZW1lbWJlckN1cnJlbnRVcmwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7XG4gICAgdHVyYm9saW5rczogdHJ1ZSxcbiAgICB1cmw6IGRvY3VtZW50LmxvY2F0aW9uLmhyZWZcbiAgfSwgJycsIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpO1xufTtcblxucmVtZW1iZXJDdXJyZW50U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlO1xufTtcblxubWFudWFsbHlUcmlnZ2VySGFzaENoYW5nZUZvckZpcmVmb3ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHVybDtcbiAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3gvKSAmJiAhKHVybCA9IG5ldyBDb21wb25lbnRVcmwpLmhhc05vSGFzaCgpKSB7XG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKGN1cnJlbnRTdGF0ZSwgJycsIHVybC53aXRob3V0SGFzaCgpKTtcbiAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaGFzaCA9IHVybC5oYXNoO1xuICB9XG59O1xuXG5yZWNhbGxTY3JvbGxQb3NpdGlvbiA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgcmV0dXJuIHdpbmRvdy5zY3JvbGxUbyhwYWdlLnBvc2l0aW9uWCwgcGFnZS5wb3NpdGlvblkpO1xufTtcblxucmVzZXRTY3JvbGxQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoZG9jdW1lbnQubG9jYXRpb24uaGFzaCkge1xuICAgIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICB9XG59O1xuXG5jbG9uZSA9IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gIHZhciBjb3B5LCBrZXksIHZhbHVlO1xuICBpZiAoKG9yaWdpbmFsID09IG51bGwpIHx8IHR5cGVvZiBvcmlnaW5hbCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3JpZ2luYWw7XG4gIH1cbiAgY29weSA9IG5ldyBvcmlnaW5hbC5jb25zdHJ1Y3RvcigpO1xuICBmb3IgKGtleSBpbiBvcmlnaW5hbCkge1xuICAgIHZhbHVlID0gb3JpZ2luYWxba2V5XTtcbiAgICBjb3B5W2tleV0gPSBjbG9uZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG5wb3BDb29raWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciByZWYsIHZhbHVlO1xuICB2YWx1ZSA9ICgocmVmID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAobmFtZSArIFwiPShcXFxcdyspXCIpKSkgIT0gbnVsbCA/IHJlZlsxXS50b1VwcGVyQ2FzZSgpIDogdm9pZCAwKSB8fCAnJztcbiAgZG9jdW1lbnQuY29va2llID0gbmFtZSArICc9OyBleHBpcmVzPVRodSwgMDEtSmFuLTcwIDAwOjAwOjAxIEdNVDsgcGF0aD0vJztcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuICB2YXIgZXZlbnQ7XG4gIGlmICh0eXBlb2YgUHJvdG90eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgIEV2ZW50LmZpcmUoZG9jdW1lbnQsIG5hbWUsIGRhdGEsIHRydWUpO1xuICB9XG4gIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICBpZiAoZGF0YSkge1xuICAgIGV2ZW50LmRhdGEgPSBkYXRhO1xuICB9XG4gIGV2ZW50LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgcmV0dXJuIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcblxucGFnZUNoYW5nZVByZXZlbnRlZCA9IGZ1bmN0aW9uKHVybCkge1xuICByZXR1cm4gIXRyaWdnZXJFdmVudChFVkVOVFMuQkVGT1JFX0NIQU5HRSwge1xuICAgIHVybDogdXJsXG4gIH0pO1xufTtcblxucHJvY2Vzc1Jlc3BvbnNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhc3NldHNDaGFuZ2VkLCBjbGllbnRPclNlcnZlckVycm9yLCBkb2MsIGV4dHJhY3RUcmFja0Fzc2V0cywgaW50ZXJzZWN0aW9uLCB2YWxpZENvbnRlbnQ7XG4gIGNsaWVudE9yU2VydmVyRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAoNDAwIDw9IChyZWYgPSB4aHIuc3RhdHVzKSAmJiByZWYgPCA2MDApO1xuICB9O1xuICB2YWxpZENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgcmV0dXJuICgoY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpKSAhPSBudWxsKSAmJiBjb250ZW50VHlwZS5tYXRjaCgvXig/OnRleHRcXC9odG1sfGFwcGxpY2F0aW9uXFwveGh0bWxcXCt4bWx8YXBwbGljYXRpb25cXC94bWwpKD86O3wkKS8pO1xuICB9O1xuICBleHRyYWN0VHJhY2tBc3NldHMgPSBmdW5jdGlvbihkb2MpIHtcbiAgICB2YXIgaSwgbGVuLCBub2RlLCByZWYsIHJlc3VsdHM7XG4gICAgcmVmID0gZG9jLnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKS5jaGlsZE5vZGVzO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGUgPSByZWZbaV07XG4gICAgICBpZiAoKHR5cGVvZiBub2RlLmdldEF0dHJpYnV0ZSA9PT0gXCJmdW5jdGlvblwiID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHVyYm9saW5rcy10cmFjaycpIDogdm9pZCAwKSAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChub2RlLmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuICBhc3NldHNDaGFuZ2VkID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgdmFyIGZldGNoZWRBc3NldHM7XG4gICAgbG9hZGVkQXNzZXRzIHx8IChsb2FkZWRBc3NldHMgPSBleHRyYWN0VHJhY2tBc3NldHMoZG9jdW1lbnQpKTtcbiAgICBmZXRjaGVkQXNzZXRzID0gZXh0cmFjdFRyYWNrQXNzZXRzKGRvYyk7XG4gICAgcmV0dXJuIGZldGNoZWRBc3NldHMubGVuZ3RoICE9PSBsb2FkZWRBc3NldHMubGVuZ3RoIHx8IGludGVyc2VjdGlvbihmZXRjaGVkQXNzZXRzLCBsb2FkZWRBc3NldHMpLmxlbmd0aCAhPT0gbG9hZGVkQXNzZXRzLmxlbmd0aDtcbiAgfTtcbiAgaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBpLCBsZW4sIHJlZiwgcmVzdWx0cywgdmFsdWU7XG4gICAgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcbiAgICAgIHJlZiA9IFtiLCBhXSwgYSA9IHJlZlswXSwgYiA9IHJlZlsxXTtcbiAgICB9XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlID0gYVtpXTtcbiAgICAgIGlmIChpbmRleE9mLmNhbGwoYiwgdmFsdWUpID49IDApIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG4gIGlmICghY2xpZW50T3JTZXJ2ZXJFcnJvcigpICYmIHZhbGlkQ29udGVudCgpKSB7XG4gICAgZG9jID0gY3JlYXRlRG9jdW1lbnQoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgaWYgKGRvYyAmJiAhYXNzZXRzQ2hhbmdlZChkb2MpKSB7XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgfVxufTtcblxuZXh0cmFjdFRpdGxlQW5kQm9keSA9IGZ1bmN0aW9uKGRvYykge1xuICB2YXIgdGl0bGU7XG4gIHRpdGxlID0gZG9jLnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJyk7XG4gIHJldHVybiBbdGl0bGUgIT0gbnVsbCA/IHRpdGxlLnRleHRDb250ZW50IDogdm9pZCAwLCByZW1vdmVOb3NjcmlwdFRhZ3MoZG9jLnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSksIENTUkZUb2tlbi5nZXQoZG9jKS50b2tlbiwgJ3J1blNjcmlwdHMnXTtcbn07XG5cbkNTUkZUb2tlbiA9IHtcbiAgZ2V0OiBmdW5jdGlvbihkb2MpIHtcbiAgICB2YXIgdGFnO1xuICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgZG9jID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiB0YWcgPSBkb2MucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpLFxuICAgICAgdG9rZW46IHRhZyAhPSBudWxsID8gdHlwZW9mIHRhZy5nZXRBdHRyaWJ1dGUgPT09IFwiZnVuY3Rpb25cIiA/IHRhZy5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSA6IHZvaWQgMCA6IHZvaWQgMFxuICAgIH07XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24obGF0ZXN0KSB7XG4gICAgdmFyIGN1cnJlbnQ7XG4gICAgY3VycmVudCA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKChjdXJyZW50LnRva2VuICE9IG51bGwpICYmIChsYXRlc3QgIT0gbnVsbCkgJiYgY3VycmVudC50b2tlbiAhPT0gbGF0ZXN0KSB7XG4gICAgICByZXR1cm4gY3VycmVudC5ub2RlLnNldEF0dHJpYnV0ZSgnY29udGVudCcsIGxhdGVzdCk7XG4gICAgfVxuICB9XG59O1xuXG5icm93c2VyQ29tcGF0aWJsZURvY3VtZW50UGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWlsZFRlc3RzVXNpbmcsIGNyZWF0ZURvY3VtZW50VXNpbmdET00sIGNyZWF0ZURvY3VtZW50VXNpbmdGcmFnbWVudCwgY3JlYXRlRG9jdW1lbnRVc2luZ1BhcnNlciwgY3JlYXRlRG9jdW1lbnRVc2luZ1dyaXRlLCBkb2NUZXN0LCBkb2NUZXN0cywgZSwgaSwgbGVuO1xuICBjcmVhdGVEb2N1bWVudFVzaW5nUGFyc2VyID0gZnVuY3Rpb24oaHRtbCkge1xuICAgIHJldHVybiAobmV3IERPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKGh0bWwsICd0ZXh0L2h0bWwnKTtcbiAgfTtcbiAgY3JlYXRlRG9jdW1lbnRVc2luZ0RPTSA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICB2YXIgZG9jO1xuICAgIGRvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7XG4gICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkb2M7XG4gIH07XG4gIGNyZWF0ZURvY3VtZW50VXNpbmdXcml0ZSA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICB2YXIgZG9jO1xuICAgIGRvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7XG4gICAgZG9jLm9wZW4oJ3JlcGxhY2UnKTtcbiAgICBkb2Mud3JpdGUoaHRtbCk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgcmV0dXJuIGRvYztcbiAgfTtcbiAgY3JlYXRlRG9jdW1lbnRVc2luZ0ZyYWdtZW50ID0gZnVuY3Rpb24oaHRtbCkge1xuICAgIHZhciBib2R5LCBkb2MsIGhlYWQsIGh0bWxXcmFwcGVyLCByZWYsIHJlZjE7XG4gICAgaGVhZCA9ICgocmVmID0gaHRtbC5tYXRjaCgvPGhlYWRbXj5dKj4oW1xcc1xcUy5dKik8XFwvaGVhZD4vaSkpICE9IG51bGwgPyByZWZbMF0gOiB2b2lkIDApIHx8ICc8aGVhZD48L2hlYWQ+JztcbiAgICBib2R5ID0gKChyZWYxID0gaHRtbC5tYXRjaCgvPGJvZHlbXj5dKj4oW1xcc1xcUy5dKik8XFwvYm9keT4vaSkpICE9IG51bGwgPyByZWYxWzBdIDogdm9pZCAwKSB8fCAnPGJvZHk+PC9ib2R5Pic7XG4gICAgaHRtbFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgaHRtbFdyYXBwZXIuaW5uZXJIVE1MID0gaGVhZCArIGJvZHk7XG4gICAgZG9jID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGRvYy5hcHBlbmRDaGlsZChodG1sV3JhcHBlcik7XG4gICAgcmV0dXJuIGRvYztcbiAgfTtcbiAgYnVpbGRUZXN0c1VzaW5nID0gZnVuY3Rpb24oY3JlYXRlTWV0aG9kKSB7XG4gICAgdmFyIGJ1aWxkVGVzdCwgZm9ybU5lc3RpbmdUZXN0LCBzdHJ1Y3R1cmVUZXN0O1xuICAgIGJ1aWxkVGVzdCA9IGZ1bmN0aW9uKGZhbGxiYWNrLCBwYXNzZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhc3NlczogcGFzc2VzKCksXG4gICAgICAgIGZhbGxiYWNrOiBmYWxsYmFja1xuICAgICAgfTtcbiAgICB9O1xuICAgIHN0cnVjdHVyZVRlc3QgPSBidWlsZFRlc3QoY3JlYXRlRG9jdW1lbnRVc2luZ1dyaXRlLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmMTtcbiAgICAgICAgcmV0dXJuICgocmVmID0gY3JlYXRlTWV0aG9kKCc8aHRtbD48Ym9keT48cD50ZXN0JykpICE9IG51bGwgPyAocmVmMSA9IHJlZi5ib2R5KSAhPSBudWxsID8gcmVmMS5jaGlsZE5vZGVzLmxlbmd0aCA6IHZvaWQgMCA6IHZvaWQgMCkgPT09IDE7XG4gICAgICB9O1xuICAgIH0pKHRoaXMpKTtcbiAgICBmb3JtTmVzdGluZ1Rlc3QgPSBidWlsZFRlc3QoY3JlYXRlRG9jdW1lbnRVc2luZ0ZyYWdtZW50LCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZiwgcmVmMTtcbiAgICAgICAgcmV0dXJuICgocmVmID0gY3JlYXRlTWV0aG9kKCc8aHRtbD48Ym9keT48Zm9ybT48L2Zvcm0+PGRpdj48L2Rpdj48L2JvZHk+PC9odG1sPicpKSAhPSBudWxsID8gKHJlZjEgPSByZWYuYm9keSkgIT0gbnVsbCA/IHJlZjEuY2hpbGROb2Rlcy5sZW5ndGggOiB2b2lkIDAgOiB2b2lkIDApID09PSAyO1xuICAgICAgfTtcbiAgICB9KSh0aGlzKSk7XG4gICAgcmV0dXJuIFtzdHJ1Y3R1cmVUZXN0LCBmb3JtTmVzdGluZ1Rlc3RdO1xuICB9O1xuICB0cnkge1xuICAgIGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG4gICAgICBkb2NUZXN0cyA9IGJ1aWxkVGVzdHNVc2luZyhjcmVhdGVEb2N1bWVudFVzaW5nUGFyc2VyKTtcbiAgICAgIHJldHVybiBjcmVhdGVEb2N1bWVudFVzaW5nUGFyc2VyO1xuICAgIH1cbiAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgZSA9IF9lcnJvcjtcbiAgICBkb2NUZXN0cyA9IGJ1aWxkVGVzdHNVc2luZyhjcmVhdGVEb2N1bWVudFVzaW5nRE9NKTtcbiAgICByZXR1cm4gY3JlYXRlRG9jdW1lbnRVc2luZ0RPTTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBkb2NUZXN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgZG9jVGVzdCA9IGRvY1Rlc3RzW2ldO1xuICAgICAgaWYgKCFkb2NUZXN0LnBhc3Nlcykge1xuICAgICAgICByZXR1cm4gZG9jVGVzdC5mYWxsYmFjaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkNvbXBvbmVudFVybCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQ29tcG9uZW50VXJsKG9yaWdpbmFsMSkge1xuICAgIHRoaXMub3JpZ2luYWwgPSBvcmlnaW5hbDEgIT0gbnVsbCA/IG9yaWdpbmFsMSA6IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG4gICAgaWYgKHRoaXMub3JpZ2luYWwuY29uc3RydWN0b3IgPT09IENvbXBvbmVudFVybCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWw7XG4gICAgfVxuICAgIHRoaXMuX3BhcnNlKCk7XG4gIH1cblxuICBDb21wb25lbnRVcmwucHJvdG90eXBlLndpdGhvdXRIYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaHJlZi5yZXBsYWNlKHRoaXMuaGFzaCwgJycpLnJlcGxhY2UoJyMnLCAnJyk7XG4gIH07XG5cbiAgQ29tcG9uZW50VXJsLnByb3RvdHlwZS53aXRob3V0SGFzaEZvcklFMTBjb21wYXRpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMud2l0aG91dEhhc2goKTtcbiAgfTtcblxuICBDb21wb25lbnRVcmwucHJvdG90eXBlLmhhc05vSGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhhc2gubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIENvbXBvbmVudFVybC5wcm90b3R5cGUuY3Jvc3NPcmlnaW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW4gIT09IChuZXcgQ29tcG9uZW50VXJsKS5vcmlnaW47XG4gIH07XG5cbiAgQ29tcG9uZW50VXJsLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVmO1xuICAgICh0aGlzLmxpbmsgIT0gbnVsbCA/IHRoaXMubGluayA6IHRoaXMubGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSkuaHJlZiA9IHRoaXMub3JpZ2luYWw7XG4gICAgcmVmID0gdGhpcy5saW5rLCB0aGlzLmhyZWYgPSByZWYuaHJlZiwgdGhpcy5wcm90b2NvbCA9IHJlZi5wcm90b2NvbCwgdGhpcy5ob3N0ID0gcmVmLmhvc3QsIHRoaXMuaG9zdG5hbWUgPSByZWYuaG9zdG5hbWUsIHRoaXMucG9ydCA9IHJlZi5wb3J0LCB0aGlzLnBhdGhuYW1lID0gcmVmLnBhdGhuYW1lLCB0aGlzLnNlYXJjaCA9IHJlZi5zZWFyY2gsIHRoaXMuaGFzaCA9IHJlZi5oYXNoO1xuICAgIHRoaXMub3JpZ2luID0gW3RoaXMucHJvdG9jb2wsICcvLycsIHRoaXMuaG9zdG5hbWVdLmpvaW4oJycpO1xuICAgIGlmICh0aGlzLnBvcnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aGlzLm9yaWdpbiArPSBcIjpcIiArIHRoaXMucG9ydDtcbiAgICB9XG4gICAgdGhpcy5yZWxhdGl2ZSA9IFt0aGlzLnBhdGhuYW1lLCB0aGlzLnNlYXJjaCwgdGhpcy5oYXNoXS5qb2luKCcnKTtcbiAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZSA9IHRoaXMuaHJlZjtcbiAgfTtcblxuICByZXR1cm4gQ29tcG9uZW50VXJsO1xuXG59KSgpO1xuXG5MaW5rID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgZXh0ZW5kKExpbmssIHN1cGVyQ2xhc3MpO1xuXG4gIExpbmsuSFRNTF9FWFRFTlNJT05TID0gWydodG1sJ107XG5cbiAgTGluay5hbGxvd0V4dGVuc2lvbnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXh0ZW5zaW9uLCBleHRlbnNpb25zLCBpLCBsZW47XG4gICAgZXh0ZW5zaW9ucyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4dGVuc2lvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbaV07XG4gICAgICBMaW5rLkhUTUxfRVhURU5TSU9OUy5wdXNoKGV4dGVuc2lvbik7XG4gICAgfVxuICAgIHJldHVybiBMaW5rLkhUTUxfRVhURU5TSU9OUztcbiAgfTtcblxuICBmdW5jdGlvbiBMaW5rKGxpbmsxKSB7XG4gICAgdGhpcy5saW5rID0gbGluazE7XG4gICAgaWYgKHRoaXMubGluay5jb25zdHJ1Y3RvciA9PT0gTGluaykge1xuICAgICAgcmV0dXJuIHRoaXMubGluaztcbiAgICB9XG4gICAgdGhpcy5vcmlnaW5hbCA9IHRoaXMubGluay5ocmVmO1xuICAgIHRoaXMub3JpZ2luYWxFbGVtZW50ID0gdGhpcy5saW5rO1xuICAgIHRoaXMubGluayA9IHRoaXMubGluay5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIExpbmsuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBMaW5rLnByb3RvdHlwZS5zaG91bGRJZ25vcmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jcm9zc09yaWdpbigpIHx8IHRoaXMuX2FuY2hvcmVkKCkgfHwgdGhpcy5fbm9uSHRtbCgpIHx8IHRoaXMuX29wdE91dCgpIHx8IHRoaXMuX3RhcmdldCgpO1xuICB9O1xuXG4gIExpbmsucHJvdG90eXBlLl9hbmNob3JlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5oYXNoLmxlbmd0aCA+IDAgfHwgdGhpcy5ocmVmLmNoYXJBdCh0aGlzLmhyZWYubGVuZ3RoIC0gMSkgPT09ICcjJykgJiYgKHRoaXMud2l0aG91dEhhc2goKSA9PT0gKG5ldyBDb21wb25lbnRVcmwpLndpdGhvdXRIYXNoKCkpO1xuICB9O1xuXG4gIExpbmsucHJvdG90eXBlLl9ub25IdG1sID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aG5hbWUubWF0Y2goL1xcLlthLXpdKyQvZykgJiYgIXRoaXMucGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cChcIlxcXFwuKD86XCIgKyAoTGluay5IVE1MX0VYVEVOU0lPTlMuam9pbignfCcpKSArIFwiKT8kXCIsICdnJykpO1xuICB9O1xuXG4gIExpbmsucHJvdG90eXBlLl9vcHRPdXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWdub3JlLCBsaW5rO1xuICAgIGxpbmsgPSB0aGlzLm9yaWdpbmFsRWxlbWVudDtcbiAgICB3aGlsZSAoIShpZ25vcmUgfHwgbGluayA9PT0gZG9jdW1lbnQpKSB7XG4gICAgICBpZ25vcmUgPSBsaW5rLmdldEF0dHJpYnV0ZSgnZGF0YS1uby10dXJib2xpbmsnKSAhPSBudWxsO1xuICAgICAgbGluayA9IGxpbmsucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlnbm9yZTtcbiAgfTtcblxuICBMaW5rLnByb3RvdHlwZS5fdGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGluay50YXJnZXQubGVuZ3RoICE9PSAwO1xuICB9O1xuXG4gIHJldHVybiBMaW5rO1xuXG59KShDb21wb25lbnRVcmwpO1xuXG5DbGljayA9IChmdW5jdGlvbigpIHtcbiAgQ2xpY2suaW5zdGFsbEhhbmRsZXJMYXN0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgQ2xpY2suaGFuZGxlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBDbGljay5oYW5kbGUsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgQ2xpY2suaGFuZGxlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IENsaWNrKGV2ZW50KTtcbiAgfTtcblxuICBmdW5jdGlvbiBDbGljayhldmVudDEpIHtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQxO1xuICAgIGlmICh0aGlzLmV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXh0cmFjdExpbmsoKTtcbiAgICBpZiAodGhpcy5fdmFsaWRGb3JUdXJib2xpbmtzKCkpIHtcbiAgICAgIGlmICghcGFnZUNoYW5nZVByZXZlbnRlZCh0aGlzLmxpbmsuYWJzb2x1dGUpKSB7XG4gICAgICAgIHZpc2l0KHRoaXMubGluay5ocmVmKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBDbGljay5wcm90b3R5cGUuX2V4dHJhY3RMaW5rID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpbms7XG4gICAgbGluayA9IHRoaXMuZXZlbnQudGFyZ2V0O1xuICAgIHdoaWxlICghKCFsaW5rLnBhcmVudE5vZGUgfHwgbGluay5ub2RlTmFtZSA9PT0gJ0EnKSkge1xuICAgICAgbGluayA9IGxpbmsucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaWYgKGxpbmsubm9kZU5hbWUgPT09ICdBJyAmJiBsaW5rLmhyZWYubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5saW5rID0gbmV3IExpbmsobGluayk7XG4gICAgfVxuICB9O1xuXG4gIENsaWNrLnByb3RvdHlwZS5fdmFsaWRGb3JUdXJib2xpbmtzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLmxpbmsgIT0gbnVsbCkgJiYgISh0aGlzLmxpbmsuc2hvdWxkSWdub3JlKCkgfHwgdGhpcy5fbm9uU3RhbmRhcmRDbGljaygpKTtcbiAgfTtcblxuICBDbGljay5wcm90b3R5cGUuX25vblN0YW5kYXJkQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudC53aGljaCA+IDEgfHwgdGhpcy5ldmVudC5tZXRhS2V5IHx8IHRoaXMuZXZlbnQuY3RybEtleSB8fCB0aGlzLmV2ZW50LnNoaWZ0S2V5IHx8IHRoaXMuZXZlbnQuYWx0S2V5O1xuICB9O1xuXG4gIHJldHVybiBDbGljaztcblxufSkoKTtcblxuUHJvZ3Jlc3NCYXIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBjbGFzc05hbWU7XG5cbiAgY2xhc3NOYW1lID0gJ3R1cmJvbGlua3MtcHJvZ3Jlc3MtYmFyJztcblxuICBmdW5jdGlvbiBQcm9ncmVzc0JhcihlbGVtZW50U2VsZWN0b3IpIHtcbiAgICB0aGlzLmVsZW1lbnRTZWxlY3RvciA9IGVsZW1lbnRTZWxlY3RvcjtcbiAgICB0aGlzLl90cmlja2xlID0gYmluZCh0aGlzLl90cmlja2xlLCB0aGlzKTtcbiAgICB0aGlzLnZhbHVlID0gMDtcbiAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMuY29udGVudCA9ICcnO1xuICAgIHRoaXMuc3BlZWQgPSAzMDA7XG4gICAgdGhpcy5pbnN0YWxsKCk7XG4gIH1cblxuICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5lbGVtZW50U2VsZWN0b3IpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLl91cGRhdGVTdHlsZSgpO1xuICB9O1xuXG4gIFByb2dyZXNzQmFyLnByb3RvdHlwZS51bmluc3RhbGwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIHJldHVybiBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHRoaXMuc3R5bGVFbGVtZW50KTtcbiAgfTtcblxuICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hZHZhbmNlVG8oNSk7XG4gIH07XG5cbiAgUHJvZ3Jlc3NCYXIucHJvdG90eXBlLmFkdmFuY2VUbyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlZjtcbiAgICBpZiAoKHZhbHVlID4gKHJlZiA9IHRoaXMudmFsdWUpICYmIHJlZiA8PSAxMDApKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLl91cGRhdGVTdHlsZSgpO1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IDEwMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcFRyaWNrbGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0VHJpY2tsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnZhbHVlID4gMCkge1xuICAgICAgdGhpcy5hZHZhbmNlVG8oMTAwKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNldCgpO1xuICAgIH1cbiAgfTtcblxuICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgc2V0VGltZW91dCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMub3BhY2l0eSA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpcy5fdXBkYXRlU3R5bGUoKTtcbiAgICAgIH07XG4gICAgfSkodGhpcyksIHRoaXMuc3BlZWQgLyAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMudmFsdWUgPSAwO1xuICAgICAgICBfdGhpcy5vcGFjaXR5ID0gMTtcbiAgICAgICAgcmV0dXJuIF90aGlzLl93aXRoU3BlZWQoMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl91cGRhdGVTdHlsZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pKHRoaXMpLCB0aGlzLnNwZWVkKTtcbiAgfTtcblxuICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuX3N0YXJ0VHJpY2tsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnRyaWNrbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyaWNrbGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQodGhpcy5fdHJpY2tsZSwgdGhpcy5zcGVlZCk7XG4gIH07XG5cbiAgUHJvZ3Jlc3NCYXIucHJvdG90eXBlLl9zdG9wVHJpY2tsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWxldGUgdGhpcy50cmlja2xpbmc7XG4gIH07XG5cbiAgUHJvZ3Jlc3NCYXIucHJvdG90eXBlLl90cmlja2xlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnRyaWNrbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkdmFuY2VUbyh0aGlzLnZhbHVlICsgTWF0aC5yYW5kb20oKSAvIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KHRoaXMuX3RyaWNrbGUsIHRoaXMuc3BlZWQpO1xuICB9O1xuXG4gIFByb2dyZXNzQmFyLnByb3RvdHlwZS5fd2l0aFNwZWVkID0gZnVuY3Rpb24oc3BlZWQsIGZuKSB7XG4gICAgdmFyIG9yaWdpbmFsU3BlZWQsIHJlc3VsdDtcbiAgICBvcmlnaW5hbFNwZWVkID0gdGhpcy5zcGVlZDtcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgcmVzdWx0ID0gZm4oKTtcbiAgICB0aGlzLnNwZWVkID0gb3JpZ2luYWxTcGVlZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIFByb2dyZXNzQmFyLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUgPSBmdW5jdGlvbihmb3JjZVJlcGFpbnQpIHtcbiAgICBpZiAoZm9yY2VSZXBhaW50ID09IG51bGwpIHtcbiAgICAgIGZvcmNlUmVwYWludCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZm9yY2VSZXBhaW50KSB7XG4gICAgICB0aGlzLl9jaGFuZ2VDb250ZW50VG9Gb3JjZVJlcGFpbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVFbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5fY3JlYXRlQ1NTUnVsZSgpO1xuICB9O1xuXG4gIFByb2dyZXNzQmFyLnByb3RvdHlwZS5fY2hhbmdlQ29udGVudFRvRm9yY2VSZXBhaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudCA9PT0gJycgPyAnICcgOiAnJztcbiAgfTtcblxuICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuX2NyZWF0ZUNTU1J1bGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50U2VsZWN0b3IgKyBcIi5cIiArIGNsYXNzTmFtZSArIFwiOjpiZWZvcmUge1xcbiAgY29udGVudDogJ1wiICsgdGhpcy5jb250ZW50ICsgXCInO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDc2ZmY7XFxuICBoZWlnaHQ6IDNweDtcXG4gIG9wYWNpdHk6IFwiICsgdGhpcy5vcGFjaXR5ICsgXCI7XFxuICB3aWR0aDogXCIgKyB0aGlzLnZhbHVlICsgXCIlO1xcbiAgdHJhbnNpdGlvbjogd2lkdGggXCIgKyB0aGlzLnNwZWVkICsgXCJtcyBlYXNlLW91dCwgb3BhY2l0eSBcIiArICh0aGlzLnNwZWVkIC8gMikgKyBcIm1zIGVhc2UtaW47XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsMCwwKTtcXG59XCI7XG4gIH07XG5cbiAgcmV0dXJuIFByb2dyZXNzQmFyO1xuXG59KSgpO1xuXG5ieXBhc3NPbkxvYWRQb3BzdGF0ZSA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCA1MDApO1xufTtcblxuaW5zdGFsbERvY3VtZW50UmVhZHlQYWdlRXZlbnRUcmlnZ2VycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIChmdW5jdGlvbigpIHtcbiAgICB0cmlnZ2VyRXZlbnQoRVZFTlRTLkNIQU5HRSk7XG4gICAgcmV0dXJuIHRyaWdnZXJFdmVudChFVkVOVFMuVVBEQVRFKTtcbiAgfSksIHRydWUpO1xufTtcblxuaW5zdGFsbEpxdWVyeUFqYXhTdWNjZXNzUGFnZVVwZGF0ZVRyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiBqUXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGpRdWVyeShkb2N1bWVudCkub24oJ2FqYXhTdWNjZXNzJywgZnVuY3Rpb24oZXZlbnQsIHhociwgc2V0dGluZ3MpIHtcbiAgICAgIGlmICghalF1ZXJ5LnRyaW0oeGhyLnJlc3BvbnNlVGV4dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyaWdnZXJFdmVudChFVkVOVFMuVVBEQVRFKTtcbiAgICB9KTtcbiAgfVxufTtcblxuaW5zdGFsbEhpc3RvcnlDaGFuZ2VIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGNhY2hlZFBhZ2UsIHJlZjtcbiAgaWYgKChyZWYgPSBldmVudC5zdGF0ZSkgIT0gbnVsbCA/IHJlZi50dXJib2xpbmtzIDogdm9pZCAwKSB7XG4gICAgaWYgKGNhY2hlZFBhZ2UgPSBwYWdlQ2FjaGVbKG5ldyBDb21wb25lbnRVcmwoZXZlbnQuc3RhdGUudXJsKSkuYWJzb2x1dGVdKSB7XG4gICAgICBjYWNoZUN1cnJlbnRQYWdlKCk7XG4gICAgICByZXR1cm4gZmV0Y2hIaXN0b3J5KGNhY2hlZFBhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmlzaXQoZXZlbnQudGFyZ2V0LmxvY2F0aW9uLmhyZWYpO1xuICAgIH1cbiAgfVxufTtcblxuaW5pdGlhbGl6ZVR1cmJvbGlua3MgPSBmdW5jdGlvbigpIHtcbiAgcmVtZW1iZXJDdXJyZW50VXJsKCk7XG4gIHJlbWVtYmVyQ3VycmVudFN0YXRlKCk7XG4gIGNyZWF0ZURvY3VtZW50ID0gYnJvd3NlckNvbXBhdGlibGVEb2N1bWVudFBhcnNlcigpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIENsaWNrLmluc3RhbGxIYW5kbGVyTGFzdCwgdHJ1ZSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZW1lbWJlckN1cnJlbnRVcmwoKTtcbiAgICByZXR1cm4gcmVtZW1iZXJDdXJyZW50U3RhdGUoKTtcbiAgfSwgZmFsc2UpO1xuICByZXR1cm4gYnlwYXNzT25Mb2FkUG9wc3RhdGUoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGluc3RhbGxIaXN0b3J5Q2hhbmdlSGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn07XG5cbmhpc3RvcnlTdGF0ZUlzRGVmaW5lZCA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlICE9PSB2b2lkIDAgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLzJbNnw3XS8pO1xuXG5icm93c2VyU3VwcG9ydHNQdXNoU3RhdGUgPSB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgJiYgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlICYmIGhpc3RvcnlTdGF0ZUlzRGVmaW5lZDtcblxuYnJvd3NlcklzbnRCdWdneSA9ICFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DcmlPU1xcLy8pO1xuXG5yZXF1ZXN0TWV0aG9kSXNTYWZlID0gKHJlZiA9IHBvcENvb2tpZSgncmVxdWVzdF9tZXRob2QnKSkgPT09ICdHRVQnIHx8IHJlZiA9PT0gJyc7XG5cbmJyb3dzZXJTdXBwb3J0c1R1cmJvbGlua3MgPSBicm93c2VyU3VwcG9ydHNQdXNoU3RhdGUgJiYgYnJvd3NlcklzbnRCdWdneSAmJiByZXF1ZXN0TWV0aG9kSXNTYWZlO1xuXG5icm93c2VyU3VwcG9ydHNDdXN0b21FdmVudHMgPSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICYmIGRvY3VtZW50LmNyZWF0ZUV2ZW50O1xuXG5pZiAoYnJvd3NlclN1cHBvcnRzQ3VzdG9tRXZlbnRzKSB7XG4gIGluc3RhbGxEb2N1bWVudFJlYWR5UGFnZUV2ZW50VHJpZ2dlcnMoKTtcbiAgaW5zdGFsbEpxdWVyeUFqYXhTdWNjZXNzUGFnZVVwZGF0ZVRyaWdnZXIoKTtcbn1cblxuaWYgKGJyb3dzZXJTdXBwb3J0c1R1cmJvbGlua3MpIHtcbiAgdmlzaXQgPSBmZXRjaDtcbiAgaW5pdGlhbGl6ZVR1cmJvbGlua3MoKTtcbn0gZWxzZSB7XG4gIHZpc2l0ID0gZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gIH07XG59XG5cbnRoaXMuVHVyYm9saW5rcyA9IHtcbiAgdmlzaXQ6IHZpc2l0LFxuICBwYWdlc0NhY2hlZDogcGFnZXNDYWNoZWQsXG4gIGVuYWJsZVRyYW5zaXRpb25DYWNoZTogZW5hYmxlVHJhbnNpdGlvbkNhY2hlLFxuICBlbmFibGVQcm9ncmVzc0JhcjogZW5hYmxlUHJvZ3Jlc3NCYXIsXG4gIGFsbG93TGlua0V4dGVuc2lvbnM6IExpbmsuYWxsb3dFeHRlbnNpb25zLFxuICBzdXBwb3J0ZWQ6IGJyb3dzZXJTdXBwb3J0c1R1cmJvbGlua3MsXG4gIEVWRU5UUzogY2xvbmUoRVZFTlRTKVxufTsiXX0=
